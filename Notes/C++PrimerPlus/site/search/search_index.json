{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C++ Primer Plus","text":"<p>Personal notes / Summary</p>"},{"location":"#chapter-1-getting-started","title":"Chapter 1: Getting Started","text":"<p>Computer language deal with 2 concepts: DATA (information) &amp; ALGORITHMS (methods)</p> <p>C++ joins three programming categories:</p> <ul> <li>C   - Procedural language</li> <li>C++ - Object-oriented language, represented by: class enhancements</li> <li>C++ - Generic programming (eg. write function for a generic (unspecified) type once and use it for variety of actual types)</li> </ul> <p>Object-Oriented Programming (OOP):</p> <ul> <li>Class - Defines what data is used to represent object and what operations can be performed on it; data form; [name, date, ...]</li> <li>Object - data structure; [David, 19.01.2000, ...]</li> </ul> <p>Bottom-up programming - going from lower level (eg. classes) to higher (eg. program design) OOP facilitates creating reusable code with:</p> <ul> <li>Information hiding - safeguard from improper access</li> <li>Polymorphism - allows creating multiple definitions for operators and functions</li> <li>Inheritance - allows deriving new classes from old ones</li> </ul> <p>Mechanics of creating a Program:</p> <ol> <li>Write and save program: source code <code>code.cpp</code></li> <li>Compile the source code: translation to machine language <code>gcc ./code.cpp</code></li> <li>Link with additional code: libraries, functions; The output is executable code</li> </ol> <p>Common phrases:</p> <ul> <li>Compile - Compile code in the file you are currently in</li> <li>Build/Make - Compile code for all source code files in the project</li> <li>Build All - Compile all source code files from scratch</li> <li>Link - Combine compiled source code with necessary library code</li> <li>Run/Execute - Run the program ./prog or exe</li> <li>Debug - Run program with option of going  through step-by-step</li> </ul>"},{"location":"#chapter-2-setting-out-to-c","title":"Chapter 2: Setting Out to C++","text":"List of what you will learn  <pre><code>    1. Creation and format of C++ program &lt;/br&gt;\n    2. The #include directive &lt;/br&gt;\n    3. The main() function &lt;/br&gt;\n    4. Using cout object for output &lt;/br&gt;\n    5. Using cin object for input&lt;/br&gt;\n    6. How/when use endl&lt;/br&gt;\n    7. Placing comments in C++ program &lt;/br&gt;\n    8. Declaring and using variables and functions&lt;/br&gt;\n</code></pre> <p>C++ is:</p> <ul> <li><code>case sensitive</code> - it distinguish uppercase from lowercase characters</li> <li><code>spelling sensitive</code> - kout or coot instead of <code>cout</code> will give you error</li> </ul> <p>Construction of C++ program: C++ program is constructed from functions \"C++ building blocks\". Typical program is organized to major tasks with separated functions to handle those tasks. Below is simple function named <code>main()</code>:</p> <pre><code>// myfirst.cpp -- displays a message\n#include &lt;iostream&gt;                          // a PREPROCESSOR directive\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;                     // make definitions visible\n    cout &lt;&lt; \"Come up and C++ me some time.\"; // message\n    cout &lt;&lt; endl;                            // start a new line\n    cout &lt;&lt; \"You won\u2019t regret it!\" &lt;&lt; endl;  // more output\n    return 0;                                // terminate main()\n} // end of function body\n</code></pre> <p>The fundamental structure of program (listing) above is:</p> <pre><code>int main()\n{\n    statements\n    return 0;\n}\n</code></pre> <p>It have two parts: function header <code>int main()</code> and function body enclosed in brackets.</p> <p>C++ uses <code>preprocerssor</code> - Program, that process a source file before the main compilation takes place; directives whose names begins with <code>#</code>. Program above uses <code>#include</code> directive (thus they are named include files - they are included in other files/included at the beggining) of <code>iostream</code> file that is responsible with communication with external world (input/output).</p> <ul> <li><code>using namespace std</code> - use all namespace directives from std library <code>std::</code></li> <li><code>using std::cout</code> - use only one <code>std::</code> qualifier</li> <li><code>cout</code> - predefined object that knows how to display variety of things</li> <li>Operator Overloading - the same operator with different meanings, eg.: \"<code>&lt;&lt;</code>\" is insertion operator and bitwise left-shift operator. The meaning is defined by context.</li> <li><code>endl</code> - Moves screen coursor to the new line; equvalent to newline character \"<code>\\n</code>\" from C, but <code>endl</code> guarantees that output will be <code>flushed</code>. Special notations (to <code>cout</code>) like this are called <code>manipulators</code></li> <li>tokens - indivisible elements in a line of code, eg.: <code>int</code></li> </ul> <p>Statements</p> <p>To store information on a computer you need:</p> <ul> <li>identify storage location</li> <li>identify how much storage information requires</li> <li>C++ program - collection of functions.</li> <li>Function - collection of statements.</li> <li><code>=</code> - assignment operator from right to left (assign value to a storage location).</li> <li><code>&lt;&lt;</code> - insertion operator - defined in ostream class</li> <li><code>&gt;&gt;</code> - extraction operator - defined in istream class</li> </ul> <pre><code>/* \n- declaration statement \n- definition - variable is declared and it causes compiler to allocate memory space\n for variable. Declaration don't need to be the definition (something is declared\n but it don't need to have allocated space)\n */\nint x;  \n\nx = 10; // - assignement statement - provide/assign value to variable/storage location\nx = x - 1 // - arithmetic expression \n</code></pre> <p>class - data type that user defines to define class - describe what information it can represent and what action  you can perform on data or in other words</p> <pre><code>x = sqrt(6.25)        --&gt;    function call                 --&gt;    |code for sqrt|\n                                                                        \u25bc\n|assign return to x|  &lt;--    return to calling function    &lt;--    | sqrt return |\n</code></pre> <p>Argument <code>6.25</code> is passed to a function sqrt</p> <p>function prototype - is for function as variable declaration for variables decribe the function interface and needs to be before function definition;  if you use it you will need to provide prototype in source code or with #include</p> <p>function definition - code for function workings</p> <p>keyword - vocabulary of a computer language: int, void, return, double, etc.. - the list of them is in appendix \"C++ Reserved Words\"; functions and object names are not keywords</p> <pre><code>//function prototype; initial double is type of returned value from sqrt; \n//double in sqrt(double) is passed argument for sqrt \ndouble sqrt(double);  \n</code></pre> <p>exit values - (tested) return values of executed program. default convention: 0 - program ran successfully; &gt;0 - error/problem</p> <ul> <li>Declaration statement \u2014 A declaration statement announces the name and the   type of a variable used in a function.</li> <li>Assignment statement \u2014 An assignment statement uses the assignment operator (=)   to assign a value to a variable.</li> <li>Message statement \u2014 A message statement sends a message to an object, initiating   some sort of action.</li> <li>Function call \u2014 A function call activates a function.When the called function ter-   minates, the program returns to the statement in the calling function immediately   following the function call.</li> <li>Function prototype \u2014 A function prototype declares the return type for a function,   along with the number and type of arguments the function expects.</li> <li>Return statement \u2014 A return statement sends a value from a called function back   to the calling function.</li> </ul>"},{"location":"#chapter-3-dealing-with-data","title":"Chapter 3: Dealing with Data","text":"List of what you will learn  <pre><code>- Rules for naming C++ variables\n- C++\u2019s built-in integer types: unsigned long, long, unsigned int, int, unsigned\nshort, short, char, unsigned char, signed char, bool\n- C++11\u2019s additions: unsigned long long and long long\n- The climits file, which represents system limits for various integer types\n- Numeric literals (constants) of various integer types\n- Using the const qualifier to create symbolic constants\n- C++\u2019s built-in floating-point types: float, double, and long double\n- The cfloat file, which represents system limits for various floating-point types\n- Numeric literals of various floating-point types\n- C++\u2019s arithmetic operators\n- Automatic type conversions\n- Forced type conversions (type casts)\n</code></pre> <p>Build-in C++ data types:</p> <ul> <li>fundamental types - integers and floating point numbers</li> <li>compound types - arrays, strings, pointers and structures, explained in Chapter 4</li> </ul> <p>To store item of information on a computer you need to track:</p> <ul> <li>Where the information is stored</li> <li>What value is kept there</li> <li>What kind of information is stored</li> </ul> <p>C++ naming rules:</p> <ul> <li>Only characters you can use in names are: alphabetic characters, numeric digits and underscore character</li> <li>The first character in a name cannot be a nu,eric digit</li> <li>Uppercase characters are considered distinct from lowercase characters</li> <li>You can't use C++ keyword for a name</li> <li>Names beginning with two underscore characters or with an underscore character followed by an uppercase letter are reseved for use by implementatio (the compiler and the resources it uses).</li> <li>Names beggining with single underscore character are reserved for use a global identifiers bt the implementation</li> <li>C++ places no limits on the length of a name, and all characters in a name are significant (but some platforms can have their own length limits).</li> </ul> <p>Data</p> <ul> <li>width - term for the amount of memory used to hold variable</li> <li>operator - build in language element that operates on one or more items to produce a value (addition operator <code>+</code> adds two values)</li> <li>sizeof - return size in bytes of a tupe or variable</li> <li>climits - header file - contain information about integer type limits,   check limits.cpp</li> </ul> limits.cpp <pre><code>#include &lt;iostream&gt;\n#include &lt;climits&gt; // use limits.h for older systems\n\nint main()\n{\n    using namespace std;\n    int n_int = INT_MAX;      // initialize n_int to max int value\n    short n_short = SHRT_MAX; // symbols defined in climits file\n    long n_long = LONG_MAX;\n    long long n_llong = LLONG_MAX;\n    // sizeof operator yields size of type or of variable\n    cout &lt;&lt; \"int is \" &lt;&lt; sizeof(int) &lt;&lt; \" bytes.\" &lt;&lt; endl;\n    cout &lt;&lt; \"short is \" &lt;&lt; sizeof n_short &lt;&lt; \" bytes.\" &lt;&lt; endl;\n    cout &lt;&lt; \"long is \" &lt;&lt; sizeof n_long &lt;&lt; \" bytes.\" &lt;&lt; endl;\n    cout &lt;&lt; \"long long is \" &lt;&lt; sizeof n_llong &lt;&lt; \" bytes.\" &lt;&lt; endl;\n    cout &lt;&lt; endl;\n    cout &lt;&lt; \"Maximum values:\" &lt;&lt; endl;\n    cout &lt;&lt; \"int: \" &lt;&lt; n_int &lt;&lt; endl;\n    cout &lt;&lt; \"short: \" &lt;&lt; n_short &lt;&lt; endl;\n    cout &lt;&lt; \"long: \" &lt;&lt; n_long &lt;&lt; endl;\n    cout &lt;&lt; \"long long: \" &lt;&lt; n_llong &lt;&lt; endl\n         &lt;&lt; endl;\n    cout &lt;&lt; \"Minimum int value = \" &lt;&lt; INT_MIN &lt;&lt; endl;\n    cout &lt;&lt; \"Bits per byte = \" &lt;&lt; CHAR_BIT &lt;&lt; endl;\n    return 0;\n}\n\n/*\nSymbolic Constant Represents:\nCHAR_BIT Number of bits in a char\nCHAR_MAX Maximum char value\nCHAR_MIN Minimum char value\nSCHAR_MAX Maximum signed char value\nSCHAR_MIN Minimum signed char value\nUCHAR_MAX Maximum unsigned char value\nSHRT_MAX Maximum short value\nSHRT_MIN Minimum short value\nUSHRT_MAX Maximum unsigned short value\nINT_MAX Maximum int value\nINT_MIN Minimum int value\nUINT_MAX Maximum unsigned int value\nLONG_MAX Maximum long value\nLONG_MIN Minimum long value\nULONG_MAX Maximum unsigned long value\nLLONG_MAX Maximum long long value\nLLONG_MIN Minimum long long value\nULLONG_MAX Maximum unsigned long long value\n*/\n</code></pre>"},{"location":"#initialization","title":"Initialization","text":"<p>Combines assignment with declaration, for example:</p> <pre><code>int i_sth = INT_MAX; \nint owls = 101; // traditional C initialization, sets owls to 101\nint wrens(432); // alternative C++ syntax, set wrens to 432\n</code></pre> <p>Not initialized variables are indeterminate - value is what was previously in memory, assigned to the newly declared variable;</p> <p>C++11 initialization:</p> <ul> <li>using a braced initializer <code>{}</code></li> <li>braces can be left empty, in which case the variable is initialized to 0</li> <li>it can be used with or without the = sign</li> <li>it provides better protection against type conversion errors (more on end of this chapter)</li> </ul> <pre><code>int emus{7};        // set emus to 5\nint rheas = {12};   // set rheas to 12\nint rocs = {};      // set rocs to 0\nint psychics{};     // set psychics to\n</code></pre> <p>Exceeding max value (range of data type) will make value assign the lowest value possible (like odometer).  </p> <p>Amount of allocated memory for <code>int</code> (and thus max range/value) can differ from devices and compilers, but is natural (computer handles it most efficiently); <code>long</code> type is more reliable (32bit), but worse in other aspects.</p>"},{"location":"#literals","title":"Literals","text":"<p>Constant values that are assigned to the constant variables.</p>"},{"location":"#integer-literals","title":"Integer literals","text":"<ul> <li>042 - octal value - base 8</li> <li>42 - decimal value, base 10  </li> <li>0x42 - hexadecimal value - base 16</li> </ul> <p>Example in hexoctl.cpp</p> hexoct1.cpp <pre><code>// hexoct1.cpp -- shows hex and octal literals\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int chest = 42;   // decimal integer literal\n    int waist = 0x42; // hexadecimal integer literal\n    int inseam = 042; // octal integer literal\n    cout &lt;&lt; \"Monsieur cuts a striking figure!\\n\";\n    cout &lt;&lt; \"chest = \" &lt;&lt; chest &lt;&lt; \" (42 in decimal)\\n\";\n    cout &lt;&lt; \"waist = \" &lt;&lt; waist &lt;&lt; \" (0x42 in hex)\\n\";\n    cout &lt;&lt; \"inseam = \" &lt;&lt; inseam &lt;&lt; \" (042 in octal)\\n\";\n    return 0;\n}\n</code></pre> <p>You can <code>cout</code> manipulators <code>dec</code>, <code>oct</code>, <code>hex</code> for changing numer base. Example in hexoct2.cpp</p> hexoct2.cpp <pre><code>// hexoct2.cpp -- display values in hex and octal\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    using namespace std;\n    int chest = 42;\n    int waist = 42;\n    int inseam = 42;\n    cout &lt;&lt; \"Monsieur cuts a striking figure!\" &lt;&lt; endl;\n    cout &lt;&lt; \"chest = \" &lt;&lt; chest &lt;&lt; \" (decimal for 42)\" &lt;&lt; endl;\n    cout &lt;&lt; hex; // manipulator for changing number base\n    cout &lt;&lt; \"waist = \" &lt;&lt; waist &lt;&lt; \" (hexadecimal for 42)\" &lt;&lt; endl;\n    cout &lt;&lt; oct; // manipulator for changing number base\n    cout &lt;&lt; \"inseam = \" &lt;&lt; inseam &lt;&lt; \" (octal for 42)\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"#character-literals","title":"Character literals","text":"<p>Suffix for constant:</p> <p><code>l</code>, <code>L</code> - 32bit long constant <code>u</code>, <code>U</code> - unsigned int constant <code>ul</code> (any combination of letters) - unsigned long constant <code>ll</code>, <code>LL</code> - C++11 long long constant <code>ULL</code> - C++11 unsigned long long constant</p> data Stored as <code>1500</code> 16bit int <code>1500L</code> 32bit long <p>Characters set, like ASCII defines which number defines character. Thus <code>char</code> is <code>int</code> data type value and operations on it like on ints can be performed. Printed characters are processed through <code>cout</code>.</p> <p>Using single quotation marks, eg. <code>'A'</code> for character display is better, because it doesn't assume particular code.</p> <p>Escape codes represent characters, that you cannot input from keyboard notrmally:</p> Table of escape codes Character Name ASCII Symbol C++ Code ASCII Decimal Code ASCII Hex Code Newline NL (LF) <code>\\n</code> 10 <code>0xA</code> Horizontal tab HT <code>\\t</code> 9 <code>0x9</code> Vertical tab VT <code>\\v</code> 11 <code>0xB</code> Backspace BS <code>\\b</code> 8 <code>0x8</code> Carriage return CR <code>\\r</code> 13 <code>0xD</code> Alert BEL <code>\\a</code> 7 <code>0x7</code> Backslash \\ <code>\\\\</code> 92 <code>0x5C</code> Question mark ? <code>\\\\?</code> 63 <code>0x3F</code> Single quote \u2019 <code>\\\\'</code> 39 <code>0x27</code> Double quote \u201d <code>\\\\\"</code> 34 <code>0x22</code> Example of use: bondini.cpp <pre><code>// bondini.cpp -- using escape sequences\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"\\aOperation \\\"HyperHype\\\" is now activated!\\n\";\n    cout &lt;&lt; \"Enter your agent code:________\\b\\b\\b\\b\\b\\b\\b\\b\";\n    long code;\n    cin &gt;&gt; code;\n    cout &lt;&lt; \"\\aYou entered \" &lt;&lt; code &lt;&lt; \"...\\n\";\n    cout &lt;&lt; \"\\aCode verified! Proceed with Plan Z3!\\n\";\n    return 0;\n}\n</code></pre> <p>Universal Character Names - used for international characters like French vowel. It starts with <code>\\u</code> ot <code>\\U</code>, eg.: <code>cout &lt;&lt; \"g\\u00E2teau.</code> - ISO 10646</p> <p><code>wchar_t</code> - wide character set - for characters that don't fit within 8-bit bute (eg.: Japanese kanji system). It is 16-bit or larger. <code>wchar_t</code> can vary from one implementation to another.</p>"},{"location":"#c11-types","title":"C++11 types","text":"<ul> <li><code>char16_t</code> - unsigned 16-bits, use <code>u</code> prefix for <code>char16_t</code>, eg.: <code>u\"good\"</code> or <code>u'R'</code></li> <li><code>char32_t</code> - unsigned 32-bits, use <code>U</code> prefix for <code>char32_t</code></li> </ul>"},{"location":"#member-function-oop","title":"Member function (OOP)","text":"<p>Eg. <code>cout.put()</code>, belongs to a class and describes a method for manipulating class data. <code>put()</code> is a class member function. <code>.</code> is membersip operator. You can use member function only with particular object in that class (in this case <code>ostream</code>), such as <code>cout</code> class object in this case.</p> <p>In short: class - <code>ostream</code>, class object - <code>cout</code>, function name (member function) - <code>put()</code></p> <p><code>cout.put()</code> is alternative for using <code>&lt;&lt;</code> operator to display character.</p>"},{"location":"#bool-type","title":"bool type","text":"<p>C++ interprets nonzero values as true and zeros values as false You can use <code>bool</code> type to reprsent those values:</p> <pre><code>bool read = true; \n</code></pre> <p>The literals true and false can be converted to type int by promotion, with true converting to 1 and false to 0 and vice-versa:</p> <pre><code>int ans = true;         // ans assigned 1\nint promise = false;    // promise assigned 0\nbool is_tru = -500;     // any non-zero will be converted to true \n</code></pre>"},{"location":"#const-qualifier","title":"const qualifier","text":"<ul> <li>if attempted to change, compilator will give error</li> <li>if value is not provided during declaration, it will be unspecified, that you cannot modify</li> <li>you can use scoping rules (chapter 9) to limit it to particular function or files (advantage over #define, second advantage is you can use const with elaborate types, such as arrays or structures)</li> </ul> <p>Example of use: <code>const int Months = 12;</code></p>"},{"location":"#floating-point-numbers","title":"Floating-Point Numbers","text":"<p>There is two ways of writing floating-point numbers:</p> <ul> <li>standard, decimal-point notation, eg.: <code>12.34</code></li> <li>representing floating-point values is called E notation, eg.: <code>-3.45E6</code> = -3.4 10^6* (where <code>6</code> - exponent, <code>3.45</code> - mantissa).</li> </ul>"},{"location":"#floating-point-types","title":"Floating-Point Types","text":"<p>All three can be the same size. Typically, float is 32 bits, double is 64 bits, and long double is 80, 96, or 128 bits, and range in exponents for all three types is at least \u201337 to +37. You can look in the <code>cfloat</code> or <code>float.h</code> header files to find the limits for your system.</p> <p>The program floatnum.cpp display limiitations of floating-point numbers precision and previews an ostream method called <code>setf()</code> from Chapter 17. This call forces output to stay in fixed-point notation so that you can better see the precision.</p> floatnum.cpp <pre><code>// floatnum.cpp -- floating-point types\n#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n\n    cout.setf(ios_base::fixed, ios_base::floatfield); // fixed-point\n\n    float tub = 10.0 / 3.0;                           // good to about 6 places\n    double mint = 10.0 / 3.0;                         // good to about 15 places\n    const float million = 1.0e6;\n\n    cout &lt;&lt; \"tub = \" &lt;&lt; tub;\n    cout &lt;&lt; \", a million tubs = \" &lt;&lt; million * tub;\n    cout &lt;&lt; \",\\nand ten million tubs = \";\n    cout &lt;&lt; 10 * million * tub &lt;&lt; endl;\n    cout &lt;&lt; \"mint = \" &lt;&lt; mint &lt;&lt; \" and a million mints = \";\n    cout &lt;&lt; million * mint &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"#floating-point-constants","title":"Floating-Point Constants","text":"<p>Use suffixes for declaration <code>f</code> or <code>F</code> - float constant, eg.: <code>1.234f</code> <code>l</code> or <code>L</code> - long double</p> <pre><code>1.234f // a float constant\n2.45E20F // a float constant\n2.345324E28 // a double constant\n2.2L // a long double constant\n</code></pre>"},{"location":"#plus-and-cons-of-floating-point-values","title":"Plus and Cons of Floating-Point values","text":"<p><code>-</code> operations usually are slightly slower than integer operations <code>-</code> you can lose precision and values: example fltadd.cpp <code>+</code> represent values betwewen integers <code>+</code> can represent a much greater range of values, because of the scaling factor</p>"},{"location":"#c-arithmetic-operators","title":"C++ Arithmetic Operators","text":"<ul> <li>operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>%</code>, <code>/</code>, <code>*</code></li> <li>operands - two values used for calculation via operators</li> <li>expression - combined operator with operands</li> </ul> <p><code>%</code> - modulo works only with integers and produces remainder of dividing first value by second. <code>19 % 6</code> is <code>1</code>, because 6 goes into 19 three times, with remainder of 1. Practical example: modulus.cpp</p> <p><code>precedence rules</code> - When more than one operator can be applied to the same operand, C++ uses<code>precedence rules</code> to decide which operator is used first.</p> <p><code>int flyingpigs = 3 + 4 * 5; // 35 or 23?</code> The arithmetic operators follow the usual algebraic precedence, with multiplication, division, and the taking of the modulus done before addition and subtraction.</p> <p>Appendix D,\u201cOperator Precedence,\u201d - The <code>/</code> and <code>*</code> operators have the same precedence. <code>float logs = 120 / 4 * 5; // 150 or 6?</code></p> <p>When two operators have the same precedence, C++ looks at whether the operators have a <code>left-to-right associativity</code> or a <code>right-to-left associativity</code>.</p> <p>Appendix D shows that multiplication and division associate left-to-right.</p>"},{"location":"#conversion","title":"Conversion","text":"<ul> <li>truncation - discarding fractional part in <code>int</code>, when converting from floating-point to int value (eg.: <code>int g(1.123)</code>)</li> </ul> <p>C++11 - doesn't permit narrowing - variable may not be able to represent the assigned value:</p> <pre><code>const int code = 66;\nint x = 66;\nchar c1 {31325}; // narrowing, not allowed\nchar c2 = {66}; // allowed because char can hold 66\nchar c3 {code}; // ditto\nchar c4 = {x}; // not allowed, x is not constant\nx = 31325;\nchar c5 = x; // allowed by this form of initialization\n</code></pre> <ul> <li>integral promotion - automatic conversion evaluates expressions, C++ converts <code>bool</code>, <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, and <code>short</code> values to <code>int</code>, eg.:</li> </ul> <pre><code>short chickens = 20; // line 1\nshort ducks = 35; // line 2\nshort fowl = chickens + ducks; // line 3\n</code></pre> <p>For <code>fowl</code>, <code>chickens</code> and <code>ducks</code> got converted (promoted) to <code>int</code> for calculation and then result got converted back to <code>short</code>. This is because <code>int</code> is the computer most natural type</p> <p>Type cast conversion Is explicit form of conversion</p> <pre><code>(long) thorn // returns a type long conversion of thorn\nlong (thorn) // returns a type long conversion of thorn\n</code></pre> <p>The type cast doesn\u2019t alter the thorn variable itself; instead, it creates new value of the indicated type, which you can then use in an expression, as in the following:</p> <pre><code>cout &lt;&lt; int('Q'); // displays the integer code for 'Q'\n</code></pre>"},{"location":"#static-type-cast-conversion","title":"Static type cast conversion","text":"<p>In c++ of the four, the static_cast&lt;&gt; operator, can be used for converting values from one numeric type to another. For example, using it to convert thorn to a type long value looks like this:</p> <pre><code>static_cast&lt;long&gt; (thorn)\n</code></pre> typecast.cpp <pre><code>// typecast.cpp -- forcing type changes\n#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n    int auks, bats, coots;\n\n    // the following statement adds the values as double,\n    // then converts the result to int\n    auks = 19.99 + 11.99;\n\n    // these statements add values as int\n    bats = (int)19.99 + (int)11.99;  // old C syntax\n    coots = int(19.99) + int(11.99); // new C++ syntax\n    cout &lt;&lt; \"auks = \" &lt;&lt; auks &lt;&lt; \", bats = \" &lt;&lt; bats;\n    cout &lt;&lt; \", coots = \" &lt;&lt; coots &lt;&lt; endl;\n\n    char ch = 'Z';\n    cout &lt;&lt; \"The code for \" &lt;&lt; ch &lt;&lt; \" is \"; // print as char\n    cout &lt;&lt; int(ch) &lt;&lt; endl;                 // print as int\n    cout &lt;&lt; \"Yes, the code is \";\n    cout &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; endl; // using static_cast\n    return 0;\n}\n</code></pre> <p><code>auto</code> in C++11</p> <p>Just use <code>auto</code> instead of the type name in an initializing declaration, and the compiler assigns the variable the same type as that of the initializer:</p> <pre><code>auto n = 100; // n is int\nauto x = 1.5; // x is double\nauto y = 1.3e12L; // y is long double\n</code></pre> <p>Automatic type deduction becomes much more useful when dealing with complicated types, such as those in the STL (Standard Template Library). For example:</p> <p>C++98 code:</p> <pre><code>std::vector&lt;double&gt; scores;\nstd::vector&lt;double&gt;::iterator pv = scores.begin();\n</code></pre> <p>C++11 code:</p> <pre><code>std::vector&lt;double&gt; scores;\nauto pv = scores.begin();\n</code></pre>"},{"location":"#chapter-4-compound-types","title":"Chapter 4: Compound Types","text":"List of what you will learn  <pre><code>Creating and using arrays\nCreating and using C-style strings\nCreating and using string-class strings\nUsing the getline() and get() methods for reading strings\nMixing string and numeric input\nCreating and using structures\nCreating and using unions\nCreating and using enumerations\nCreating and using pointers\nManaging dynamic memory with new and delete\nCreating dynamic arrays\nCreating dynamic structures\nAutomatic, static, and dynamic storage\nThe vector and array classes (an introduction)\n</code></pre>"},{"location":"#arrays","title":"Arrays","text":"<p>Data form that can hold many values of one type. Declaration should indicate three things:</p> <ul> <li>The type of value to be stored in each element</li> <li>The name of the array</li> <li>The number of elements in the array</li> </ul> <p><code>typeName arrayName[arraySize];</code> - arraySize cannot be a variable whose value is set while the program is running. However, later in this chapter you\u2019ll learn how to use <code>the</code> new operator to get around that restriction</p> <pre><code>short months[12]; // creates array of 12 short\n</code></pre> <p>An array is called a <code>compound</code> type because it is built from some other type. (C uses the term <code>derived</code> type, but because C++ uses the term <code>derived</code> for class relationships, it had to come up with a new term.)</p> <p>You can access array elements individually.The way to do this is to use a <code>subscript</code>, or an <code>index</code>, to number the elements. C++ array numbering starts with zero. The <code>index</code> of the last element is one less than the size of the <code>array</code></p> <p></p> <p>Declaring an <code>array</code>, assigning values to <code>array</code> elements, and initializing an <code>array</code>:</p> arrayone.cpp <pre><code>// arrayone.cpp -- small arrays of integers\n#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n\n    int yams[3]; // creates array with three elements\n    yams[0] = 7; // assign value to first element\n    yams[1] = 8;\n    yams[2] = 6;\n\n    int yamcosts[3] = {20, 30, 5};  // Initialization list !!!\n    // create, initialize array\n    // NOTE: If your C++ compiler or translator can't initialize\n    // this array, use static int yamcosts[3] instead of\n    // int yamcosts[3]\n\n    cout &lt;&lt; \"Total yams = \";\n    cout &lt;&lt; yams[0] + yams[1] + yams[2] &lt;&lt; endl;\n    cout &lt;&lt; \"The package with \" &lt;&lt; yams[1] &lt;&lt; \" yams costs \";\n    cout &lt;&lt; yamcosts[1] &lt;&lt; \" cents per yam.\\n\";\n    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];\n    total = total + yams[2] * yamcosts[2];\n    cout &lt;&lt; \"The total yam expense is \" &lt;&lt; total &lt;&lt; \" cents.\\n\";\n\n    cout &lt;&lt; \"\\nSize of yams array = \" &lt;&lt; sizeof yams;\n    cout &lt;&lt; \" bytes.\\n\";\n    cout &lt;&lt; \"Size of one element = \" &lt;&lt; sizeof yams[0];\n    cout &lt;&lt; \" bytes.\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"#array-initialization","title":"Array Initialization","text":"<p>You can use the initialization form only when defining the array. You cannot use it later, and you cannot assign one array wholesale to another:</p> <pre><code>int cards[4] = {3, 6, 8, 10};   // okay\nint hand[4];                    // okay\nhand[4] = {5, 6, 7, 9};         // not allowed\nhand = cards;                   // not allowed\n\n// If you partially initialize an array, \n// the compiler sets the remaining elements to zero.\nfloat hotelTips[5] = {5.0, 2.5};\n\n// If you leave the square brackets ([]) empty \n// when you initialize an array, the C++ compiler\n// counts the elements for you.\nshort things[] = {1, 5, 3, 8};\n</code></pre> <p>Often, letting the compiler count the number of elements is poor practice because its count can be different from what you think it should be. You could, for instance, accidently omit an initial value from the list. However, this approach can be a safe one for initializing a character array to a string, as you\u2019ll soon see. And if your main concern is that the program, not you, knows how large an array is, you can do something like this:</p> <pre><code>short things[] = {1, 5, 3, 8};\nint num_elements = sizeof things / sizeof (short);\n</code></pre>"},{"location":"#c11-array-initialization","title":"C++11 Array Initialization","text":"<pre><code>// 1. You can drop the = sign when initializing an array:\ndouble earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4}; // okay with C++11\n\n// 2. You can use empty braces to set all the elements to 0:\nunsigned int counts[10] = {}; // all elements set to 0\nfloat balances[100] {}; // all elements set to 0\n\n// 3. List-initialization protects against narrowing (As in Chapter 3):\nlong plifs[] = {25, 92, 3.0}; // not allowed\nchar slifs[4] {'h', 'i', 1122011, '\\0'}; // not allowed\nchar tlifs[4] {'h', 'i', 112, '\\0'}; // allowed\n</code></pre> <p><code>vector</code> - STL alternative for arrays <code>array</code> template class - C++11 alternative for arrays</p>"},{"location":"#strings","title":"Strings","text":"<p>Series of characters stored in consecutive bytes of memory.</p>"},{"location":"#c-style-strings","title":"C-style strings","text":"<p>C-style strings have a special feature:The last character of every string is the null character, written <code>\\0</code>.</p> <pre><code>char dog[8] = { 'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I'}; // not a string!\nchar cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\\0'}; // a string!\nchar bird[11] = \"Mr. Cheeps\"; // the \\0 is understood\nchar fish[] = \"Bubbles\"; // let the compiler count\n</code></pre> <p></p> <pre><code>char shirt_size = 'S'; // this is fine\nchar shirt_size = \"S\"; // illegal type mismatch\n</code></pre> <p>But <code>\"S\"</code> is not a character constant; it represents the string consisting of two characters, the <code>S</code> and the <code>\\0</code> characters. Even worse, <code>\"S\"</code> actually represents the memory address at which the string is stored. So a statement like the following attempts to assign a memory address to shirt_size.</p>"},{"location":"#concatenating-string-literals","title":"Concatenating String Literals","text":"<p>C++ enables you to concatenate string literals\u2014that is, to combine two quoted  strings into one. <code>\\0</code> character from the first string is replaced by the first character of the second string. The following output statements are equivalent to each other:</p> <pre><code>cout &lt;&lt; \"I'd give my right arm to be\" \" a great violinist.\\n\";\ncout &lt;&lt; \"I'd give my right arm to be a great violinist.\\n\";\ncout &lt;&lt; \"I'd give my right ar\"\n\"m to be a great violinist.\\n\";\n</code></pre> <p></p> Strings in an Array: strings.cpp <pre><code>// strings.cpp -- storing strings in an array\n#include &lt;iostream&gt;\n#include &lt;cstring&gt; // for the strlen() function\nint main()\n{\n    using namespace std;\n    const int Size = 15;\n    char name1[Size];              // empty array\n    char name2[Size] = \"C++owboy\"; // initialized array\n    // NOTE: some implementations may require the static keyword\n    // to initialize the array name2\n\n    cout &lt;&lt; \"Howdy! I'm \" &lt;&lt; name2;\n    cout &lt;&lt; \"! What's your name?\\n\";\n    cin &gt;&gt; name1;\n    cout &lt;&lt; \"Well, \" &lt;&lt; name1 &lt;&lt; \", your name has \";\n    cout &lt;&lt; strlen(name1) &lt;&lt; \" letters and is stored\\n\";\n    cout &lt;&lt; \"in an array of \" &lt;&lt; sizeof(name1) &lt;&lt; \" bytes.\\n\";\n    cout &lt;&lt; \"Your initial is \" &lt;&lt; name1[0] &lt;&lt; \".\\n\";\n    name2[3] = '\\0'; // set to null character\n    cout &lt;&lt; \"Here are the first 3 characters of my name: \";\n    cout &lt;&lt; name2 &lt;&lt; endl;\n    return 0;\n}\n\n/*\nHere is a sample run of the program in Listing 4.2:\n    Howdy! I'm C++owboy! What's your name?\n    Basicman\n    Well, Basicman, your name has 8 letters and is stored\n    in an array of 15 bytes.\n    Your initial is B.\n    Here are the first 3 characters of my name: C++\n*/\n</code></pre> Problem 1: instr1.cpp, reading string input via cin <pre><code>// instr1.cpp -- reading more than one string\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    const int ArSize = 20;\n    char name[ArSize];\n    char dessert[ArSize];\n\n    cout &lt;&lt; \"Enter your name:\\n\";\n    cin &gt;&gt; name;\n    cout &lt;&lt; \"Enter your favorite dessert:\\n\";\n    cin &gt;&gt; dessert;\n    cout &lt;&lt; \"I have some delicious \" &lt;&lt; dessert;\n    cout &lt;&lt; \" for you, \" &lt;&lt; name &lt;&lt; \".\\n\";\n    return 0;\n}\n\n/*\nEnter your name:\n    Alistair Dreeb\n    Enter your favorite dessert:\n    I have some delicious Dreeb for you, Alistair.\n*/\n</code></pre> Solution 1: instr2.cpp, Line-Oriented Input with getline() <pre><code>// instr2.cpp -- reading more than one word with getline\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    const int ArSize = 20;\n    char name[ArSize];\n    char dessert[ArSize];\n\n    cout &lt;&lt; \"Enter your name:\\n\";\n    cin.getline(name, ArSize); // reads through newline\n    cout &lt;&lt; \"Enter your favorite dessert:\\n\";\n    cin.getline(dessert, ArSize);\n    cout &lt;&lt; \"I have some delicious \" &lt;&lt; dessert;\n    cout &lt;&lt; \" for you, \" &lt;&lt; name &lt;&lt; \".\\n\";\n    return 0;\n}\n\n/*\nHere is some sample output for Listing 4.4:\n    Enter your name:\n    Dirk Hammernose\n    Enter your favorite dessert:\n    Radish Torte\n    I have some delicious Radish Torte for you, Dirk Hammernose.\n*/\n</code></pre> Solution 2: instr3.cpp, Line-Oriented Input with get() <pre><code>// instr3.cpp -- reading more than one word with get() &amp; get()\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    const int ArSize = 20;\n    char name[ArSize];\n    char dessert[ArSize];\n\n    cout &lt;&lt; \"Enter your name:\\n\";\n    cin.get(name, ArSize).get(); // read string, newline\n    cout &lt;&lt; \"Enter your favorite dessert:\\n\";\n    cin.get(dessert, ArSize).get();\n    cout &lt;&lt; \"I have some delicious \" &lt;&lt; dessert;\n    cout &lt;&lt; \" for you, \" &lt;&lt; name &lt;&lt; \".\\n\";\n    return 0;\n}\n\n/*\nEnter your name:\n    Mai Parfait\n    Enter your favorite dessert:\n    Chocolate Mousse\n    I have some delicious Chocolate Mousse for you, Mai Parfait.\n*/\n</code></pre> numstr.cpp, Mixing String and Numeric Input <pre><code>// numstr.cpp -- following number input with line input\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"What year was your house built?\\n\";\n    int year;\n    cin &gt;&gt; year;\n    cout &lt;&lt; \"What is its street address?\\n\";\n    char address[80];\n    cin.getline(address, 80);\n    cout &lt;&lt; \"Year built: \" &lt;&lt; year &lt;&lt; endl;\n    cout &lt;&lt; \"Address: \" &lt;&lt; address &lt;&lt; endl;\n    cout &lt;&lt; \"Done!\\n\";\n    return 0;\n}\n\n/*\nRunning the program in Listing 4.6 would look something like this:\n    What year was your house built?\n    1966\n    What is its street address?\n    Year built: 1966\n    Address\n    Done!\n*/\n</code></pre> <p>In short:</p> <pre><code>cin.getline(dessert, ArSize);\n\ncin.getline(name1, ArSize).getline(name2, ArSize); // overloading \n\ncin.get(name, ArSize);\ncin.get(dessert, Arsize); // a problem ()\n\ncin.get(name, ArSize); // read first line\ncin.get(); // read newline\ncin.get(dessert, Arsize); // read second line\n\ncin.get(name, ArSize).get(); // concatenate member functions\n\n// get() (but not getline()) reads an empty\n// line, it sets something called the failbit. The implications of \n// this act are that further input is blocked, but you can restore \n// input with the following command:\ncin.clear();\n\n// You can also use\ncin.get(); // or cin.get(ch);\n(cin &gt;&gt; year).get(); // or (cin &gt;&gt; year).get(ch);\n</code></pre>"},{"location":"#string-class","title":"<code>string</code> Class","text":"<p>To use the string class, a program has to include the string header file.</p> <p>You should learn from this example that, in many ways, you can use a string object in the same manner as a character array:</p> <ul> <li>You can initialize a string object to a C-style string.</li> <li>You can use cin to store keyboard input in a string object.</li> <li>You can use cout to display a string object.</li> <li>You can use array notation to access individual characters stored in a string object.</li> </ul> strtype1.cpp, differences between string objects and character arrays. <pre><code>// strtype1.cpp -- using the C++ string class\n#include &lt;iostream&gt;\n#include &lt;string&gt; // make string class available\nint main()\n{\n    using namespace std;\n    char charr1[20];            // create an empty array\n    char charr2[20] = \"jaguar\"; // create an initialized array\n    string str1;                // create an empty string object\n    string str2 = \"panther\";    // create an initialized string\n\n    cout &lt;&lt; \"Enter a kind of feline: \";\n    cin &gt;&gt; charr1;\n    cout &lt;&lt; \"Enter another kind of feline: \";\n    cin &gt;&gt; str1; // use cin for input\n    cout &lt;&lt; \"Here are some felines:\\n\";\n    cout &lt;&lt; charr1 &lt;&lt; \" \" &lt;&lt; charr2 &lt;&lt; \" \"\n         &lt;&lt; str1 &lt;&lt; \" \" &lt;&lt; str2 // use cout for output\n         &lt;&lt; endl;\n    cout &lt;&lt; \"The third letter in \" &lt;&lt; charr2 &lt;&lt; \" is \"\n         &lt;&lt; charr2[2] &lt;&lt; endl;\n    cout &lt;&lt; \"The third letter in \" &lt;&lt; str2 &lt;&lt; \" is \"\n         &lt;&lt; str2[2] &lt;&lt; endl; // use array notation\n\n    return 0;\n}\n\n/*\nHere is a sample run of the program in Listing 4.7:\n    Enter a kind of feline: ocelot\n    Enter another kind of feline: tiger\n    Here are some felines:\n    ocelot jaguar tiger panther\n    The third letter in jaguar is g\n    The third letter in panther is n\n*/\n</code></pre> <p>C++11 string initialization</p> <pre><code>char first_date[] = {\"Le Chapon Dodu\"};\nchar second_date[] {\"The Elegant Plate\"};\nstring third_date = {\"The Bread Bowl\"};\nstring fourth_date {\"Hank's Fine Eats\"};\n</code></pre>"},{"location":"#assignment-concatenation-and-appending","title":"Assignment, Concatenation, and Appending","text":"<p>String class make some operations simpler. you can\u2019t simply assign one array to  nother. But you can assign one string object to another:</p> <pre><code>char charr1[20];            // create an empty array\nchar charr2[20] = \"jaguar\"; // create an initialized array\nstring str1;                // create an empty string object\nstring str2 = \"panther\";    // create an initialized string\ncharr1 = charr2;            // INVALID, no array assignment\nstr1 = str2;                // VALID, object assignment ok\n\nstring str3;\nstr3 = str1 + str2;         // assign str3 the joined strings\nstr1 += str2;               // add str2 to the end of str1\n</code></pre> strtype2.cpp, assigning, adding, and appending strings. <pre><code>// strtype2.cpp \u2013- assigning, adding, and appending\n#include &lt;iostream&gt;\n#include &lt;string&gt; // make string class available\nint main()\n{\n    using namespace std;\n    string s1 = \"penguin\";\n    string s2, s3;\n\n    cout &lt;&lt; \"You can assign one string object to another: s2 = s1\\n\";\n    s2 = s1;\n    cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; \", s2: \" &lt;&lt; s2 &lt;&lt; endl;\n    cout &lt;&lt; \"You can assign a C-style string to a string object.\\n\";\n    cout &lt;&lt; \"s2 = \\\"buzzard\\\"\\n\";\n    s2 = \"buzzard\";\n    cout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;\n    cout &lt;&lt; \"You can concatenate strings: s3 = s1 + s2\\n\";\n    s3 = s1 + s2;\n    cout &lt;&lt; \"s3: \" &lt;&lt; s3 &lt;&lt; endl;\n    cout &lt;&lt; \"You can append strings.\\n\";\n    s1 += s2;\n    cout &lt;&lt; \"s1 += s2 yields s1 = \" &lt;&lt; s1 &lt;&lt; endl;\n    s2 += \" for a day\";\n    cout &lt;&lt; \"s2 += \\\" for a day\\\" yields s2 = \" &lt;&lt; s2 &lt;&lt; endl;\n\n    return 0;\n}\n\n/*\n    You can assign one string object to another: s2 = s1\n    s1: penguin, s2: penguin\n    You can assign a C-style string to a string object.\n    s2 = \"buzzard\"\n    s2: buzzard\n    You can concatenate strings: s3 = s1 + s2\n    s3: penguinbuzzard\n    You can append strings.\n    s1 += s2 yields s1 = penguinbuzzard\n    s2 += \" for a day\" yields s2 = buzzard for a day\n*/\n</code></pre>"},{"location":"#more-string-class-operations","title":"More <code>string</code> Class operations","text":"<p>You can use the <code>strcpy()</code> function to copy a string to a character array, and you can use the <code>strcat()</code> function to append a string to a character array:</p> <pre><code>strcpy(charr1, charr2);     // copy charr2 to charr1\nstrcat(charr1, charr2);     // append contents of charr2 to char1\n</code></pre> strtype3.cpp, compares techniques used with string objects with techniques used with character arrays. <pre><code>// strtype3.cpp -- more string class features\n#include &lt;iostream&gt;\n#include &lt;string&gt;  // make string class available\n#include &lt;cstring&gt; // C-style string library\nint main()\n{\n    using namespace std;\n    char charr1[20];\n    char charr2[20] = \"jaguar\";\n    string str1;\n    string str2 = \"panther\";\n\n    // assignment for string objects and character arrays\n    str1 = str2;            // copy str2 to str1\n    strcpy(charr1, charr2); // copy charr2 to charr1\n\n    // appending for string objects and character arrays\n    str1 += \" paste\";         // add paste to end of str1\n    strcat(charr1, \" juice\"); // add juice to end of charr1\n\n    // finding the length of a string object and a C-style string\n    int len1 = str1.size();    // obtain length of str1\n    int len2 = strlen(charr1); // obtain length of charr1\n\n    cout &lt;&lt; \"The string \" &lt;&lt; str1 &lt;&lt; \" contains \"\n         &lt;&lt; len1 &lt;&lt; \" characters.\\n\";\n    cout &lt;&lt; \"The string \" &lt;&lt; charr1 &lt;&lt; \" contains \"\n         &lt;&lt; len2 &lt;&lt; \" characters.\\n\";\n\n    return 0;\n}\n\n/*\nHere is the output:\n    The string panther paste contains 13 characters.\n    The string jaguar juice contains 12 characters.\n*/\n</code></pre>"},{"location":"#more-string-class-io","title":"More <code>string</code> Class I/O","text":"strtype4.cpp, reading a line at a time instead of a word at time uses a different syntax (class and not class). <pre><code>// strtype4.cpp -- line input\n#include &lt;iostream&gt;\n#include &lt;string&gt;  // make string class available\n#include &lt;cstring&gt; // C-style string library\nint main()\n{\n    using namespace std;\n    char charr[20];\n    string str;\n    cout &lt;&lt; \"Length of string in charr before input: \"\n         &lt;&lt; strlen(charr) &lt;&lt; endl;\n    cout &lt;&lt; \"Length of string in str before input: \"\n         &lt;&lt; str.size() &lt;&lt; endl;\n    cout &lt;&lt; \"Enter a line of text:\\n\";\n    cin.getline(charr, 20); // indicate maximum length\n    cout &lt;&lt; \"You entered: \" &lt;&lt; charr &lt;&lt; endl;\n    cout &lt;&lt; \"Enter another line of text:\\n\";\n    getline(cin, str); // cin now an argument; no length specifier\n    cout &lt;&lt; \"You entered: \" &lt;&lt; str &lt;&lt; endl;\n    cout &lt;&lt; \"Length of string in charr after input: \"\n         &lt;&lt; strlen(charr) &lt;&lt; endl;\n    cout &lt;&lt; \"Length of string in str after input: \"\n         &lt;&lt; str.size() &lt;&lt; endl;\n    return 0;\n}\n\n/*\nHere\u2019s a sample run of the program in Listing 4.10:\n    Length of string in charr before input: 27\n    Length of string in str before input: 0\n    Enter a line of text:\n    peanut butter\n    You entered: peanut butter\n    Enter another line of text:\n    blueberry jam\n    You entered: blueberry jam\n    Length of string in charr after input: 13\n    Length of string in str after input: 13\n*/\n</code></pre>"},{"location":"#other-forms-of-string-literals","title":"Other Forms of <code>string</code> Literals","text":"<p>C++ adds: <code>wchar_t</code> in addition to <code>char</code> C++11 adds: <code>char16_t</code>, <code>char32_t</code> + raw string (<code>R</code> prefix) + support UTF-8 (<code>u8</code> prefix)</p> <p>Use literals with L, u, and U prefixes:</p> <pre><code>wchar_t title[] = L\"Chief Astrogator\";      // w_char string\nchar16_t name[] = u\"Felonia Ripova\";        // char_16 string\nchar32_t car[] = U\"Humber Super Snipe\";     // char_32 string\n</code></pre> <p>Raw string</p> <p><code>cout &lt;&lt; R\"(Jim \"King\" Tutt uses \"\\n\" instead of endl.)\" &lt;&lt; '\\n';</code>    This would display the following: <code>Jim \"King\" Tutt uses \\n instead of endl.</code></p> <p>The standard string literal equivalent would be this: <code>cout &lt;&lt; \"Jim \\\"King\\\" Tutt uses \\\" \\\\n\\\" instead of endl.\" &lt;&lt; '\\n';</code></p> <p>Raw string syntax allows you to place additional characters between the opening - the statement: <code>cout &lt;&lt; R\"+*(\"(Who wouldn't?)\", she whispered.)+*\" &lt;&lt; endl;</code> would display the following: <code>\"(Who wouldn't?)\", she whispered.</code></p>"},{"location":"#structures","title":"Structures","text":"<p><code>array</code> can store only one type of data <code>structure</code>  can store different types of data at the same time</p> <pre><code>#include &lt;string&gt;\nstruct inflatable_string // structure definition\n{\n    std::string name;\n    float volume;\n    double price;\n};\n\nstruct inflatable // structure declaration with 'inflatible' identifier/tag\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\ninflatable hat;             // hat is a structure variable of type inflatable\ninflatable woopie_cushion;  // type inflatable variable\ninflatable mainframe;       // type inflatable variable\n\nstruct inflatable goose;    // keyword struct required in C\ninflatable vincent;         // keyword struct not required in C++\n</code></pre> <p>Given that <code>hat</code> is type inflatable, you use the membership operator (.) to access individual members. For example, <code>hat.volume</code> refers to the <code>volume</code> member of the structure, and <code>hat.price</code> refers to the <code>price</code> member.</p> <p></p> structur.cpp, example use of structure. <pre><code>// structur.cpp -- a simple structure\n#include &lt;iostream&gt;\nstruct inflatable // structure declaration\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    using namespace std;\n    inflatable guest =\n        {\n            \"Glorious Gloria\", // name value\n            1.88,              // volume value\n            29.99              // price value\n        };                     // guest is a structure variable of type inflatable\n\n    // It's initialized to the indicated values\n    inflatable pal =\n        {\n            \"Audacious Arthur\",\n            3.12,\n            32.99\n        }; // pal is a second variable of type inflatable\n\n    // NOTE: some implementations require using\n    // static inflatable guest =\n    cout &lt;&lt; \"Expand your guest list with \" &lt;&lt; guest.name;\n    cout &lt;&lt; \" and \" &lt;&lt; pal.name &lt;&lt; \"!\\n\";\n    // pal.name is the name member of the pal variable\n    cout &lt;&lt; \"You can have both for $\";\n    cout &lt;&lt; guest.price + pal.price &lt;&lt; \"!\\n\";\n    return 0;\n}\n/*\nOne important matter related to the program in Listing 4.11 is where to place the structure\ndeclaration.There are two choices for structur.cpp.You could place the declaration\ninside the main() function, just after the opening brace.The second choice, and the one\nmade here, is to place it outside and preceding main().When a declaration occurs outside\nany function, it\u2019s called an external declaration. For this program, there is no practical difference\nbetween the two choices. But for programs consisting of two or more functions, the\ndifference can be crucial.The external declaration can be used by all the functions following\nit, whereas the internal declaration can be used only by the function in which the\ndeclaration is found.\n*/\n</code></pre> <p><code>structures</code> can be declared outside any function, which is called <code>external declaration</code></p>"},{"location":"#c11-initialization","title":"C++11 Initialization","text":"<pre><code>inflatable duck {\"Daphne\", 0.12, 9.98}; // can omit the = in C++11\ninflatable mayor {}; // individual members being set to 0\n</code></pre> <p>Narrowing is not allowed.</p>"},{"location":"#other-structure-properties","title":"Other <code>structure</code> properties","text":"<p><code>memberwise assignment</code> - you can use the assignment operator (=) to assign one structure to another of the same type.</p> assgn_st.cpp, example use of memberwise assignment. <pre><code>// assgn_st.cpp -- assigning structures\n#include &lt;iostream&gt;\n\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    using namespace std;\n    inflatable bouquet =\n        {\n            \"sunflowers\",\n            0.20,\n            12.49\n        };\n\n    inflatable choice;\n    cout &lt;&lt; \"bouquet: \" &lt;&lt; bouquet.name &lt;&lt; \" for $\";\n    cout &lt;&lt; bouquet.price &lt;&lt; endl;\n\n    choice = bouquet; // assign one structure to another\n    cout &lt;&lt; \"choice: \" &lt;&lt; choice.name &lt;&lt; \" for $\";\n    cout &lt;&lt; choice.price &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"#arrays-of-structures","title":"Arrays of Structures","text":"<pre><code>inflatable gifts[100]; // array of 100 inflatable structures\n...\ncin &gt;&gt; gifts[0].volume; // use volume member of first struct\ncout &lt;&lt; gifts[99].price &lt;&lt; endl; // display price member of last struct\n\ninflatable guests[2] = // initializing an array of structs\n{\n    {\"Bambi\", 0.5, 21.99}, // first structure in array\n    {\"Godzilla\", 2000, 565.99} // next structure in array\n};\n</code></pre> arrstruct.cpp, array of structures. <pre><code>// arrstruc.cpp -- an array of structures\n#include &lt;iostream&gt;\n\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    using namespace std;\n    inflatable guests[2] = // initializing an array of structs\n        {\n            {\"Bambi\", 0.5, 21.99},     // first structure in array\n            {\"Godzilla\", 2000, 565.99} // next structure in array\n        };\n\n    cout &lt;&lt; \"The guests \" &lt;&lt; guests[0].name &lt;&lt; \" and \" &lt;&lt; guests[1].name\n         &lt;&lt; \"\\nhave a combined volume of \"\n         &lt;&lt; guests[0].volume + guests[1].volume &lt;&lt; \" cubic feet.\\n\";\n    return 0;\n}\n\n/*\nHere is the output of the program in Listing 4.13:\n    The guests Bambi and Godzilla\n    have a combined volume of 2000.5 cubic feet.\n*/\n</code></pre>"},{"location":"#bit-fields-in-structures","title":"Bit Fields in Structures","text":"<p>C++, like C, enables you to specify structure members that occupy a particular number of bits</p> <pre><code>struct torgle_register\n{\n    u`nsigned int SN : 4; // 4 bits for SN value\n    unsigned int : 4; // 4 bits unused\n    bool goodIn : 1; // valid input (1 bit)\n    b`ool goodTorgle : 1; // successful torgling\n};\n\ntorgle_register tr = { 14, true, false };\n...\nif (tr.goodIn)\n</code></pre>"},{"location":"#unions","title":"Unions","text":"<p>A union is a data format that can hold different data types but only one type at a time</p> <pre><code>union one4all\n{\n    int int_val;\n    long long_val;\n    double double_val;\n};\n\none4all pail;\npail.int_val = 15; // store an int\ncout &lt;&lt; pail.int_val;\npail.double_val = 1.38; // store a double, int value is lost\ncout &lt;&lt; pail.double_val;\n</code></pre> <p><code>anonymous union</code> - has no name; in essence, its members become variables that share the same address.</p> <pre><code>struct widget\n{\n    char brand[20];\n    int type;\n    union // anonymous union\n    {\n        long id_num; // type 1 widgets\n        char id_char[20]; // other widgets\n    };\n};\n...\nwidget prize;\n...\nif (prize.type == 1)\ncin &gt;&gt; prize.id_num;\nelse\ncin &gt;&gt; prize.id_char;\n</code></pre>"},{"location":"#enumerations","title":"Enumerations","text":"<p><code>enum</code> facility provides an alternative to <code>const</code> for creating symbolic constants</p> <pre><code>enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};\n</code></pre> <ul> <li>It makes spectrum the name of a new type; spectrum is termed an enumeration, much as a struct variable is called a structure.</li> <li>It establishes red, orange, yellow, and so on, as symbolic constants for the integer values 0\u20137.These constants are called enumerators.</li> </ul> <pre><code>spectrum band; // band a variable of type spectrum\n\nband = blue; // valid, blue is an enumerator\nband = 2000; // invalid, 2000 not an enumerator\n\nband = orange; // valid\n++band; // not valid, ++ discussed in Chapter 5\nband = orange + red; // not valid, but a little tricky\n\nint color = blue; // valid, spectrum type promoted to int\nband = 3; // invalid, int not converted to spectrum\ncolor = 3 + red; // valid, red converted to int\n\nband = spectrum(3); // typecast 3 to type spectrum\nband = spectrum(40003); // undefined\n</code></pre>"},{"location":"#setting-enumerator-values","title":"Setting Enumerator Values","text":"<pre><code>enum bits{one = 1, two = 2, four = 4, eight = 8};\nenum bigstep{first, second = 100, third};\nenum {zero, null = 0, one, numero_uno = 1};\n</code></pre>"},{"location":"#range-of-enumerations","title":"Range of enumerations","text":"<pre><code>enum bits{one = 1, two = 2, four = 4, eight = 8};\nbits myflag;\n// In this case, the following is valid:\nmyflag = bits(6); // valid, because 6 is in bits range\n</code></pre> <p>Here <code>6</code> is not one of the enumerations, but it lies in the range the enumerations define. The range is defined as follows. First, to find the upper limit, you take the largest enumerator value.Then you find the smallest power of two greater than this largest value and subtract one; the result is the upper end of the range (For example, the largest <code>bigstep</code> value, as previously defined, is 101. The smallest power of two greater than this is 128, so the upper end of the range is 127.)</p>"},{"location":"#pointers-and-the-free-store","title":"Pointers and the Free Store","text":"<p>address operator, represented by <code>&amp;</code> to a variable to get its location; if <code>home</code> is a variable, <code>&amp;home</code> is its address</p> address.cpp <pre><code>// address.cpp -- using the &amp; operator to find addresses\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int donuts = 6;\n    double cups = 4.5;\n\n    cout &lt;&lt; \"donuts value = \" &lt;&lt; donuts;\n    cout &lt;&lt; \" and donuts address = \" &lt;&lt; &amp;donuts &lt;&lt; endl;\n    // NOTE: you may need to use unsigned (&amp;donuts)\n    // and unsigned (&amp;cups)\n    cout &lt;&lt; \"cups value = \" &lt;&lt; cups;\n    cout &lt;&lt; \" and cups address = \" &lt;&lt; &amp;cups &lt;&lt; endl;\n    return 0;\n}\n\n/*\nHere is the output from the program in Listing 4.14 on one system:\n    donuts value = 6 and donuts address = 0x0065fd40\n    cups value = 4.5 and cups address = 0x0065fd44\n\n*/\n</code></pre> Pointers and the C++ Philosophy <p>Object-oriented programming differs from traditional procedural programming in that OOP emphasizes making decisions during runtime instead of during compile time. Runtime means while a program is running, and compile time means when the compiler is putting a program together. A runtime decision is like, when on vacation, choosing what sights to see depending on the weather and your mood at the moment, whereas a compile-time decision is more like adhering to a preset schedule, regardless of the conditions. Runtime decisions provide the flexibility to adjust to current circumstances. For example, consider allocating memory for an array. The traditional way is to declare an array. To declare an array in C++, you have to commit yourself to a particular array size. Thus, the array size is set when the program is compiled; it is a compile-time decision. Perhaps you think an array of 20 elements is sufficient 80% of the time but that occasionally the program will need to handle 200 elements. To be safe, you use an array with 200 elements. This results in your program wasting memory most of the time it\u2019s used. OOP tries to make a program more flexible by delaying such decisions until runtime. That way, after the program is running, you can tell it you need only 20 elements one time or that you need 205 elements another time. In short, with OOP you would like to make the array size a runtime decision. To make this approach possible, the language has to allow you to create an array\u2014or the equivalent\u2014 while the program runs. The C++ method, as you soon see, involves using the keyword new to request the correct amount of memory and using pointers to keep track of where the newly allocated memory is found. Making runtime decisions is not unique to OOP. But C++ makes writing the code a bit more straightforward than does C.</p> <p>A special type of variable the <code>pointer</code> \u2014 holds the address of a value. Thus, the name of the pointer represents the location</p> <p>Applying the <code>*</code> operator, called the indirect value or the dereferencing operator, yields the value at the location.</p> pointer.cpp <pre><code>// pointer.cpp -- our first pointer variable\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int updates = 6;      // declare a variable\n    int *p_updates;       // declare pointer to an int\n    p_updates = &amp;updates; // assign address of int to pointer\n\n    // express values two ways\n    cout &lt;&lt; \"Values: updates = \" &lt;&lt; updates;\n    cout &lt;&lt; \", *p_updates = \" &lt;&lt; *p_updates &lt;&lt; endl;\n\n    // express address two ways\n    cout &lt;&lt; \"Addresses: &amp;updates = \" &lt;&lt; &amp;updates;\n    cout &lt;&lt; \", p_updates = \" &lt;&lt; p_updates &lt;&lt; endl;\n\n    // use pointer to change value\n    *p_updates = *p_updates + 1;\n    cout &lt;&lt; \"Now updates = \" &lt;&lt; updates &lt;&lt; endl;\n    return 0;\n}\n\n/*\nHere is the output from the program in Listing 4.15:\n    Values: updates = 6, *p_updates = 6\n    Addresses: &amp;updates = 0x0065fd48, p_updates = 0x0065fd48\n    Now updates = 7\n*/\n</code></pre> <p></p> <p></p> <p>In C++, the combination <code>int *</code> is a compound type, pointer-to-int.</p> <pre><code>int * p_updates;\n\n// the following declaration creates one pointer (p1) and one ordinary int (p2):\nint* p1, p2;\n\ndouble * tax_ptr; // tax_ptr points to type double\nchar * str; // str points to type char\n</code></pre> init_ptr.cpp, initialize a pointer to an address. <pre><code>// init_ptr.cpp -- initialize a pointer\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int higgens = 5;\n    int *pt = &amp;higgens;\n\n    cout &lt;&lt; \"Value of higgens = \" &lt;&lt; higgens\n         &lt;&lt; \"; Address of higgens = \" &lt;&lt; &amp;higgens &lt;&lt; endl;\n    cout &lt;&lt; \"Value of *pt = \" &lt;&lt; *pt\n         &lt;&lt; \"; Value of pt = \" &lt;&lt; pt &lt;&lt; endl;\n    return 0;\n}\n\n/*\nHere is some sample output from the program in Listing 4.16:\n    Value of higgens = 5; Address of higgens = 0012FED4\n    Value of *pt = 5; Value of pt = 0012FED4\n*/\n</code></pre>"},{"location":"#pointer-danger","title":"Pointer Danger","text":"<pre><code>long * fellow; // create a pointer-to-long\n*fellow = 223323; // place a value in never-never land\n\n// Pointer Golden Rule: Always initialize a pointer to a definite and\n// appropriate address before you apply the dereferencing operator (*) to it.\n\nint * pt;\npt = 0xB8000000; // type mismatch\n\nint * pt;\npt = (int *) 0xB8000000; // types now match\n</code></pre>"},{"location":"#allocating-memory-with-new","title":"Allocating Memory with <code>new</code>","text":"<p>In C, you can allocate memory with the library function <code>malloc()</code></p> <pre><code>// typeName * pointer_name = new typeName;\nint * pn = new int;\n\n// for comparison\nint higgens;\nint * pt = &amp;higgens;\n</code></pre> <p>We say that <code>pn</code> points to a <code>data object</code></p> use_new.cpp, use new. <pre><code>// use_new.cpp -- using the new operator\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int nights = 1001;\n    int *pt = new int; // allocate space for an int\n    *pt = 1001;        // store a value there\n\n    cout &lt;&lt; \"nights value = \";\n    cout &lt;&lt; nights &lt;&lt; \": location \" &lt;&lt; &amp;nights &lt;&lt; endl;\n    cout &lt;&lt; \"int \";\n    cout &lt;&lt; \"value = \" &lt;&lt; *pt &lt;&lt; \": location = \" &lt;&lt; pt &lt;&lt; endl;\n    double *pd = new double; // allocate space for a double\n    *pd = 10000001.0;        // store a double there\n\n    cout &lt;&lt; \"double \";\n    cout &lt;&lt; \"value = \" &lt;&lt; *pd &lt;&lt; \": location = \" &lt;&lt; pd &lt;&lt; endl;\n    cout &lt;&lt; \"location of pointer pd: \" &lt;&lt; &amp;pd &lt;&lt; endl;\n    cout &lt;&lt; \"size of pt = \" &lt;&lt; sizeof(pt);\n    cout &lt;&lt; \": size of *pt = \" &lt;&lt; sizeof(*pt) &lt;&lt; endl;\n    cout &lt;&lt; \"size of pd = \" &lt;&lt; sizeof pd;\n    cout &lt;&lt; \": size of *pd = \" &lt;&lt; sizeof(*pd) &lt;&lt; endl;\n    return 0;\n}\n\n/*\nHere is the output from the program in Listing 4.17:\n    nights value = 1001: location 0028F7F8\n    int value = 1001: location = 00033A98\n    double value = 1e+007: location = 000339B8\n    location of pointer pd: 0028F7FC\n    size of pt = 4: size of *pt = 4\n    size of pd = 4: size of *pd = 8\n*/\n</code></pre> Out of Memory? <p>It\u2019s possible that a computer might not have sufficient memory available to satisfy a new request. When that is the case, new normally responds by throwing an exception, an errorhandling technique discussed in Chapter 15, \u201cFriends, Exceptions, and More.\u201d In older implementations new returns the value 0. In C++, a pointer with the value 0 is called the null pointer. C++ guarantees that the null pointer never points to valid data, so it is often used to indicate failure for operators or functions that otherwise return usable pointers. The if statement, discussed in Chapter 6, helps you deal with this possibility. For now, the important point is that C++ provides the tools to detect and respond to allocation failures.</p>"},{"location":"#freeing-memory-with-delete","title":"Freeing Memory with <code>delete</code>","text":"<p>This removes the memory to which ps points; it doesn\u2019t remove the pointer ps itself. Memory that you return, or <code>free</code>, can then be reused by other parts of the program</p> <pre><code>int * ps = new int; // allocate memory with new\n. . . // use the memory\ndelete ps; // free memory with delete when done\n\nint * ps = new int; // ok\ndelete ps; // ok\ndelete ps; // not ok now\nint jugs = 5; // ok\nint * pi = &amp;jugs; // ok\ndelete pi; // not allowed, memory not allocated by new\n\n// Ordinarily, you won\u2019t create two pointers to the same block of memory because that\n// raises the possibility that you will mistakenly try to delete the same block twice.\nint * ps = new int; // allocate memory\nint * pq = ps; // set second pointer to same block\ndelete pq; // delete with second pointer\n</code></pre>"},{"location":"#using-new-to-create-dynamic-arrays","title":"Using <code>new</code> to Create Dynamic Arrays","text":"<pre><code>//type_name * pointer_name = new type_name [num_elements];\nint * psome = new int [10]; // get a block of 10 ints\ndelete [] psome; // free a dynamic array\n\nint * pt = new int;\nshort * ps = new short [500];\ndelete [] pt; // effect is undefined, don't do it\ndelete ps; // effect is undefined, don't do it\n</code></pre> <ul> <li>Don\u2019t use delete to free memory that new didn\u2019t allocate.</li> <li>Don\u2019t use delete to free the same block of memory twice in succession.</li> <li>Use delete [] if you used new [] to allocate an array.</li> <li>Use delete (no brackets) if you used new to allocate a single entity.</li> <li>It\u2019s safe to apply delete to the null pointer (nothing happens).</li> </ul> arraynew.cpp, use dynamic array <pre><code>// arraynew.cpp -- using the new operator for arrays\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    double *p3 = new double[3]; // space for 3 doubles\n    p3[0] = 0.2;                // treat p3 like an array name\n    p3[1] = 0.5;\n    p3[2] = 0.8;\n    cout &lt;&lt; \"p3[1] is \" &lt;&lt; p3[1] &lt;&lt; \".\\n\";\n    p3 = p3 + 1; // increment the pointer\n    cout &lt;&lt; \"Now p3[0] is \" &lt;&lt; p3[0] &lt;&lt; \" and \";\n    cout &lt;&lt; \"p3[1] is \" &lt;&lt; p3[1] &lt;&lt; \".\\n\";\n    p3 = p3 - 1; // point back to beginning\n    delete[] p3; // free the memory\n    return 0;\n}\n\n/*\nHere is the output from the program in Listing 4.18:\n    p3[1] is 0.5.\n    Now p3[0] is 0.5 and p3[1] is 0.8.\n\n\nAs you can see, arraynew.cpp uses the pointer p3 as if it were the name of an array,\nwith p3[0] as the first element, and so on.The fundamental difference between an array\nname and a pointer appears in the following line:\n    p3 = p3 + 1; // okay for pointers, wrong for array names\n*/\n</code></pre>"},{"location":"#pointers-arrays-and-pointer-arithmetic","title":"Pointers, Arrays, and Pointer Arithmetic","text":"addpntrs.cpp, pointer addition <pre><code>// addpntrs.cpp -- pointer addition\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    double wages[3] = {10000.0, 20000.0, 30000.0};\n    short stacks[3] = {3, 2, 1};\n\n    // Here are two ways to get the address of an array\n    double *pw = wages;     // name of an array = address\n    short *ps = &amp;stacks[0]; // or use address operator\n\n    // with array element\n    cout &lt;&lt; \"pw = \" &lt;&lt; pw &lt;&lt; \", *pw = \" &lt;&lt; *pw &lt;&lt; endl;\n    pw = pw + 1;\n    cout &lt;&lt; \"add 1 to the pw pointer:\\n\";\n    cout &lt;&lt; \"pw = \" &lt;&lt; pw &lt;&lt; \", *pw = \" &lt;&lt; *pw &lt;&lt; \"\\n\\n\";\n\n    cout &lt;&lt; \"ps = \" &lt;&lt; ps &lt;&lt; \", *ps = \" &lt;&lt; *ps &lt;&lt; endl;\n    ps = ps + 1;\n    cout &lt;&lt; \"add 1 to the ps pointer:\\n\";\n    cout &lt;&lt; \"ps = \" &lt;&lt; ps &lt;&lt; \", *ps = \" &lt;&lt; *ps &lt;&lt; \"\\n\\n\";\n\n    cout &lt;&lt; \"access two elements with array notation\\n\";\n    cout &lt;&lt; \"stacks[0] = \" &lt;&lt; stacks[0]\n         &lt;&lt; \", stacks[1] = \" &lt;&lt; stacks[1] &lt;&lt; endl;\n    cout &lt;&lt; \"access two elements with pointer notation\\n\";\n    cout &lt;&lt; \"*stacks = \" &lt;&lt; *stacks\n         &lt;&lt; \", *(stacks + 1) = \" &lt;&lt; *(stacks + 1) &lt;&lt; endl;\n\n    cout &lt;&lt; sizeof(wages) &lt;&lt; \" = size of wages array\\n\";\n    cout &lt;&lt; sizeof(pw) &lt;&lt; \" = size of pw pointer\\n\";\n    return 0;\n}\n\n/*\nHere is the output from the program in Listing 4.19:\n    pw = 0x28ccf0, *pw = 10000\n    add 1 to the pw pointer:\n    pw = 0x28ccf8, *pw = 20000\n\n    ps = 0x28ccea, *ps = 3\n    add 1 to the ps pointer:\n    ps = 0x28ccec, *ps = 2\n\n    access two elements with array notation\n    stacks[0] = 3, stacks[1] = 2\n    access two elements with pointer notation\n    *stacks = 3, *(stacks + 1) = 2\n    24 = size of wages array\n    4 = size of pw pointer\n\nIn most contexts, C++ interprets the name of an array as the address of its first element.\nThus, the following statement makes pw a pointer to type double and then initializes pw\nto wages, which is the address of the first element of the wages array:\n    double * pw = wages;\nFor wages, as with any array, we have the following equality:\n    wages = &amp;wages[0] = address of first element of array\nJust to show that this is no jive, the program explicitly uses the address operator in the\nexpression &amp;stacks[0] to initialize the ps pointer to the first element of the stacks array.\n*/\n</code></pre>       The Address of an Array       Taking the address of an array is another case in which the name of an array is not interpreted as its address. But wait, isn\u2019t the name of an array interpreted as the address of the array? Not quite\u2014the name of the array is interpreted as the address of the first element of an array, whereas applying the address operator yields the address of the whole array:  `short tell[10]; // tell an array of 20 bytes` `cout &lt;&lt; tell &lt;&lt; endl; // displays &amp;tell[0]` `cout &lt;&lt; &amp;tell &lt;&lt; endl; // displays address of whole array`  Numerically, these two addresses are the same, but conceptually `&amp;tell[0]`, and hence tell, is the address of a 2-byte block of memory, whereas `&amp;tell` is the address of a 20- byte block of memory. So the expression tell + 1 adds 2 to the address value, whereas `&amp;tell + 1` adds 20 to the address value. Another way of expressing this is to say that tell is type pointer-to-short, or `short *`, and `&amp;tell` is type pointer-to-array-of-20-shorts, or short [*](20). Now you might be wondering about the genesis of that last type description. First, here is how you could declare and initialize a pointer of that type:  `short (*pas)[20] = &amp;tell; // pas points to array of 20 shorts`  If you omit the parentheses, precedence rules would first associate [20] with pas, making pas an array of 20 pointers-to-short, so the parentheses are necessary. Next, if you wish to describe the type of a variable, you can use the declaration of that variable as a guide and remove the variable name. Thus, the type of pas is `short (*)[20]`. Also note that because pas is set to `&amp;tell`, *pas is equivalent to tell, so `(*pas)[0]` would be the first element of the `tell` array."},{"location":"#pointer-summary","title":"<code>pointer</code> Summary","text":""},{"location":"#declaring-pointers","title":"Declaring Pointers","text":"<p>To declare a pointer to a particular type, use this form:</p> <pre><code>typeName * pointerName;\n</code></pre> <p>Here are some examples:</p> <pre><code>double * pn; // pn can point to a double value\nchar * pc; // pc can point to a char value\n</code></pre> <p>Here pn and pc are pointers, and double and char are the C++ notations for the types pointer-to-double and pointer-to-char.</p>"},{"location":"#assigning-values-to-pointers","title":"Assigning Values to Pointers","text":"<p>You should assign a memory address to a pointer.You can apply the &amp; operator to a variable name to get an address of named memory, and the new operator returns the address of unnamed memory.</p> <p>Here are some examples:</p> <pre><code>double * pn; // pn can point to a double value\ndouble * pa; // so can pa\nchar * pc; // pc can point to a char value\ndouble bubble = 3.2;\npn = &amp;bubble; // assign address of bubble to pn\npc = new char; // assign address of newly allocated char memory to pc\npa = new double[30]; // assign address of 1st element of array of 30 double to pa\n</code></pre>"},{"location":"#dereferencing-pointers","title":"Dereferencing Pointers","text":"<p>Dereferencing a <code>pointer</code> means referring to the pointed-to value. You apply the dereferencing, or indirect value, operator (<code>*</code>) to a <code>pointer</code> to <code>dereference</code> it. Thus, if <code>pn</code> is a <code>pointer</code> to <code>bubble</code>, as in the preceding example, then <code>*pn</code> is the pointed-to value, or 3.2, in this case.</p> <p>Here are some examples:</p> <pre><code>cout &lt;&lt; *pn; // print the value of bubble\n*pc = 'S'; // place 'S' into the memory location whose address is pc\n</code></pre> <p>Array notation is a second way to dereference a pointer; for instance, <code>pn[0]</code> is the same as <code>*pn</code>. You should never dereference a pointer that has not been initialized to a proper address.</p>"},{"location":"#distinguishing-between-a-pointer-and-the-pointed-to-value","title":"Distinguishing Between a Pointer and the Pointed-to Value","text":"<p>Remember, if pt is a pointer-to-int, <code>*pt</code> is not a pointer-to-int; instead, <code>*pt</code> is the complete equivalent to a type int variable. It is <code>pt</code> that is the <code>pointer</code>.</p> <p>Here are some examples:</p> <pre><code>int * pt = new int; // assigns an address to the pointer pt\n*pt = 5; // stores the value 5 at that address\n</code></pre>"},{"location":"#array-names","title":"Array Names","text":"<p>In most contexts, C++ treats the name of an array as equivalent to the address of the first element of an array.</p> <pre><code>Here is an example:\nint tacos[10]; // now tacos is the same as &amp;tacos[0]\n</code></pre> <p>One exception is when you use the name of an array with the sizeof operator. In that case, sizeof returns the size of the entire array, in bytes.</p>"},{"location":"#pointer-arithmetic","title":"Pointer Arithmetic","text":"<p>C++ allows you to add an integer to a pointer.The result of adding one equals the original address value plus a value equal to the number of bytes in the pointed-to object. You can also subtract an integer from a pointer to take the difference between two pointers. The last operation, which yields an integer, is meaningful only if the two pointers point into the same array (pointing to one position past the end is allowed, too); it then yields the separation between the two elements.</p> <p>Here are some examples:</p> <pre><code>int tacos[10] = {5,2,8,4,1,2,2,4,6,8};\nint * pt = tacos; // suppose pf and tacos are the address 3000\npt = pt + 1; // now pt is 3004 if a int is 4 bytes\nint *pe = &amp;tacos[9]; // pe is 3036 if an int is 4 bytes\npe = pe - 1; // now pe is 3032, the address of tacos[8]\nint diff = pe - pt; // diff is 7, the separation between\n// tacos[8] and tacos[1]\n</code></pre>"},{"location":"#dynamic-binding-and-static-binding-for-arrays","title":"Dynamic Binding and Static Binding for Arrays","text":"<p>You can use an array declaration to create an array with static binding\u2014that is, an array  whose size is set during the compilation process:</p> <pre><code>int tacos[10]; // static binding, size fixed at compile time\n</code></pre> <p>You use the new [] operator to create an array with dynamic binding (a dynamic array) that is, an array that is allocated and whose size can be set during runtime. You free the memory with delete [] when you are done:</p> <pre><code>int size;\ncin &gt;&gt; size;\nint * pz = new int [size]; // dynamic binding, size set at run time\n...\ndelete [] pz; // free memory when finished\n</code></pre>"},{"location":"#structure-pointers","title":"Structure pointers","text":"<p>If the data object is a <code>structure</code> initialized with <code>new</code>, you can use the pointer dereferencing operator (<code>-&gt;</code>) to access structure members</p> <pre><code>BOP *stBOP = new BOP[5];\n\nstrcpy(stBOP[0].fullname, \"Wimp Macho\");\nstrcpy(stBOP[1].fullname, \"Wimp Macho\");\n\nbop *stBOP = new bop;\nstrcpy(stBOP-&gt;fullname, \"Wimp Macho\");\n</code></pre> <p>The <code>.</code> operator works instead of the <code>-&gt;</code> operator because you are accessing the members of the <code>bop struct</code> using an <code>array</code> of <code>structs</code> (<code>stBOP</code>), not a <code>pointer</code> to a <code>struct</code>.</p> <p>When you use the array notation <code>stBOP[0]</code>, it refers to the first element of the array, which is an object of the <code>bop</code> <code>struct</code>. Therefore, you can use the <code>.</code> operator to access its members directly.</p> <p>Use the <code>.</code> operator to access members of a <code>struct</code> or <code>class</code> directly, and use the <code>-&gt;</code> operator to access members through a pointer to a <code>struct</code> or <code>class</code>.</p>"},{"location":"#pointers-and-strings","title":"Pointers and Strings","text":"<p>With cout and with most C++ expressions, the name of an array of char, a pointer-tochar, and a quoted string constant are all interpreted as the address of the first character of a string.</p> <p>The <code>strcpy(var_dest, var_copyFrom)</code> function copies a string from one location to another. The <code>strncpy(var_dest, var_copyFrom, int_sizeof_var_copyFrom)</code> function copies a string from one location to another with the new size of it. The <code>strlen()</code> function returns the length of a string, not counting the null character When using these functions, you include the <code>cstring</code> or the <code>string.h</code> header file.</p> ptrstr.cpp <pre><code>// ptrstr.cpp -- using pointers to strings\n#include &lt;iostream&gt;\n#include &lt;cstring&gt; // declare strlen(), strcpy()\nint main()\n{\n    using namespace std;\n    char animal[20] = \"bear\";  // animal holds bear\n    const char *bird = \"wren\"; // bird holds address of string\n    char *ps;                  // uninitialized\n\n    cout &lt;&lt; animal &lt;&lt; \" and \"; // display bear\n    cout &lt;&lt; bird &lt;&lt; \"\\n\";      // display wren\n    // cout &lt;&lt; ps &lt;&lt; \"\\n\"; //may display garbage, may cause a crash\n\n    cout &lt;&lt; \"Enter a kind of animal: \";\n    cin &gt;&gt; animal; // ok if input &lt; 20 chars\n    // cin &gt;&gt; ps; Too horrible a blunder to try; ps doesn't\n    // point to allocated space\n\n    ps = animal;         // set ps to point to string\n    cout &lt;&lt; ps &lt;&lt; \"!\\n\"; // ok, same as using animal\n    cout &lt;&lt; \"Before using strcpy():\\n\";\n    cout &lt;&lt; animal &lt;&lt; \" at \" &lt;&lt; (int *)animal &lt;&lt; endl;\n    cout &lt;&lt; ps &lt;&lt; \" at \" &lt;&lt; (int *)ps &lt;&lt; endl;\n\n    ps = new char[strlen(animal) + 1]; // get new storage\n    strcpy(ps, animal);                // copy string to new storage\n    cout &lt;&lt; \"After using strcpy():\\n\";\n    cout &lt;&lt; animal &lt;&lt; \" at \" &lt;&lt; (int *)animal &lt;&lt; endl;\n    cout &lt;&lt; ps &lt;&lt; \" at \" &lt;&lt; (int *)ps &lt;&lt; endl;\n    delete[] ps;\n    return 0;\n}\n\n/*\nHere is a sample run of the program in Listing 4.20:\n    bear and wren\n    Enter a kind of animal: fox\n    fox!\n    Before using strcpy():\n    fox at 0x0065fd30\n    fox at 0x0065fd30\n    After using strcpy():\n    fox at 0x0065fd30\n    fox at 0x004301c8\n*/\n</code></pre> <pre><code>const char * bird = \"wren\"; // bird holds address of string\n\n// you can use the pointer bird just as you would use the string \"wren\", as in this example:\ncout &lt;&lt; \"A concerned \" &lt;&lt; bird &lt;&lt; \" speaks\\n\";\n\nchar food[20] = \"carrots\"; // initialization\nstrcpy(food, \"flan\"); // otherwise\n\n\nps = animal; // set ps to point to string\n...\ncout &lt;&lt; animal &lt;&lt; \" at \" &lt;&lt; (int *) animal &lt;&lt; endl;\ncout &lt;&lt; ps &lt;&lt; \" at \" &lt;&lt; (int *) ps &lt;&lt; endl;\n\n// It produces the following output:\n// fox at 0x0065fd30\n// fox at 0x0065fd30\n</code></pre>"},{"location":"#using-new-to-create-dynamic-structures","title":"Using new to Create Dynamic Structures","text":"<pre><code>inflatable * ps = new inflatable;\ninflatable * ps = new inflatable[10];\n</code></pre> newstrct.cpp <pre><code>// newstrct.cpp -- using new with a structure\n#include &lt;iostream&gt;\nstruct inflatable // structure definition\n{\n    char name[20];\n    float volume;\n    double price;\n};\nint main()\n{\n    using namespace std;\n\n    inflatable *ps = new inflatable; // allot memory for structure\n    cout &lt;&lt; \"Enter name of inflatable item: \";\n    cin.get(ps-&gt;name, 20); // method 1 for member access\n    cout &lt;&lt; \"Enter volume in cubic feet: \";\n    cin &gt;&gt; (*ps).volume; // method 2 for member access\n    cout &lt;&lt; \"Enter price: $\";\n    cin &gt;&gt; ps-&gt;price;\n    cout &lt;&lt; \"Name: \" &lt;&lt; (*ps).name &lt;&lt; endl;              // method 2\n    cout &lt;&lt; \"Volume: \" &lt;&lt; ps-&gt;volume &lt;&lt; \" cubic feet\\n\"; // method 1\n    cout &lt;&lt; \"Price: $\" &lt;&lt; ps-&gt;price &lt;&lt; endl;             // method 1\n    delete ps;                                           // free memory used by structure\n    return 0;\n}\n\n/*\nHere is a sample run of the program in Listing 4.21:\n    Enter name of inflatable item: Fabulous Frodo\n    Enter volume in cubic feet: 1.4\n    Enter price: $27.99\n    Name: Fabulous Frodo\n    Volume: 1.4 cubic feet\n    Price: $27.99\n*/\n</code></pre>"},{"location":"#using-new-and-delete","title":"Using <code>new</code> and <code>delete</code>","text":"delete.cpp <pre><code>// delete.cpp -- using the delete operator\n#include &lt;iostream&gt;\n#include &lt;cstring&gt; // or string.h\nusing namespace std;\nchar *getname(void); // function prototype\nint main()\n{\n    char *name;       // create pointer but no storage\n\n    name = getname(); // assign address of string to name\n    cout &lt;&lt; name &lt;&lt; \" at \" &lt;&lt; (int *)name &lt;&lt; \"\\n\";\n    delete[] name;    // memory freed\n\n    name = getname(); // reuse freed memory\n    cout &lt;&lt; name &lt;&lt; \" at \" &lt;&lt; (int *)name &lt;&lt; \"\\n\";\n    delete[] name; // memory freed again\n    return 0;\n}\nchar *getname() // return pointer to new string\n{\n    char temp[80]; // temporary storage\n    cout &lt;&lt; \"Enter last name: \";\n    cin &gt;&gt; temp;\n    char *pn = new char[strlen(temp) + 1];\n    strcpy(pn, temp); // copy string into smaller space\n\n    return pn;        // temp lost when function ends\n}\n\n/*\nHere is a sample run of the program in Listing 4.22:\n    Enter last name: Fredeldumpkin\n    Fredeldumpkin at 0x004326b8\n    Enter last name: Pook\n    Pook at 0x004301c8\n*/\n</code></pre>"},{"location":"#automatic-storage-static-storage-and-dynamic-storage","title":"Automatic Storage, Static Storage, and Dynamic Storage","text":"<p>Ordinary variables defined inside a function use automatic storage and are called automatic variables. Automatic variables typically are stored on a <code>stack</code>.</p> <p>Static storage is storage that exists throughout the execution of an entire program. There are two ways to make a variable static.</p> <p>The new and delete operators provide a more flexible approach than automatic and static variables.They manage a pool of memory, which C++ refers to as the <code>free</code> store or <code>heap</code>.</p>"},{"location":"#combinations-of-types","title":"Combinations of Types","text":"mixtypes.cpp <pre><code>// mixtypes.cpp -- some type combinations\n#include &lt;iostream&gt;\nstruct antarctica_years_end\n{\n    int year;\n    /* some really interesting data, etc. */\n};\nint main()\n{\n    antarctica_years_end s01, s02, s03;\n    s01.year = 1998;\n    antarctica_years_end *pa = &amp;s02;\n    pa-&gt;year = 1999;\n    antarctica_years_end trio[3]; // array of 3 structures\n    trio[0].year = 2003;\n    std::cout &lt;&lt; trio-&gt;year &lt;&lt; std::endl;\n    const antarctica_years_end *arp[3] = {&amp;s01, &amp;s02, &amp;s03};\n    std::cout &lt;&lt; arp[1]-&gt;year &lt;&lt; std::endl;\n    const antarctica_years_end **ppa = arp;\n    auto ppb = arp; // C++11 automatic type deduction\n    // or else use const antarctica_years_end ** ppb = arp;\n    std::cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; std::endl;\n    std::cout &lt;&lt; (*(ppb + 1))-&gt;year &lt;&lt; std::endl;\n    return 0;\n}\n/*\nHere\u2019s the output:\n    2003\n    1999\n    1998\n    1999\n*/\n</code></pre>"},{"location":"#array-alternatives-vector","title":"Array Alternatives - <code>vector</code>","text":"<p><code>vector</code> class does use new and delete to manage memory, but it does so automatically.</p> <pre><code>vector&lt;typeName&gt; vt(n_elem);\n</code></pre> <pre><code>#include &lt;vector&gt;\n...\nusing namespace std;\nvector&lt;int&gt; vi; // create a zero-size array of int\nint n;\ncin &gt;&gt; n;\nvector&lt;double&gt; vd(n); // create an array of n doubles\n</code></pre> <p>We say that vi is an object of type vector and that vd is an object of type vector. <p>C++11 <code>array</code> Template Class</p> <p>Comparing Arrays, Vector Objects, and Array Objects</p> choices.cpp <pre><code>// choices.cpp -- array variations\n#include &lt;iostream&gt;\n#include &lt;vector&gt; // STL C++98\n#include &lt;array&gt;  // C++11\nint main()\n{\n    using namespace std;\n\n    // C, original C++\n    double a1[4] = {1.2, 2.4, 3.6, 4.8};\n    // C++98 STL\n    vector&lt;double&gt; a2(4); // create vector with 4 elements\n\n    // no simple way to initialize in C98\n    a2[0] = 1.0 / 3.0;\n    a2[1] = 1.0 / 5.0;\n    a2[2] = 1.0 / 7.0;\n    a2[3] = 1.0 / 9.0;\n\n    // C++11 -- create and initialize array object\n    array&lt;double, 4&gt; a3 = {3.14, 2.72, 1.62, 1.41};\n    array&lt;double, 4&gt; a4;\n    a4 = a3; // valid for array objects of same size\n\n    // use array notation\n    cout &lt;&lt; \"a1[2]: \" &lt;&lt; a1[2] &lt;&lt; \" at \" &lt;&lt; &amp;a1[2] &lt;&lt; endl;\n    cout &lt;&lt; \"a2[2]: \" &lt;&lt; a2[2] &lt;&lt; \" at \" &lt;&lt; &amp;a2[2] &lt;&lt; endl;\n    cout &lt;&lt; \"a3[2]: \" &lt;&lt; a3[2] &lt;&lt; \" at \" &lt;&lt; &amp;a3[2] &lt;&lt; endl;\n    cout &lt;&lt; \"a4[2]: \" &lt;&lt; a4[2] &lt;&lt; \" at \" &lt;&lt; &amp;a4[2] &lt;&lt; endl;\n\n    // misdeed\n    a1[-2] = 20.2;\n    cout &lt;&lt; \"a1[-2]: \" &lt;&lt; a1[-2] &lt;&lt; \" at \" &lt;&lt; &amp;a1[-2] &lt;&lt; endl;\n    cout &lt;&lt; \"a3[2]: \" &lt;&lt; a3[2] &lt;&lt; \" at \" &lt;&lt; &amp;a3[2] &lt;&lt; endl;\n    cout &lt;&lt; \"a4[2]: \" &lt;&lt; a4[2] &lt;&lt; \" at \" &lt;&lt; &amp;a4[2] &lt;&lt; endl;\n    return 0;\n}\n/*\nHere\u2019s some sample output:\n    a1[2]: 3.6 at 0x28cce8\n    a2[2]: 0.142857 at 0xca0328\n    a3[2]: 1.62 at 0x28ccc8\n    a4[2]: 1.62 at 0x28cca8\n    a1[-2]: 20.2 at 0x28ccc8\n    a3[2]: 20.2 at 0x28ccc8\n    a4[2]: 1.62 at 0x28cca8\n*/\n</code></pre> <p>Pointers and arrays are closely connected. If ar is an array name, then the expression <code>ar[i]</code>is interpreted as <code>*(ar + i)</code>, with the array name interpreted as the address of the first element of the array. Thus, the array name plays the same role as a pointer.</p>"},{"location":"#assign-safety","title":"Assign safety","text":"<pre><code>// a2[-2] = .5; // still allowed (out of range)\na2.at(1) = 2.3; // assign 2.3 to a2[1] \n</code></pre> <p>The difference between using bracket notation and the <code>at()</code> member function is that if you use <code>at()</code>, an invalid index is caught during runtime and the program, by default, aborts.</p>"},{"location":"#chapter-5-loops-and-relational-expressions","title":"Chapter 5: Loops and Relational Expressions","text":"List of what you will learn      <pre><code> - The for loop \n - Expressions and statements \n - The increment and decrement operators: ++ and -- \n - Combination assignment operators \n - Compound statements (blocks) \n - The comma operator \n - Relational operators: &gt;, &gt;=, ==, &lt;=, &lt;, and != \n - The while loop \n - The typedef facility \n - The do while loop \n - The get() character input method \n - The end-of-file condition \n - Nested loops and two-dimensional arrays \n</code></pre>"},{"location":"#loops-expressions-and-statements","title":"Loops, Expressions and Statements","text":"<p>You can\u2019t assign a for loop to a variable. In the following example, the for loop is not an expression, so it has no value and you can\u2019t assign it:</p> <pre><code>int fx = for (i = 0; i&lt; 4; i++)\ncout &gt;&gt; i; // not possible\n\nfor (expression; expression; expression)\n    statement\n</code></pre> formore.cpp - factorials in cpp <pre><code>// formore.cpp -- Factorials in cpp \n#include &lt;iostream&gt;\nconst int ArSize = 16; // example of external declaration\nint main()\n{\n    long long factorials[ArSize];\n    factorials[1] = factorials[0] = 1LL;\n    for (int i = 2; i &lt; ArSize; i++)\n        factorials[i] = i * factorials[i - 1];\n    for (int i = 0; i &lt; ArSize; i++)\n        std::cout &lt;&lt; i &lt;&lt; \"! = \" &lt;&lt; factorials[i] &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> forstr1.cpp - (string) letters in reverse order <pre><code>// forstr1.cpp -- using for with a string\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter a word: \";\n    string word;\n    cin &gt;&gt; word;\n    // display letters in reverse order\n    for (int i = word.size() - 1; i &gt;= 0; i--)\n        cout &lt;&lt; word[i];\n    cout &lt;&lt; \"\\nBye.\\n\";\n    return 0;\n}\n</code></pre> <p>Consider this statement:</p> <pre><code>y = (4 + x++) + (6 + x++);\n</code></pre> <p>The expression <code>4 + x++</code> is not a full expression, so C++ does not guarantee that <code>x</code> will be incremented immediately after the subexpression <code>4 + x++</code> is evaluated. Here the full expression is the entire assignment statement, and the semicolon marks the sequence point, so all that C++ guarantees is that x will have been incremented twice by the time the program moves to the following statement. C++ does not specify whether x is incremented after each subexpression is evaluated or only after all the expressions have been evaluated, which is why you should avoid statements of this kind.</p>"},{"location":"#prefix-postfix","title":"Prefix &amp; Postfix","text":"<p>postfix version works by first stashing a copy of the value, incrementing the value, and then returning the stashed copy.Thus, for classes, the prefix version is a bit more efficient than the postfix version.</p> <p>In short, for built-in types, it most likely makes no difference which form you use. For user-defined types having user-defined increment and decrement operators, the prefix form is more efficient.</p> <p>The right-to-left association rule for prefix operators implies that <code>*++pt</code> means first apply <code>++</code> to <code>pt</code> (because the <code>++</code> is to the right of the <code>*</code>) and then apply <code>*</code> to the new value of pt:</p> <pre><code>double x = *++pt; // increment pointer, take the value; i.e., arr[2], or 23.4\n++*pt; // increment the pointed to value; i.e., change 23.4 to 24.4\n(*pt)++; // increment pointed-to value\nx = *pt++; // dereference original location, then increment pointer\n</code></pre> <p>Incrementing and decrementing pointers follow pointer arithmetic rules. Thus, if pt points to the first member of an array, ++pt changes pt so that it points to the second member.</p>"},{"location":"#assignment-operators","title":"Assignment Operators","text":"<pre><code>+= Assigns L + R to L\n-= Assigns L - R to L\n*= Assigns L * R to L\n/= Assigns L / R to L\n%= Assigns L % R to L\n</code></pre>"},{"location":"#relational-operators","title":"Relational Operators","text":"<pre><code>&lt;&lt; Is less than\n&lt;= Is less than or equal to\n== Is equal to\n&gt; Is greater than\n&gt;= Is greater than or equal to\n!= Is not equal to\n</code></pre>"},{"location":"#compound-statements-or-blocks-syntax-tricks","title":"Compound Statements, or Blocks, Syntax Tricks","text":"block.cpp - Example of local code block <pre><code>// block.cpp -- use a block statement\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"The Amazing Accounto will sum and average \";\n    cout &lt;&lt; \"five numbers for you.\\n\";\n    cout &lt;&lt; \"Please enter five values:\\n\";\n    double number;\n    double sum = 0.0;\n    for (int i = 1; i &lt;= 5; i++)\n    { // block starts here\n        cout &lt;&lt; \"Value \" &lt;&lt; i &lt;&lt; \": \";\n        cin &gt;&gt; number;\n        sum += number;\n    } // block ends here\n    cout &lt;&lt; \"Five exquisite choices indeed! \";\n    cout &lt;&lt; \"They sum to \" &lt;&lt; sum &lt;&lt; endl;\n    cout &lt;&lt; \"and average to \" &lt;&lt; sum / 5 &lt;&lt; \".\\n\";\n    cout &lt;&lt; \"The Amazing Accounto bids you adieu!\\n\";\n    return 0;\n}\n</code></pre> <pre><code>++j, --i // two expressions count as one for syntax purposes\nint i, j; // comma is a separator here, not an operator\n</code></pre> forstr2.cpp - Example of comma separator trick <pre><code>// forstr2.cpp -- reversing an array\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter a word: \";\n    string word;\n    cin &gt;&gt; word;\n\n    // physically modify string object\n    char temp;\n    int i, j;\n    for (j = 0, i = word.size() - 1; j &lt; i; --i, ++j)\n    { // start block\n        temp = word[i];\n        word[i] = word[j];\n        word[j] = temp;\n    } // end block\n    cout &lt;&lt; word &lt;&lt; \"\\nDone\\n\";\n    return 0;\n}\n</code></pre> <p>The relational operators have a lower precedence than the arithmetic operators.That means this expression: <code>x + 3 &gt; y - 2 // Expression 1</code> corresponds to this: <code>(x + 3) &gt; (y - 2) // Expression 2</code> and not to the following: <code>x + (3 &gt; y) - 2 // Expression 3</code></p> <pre><code>strcmp(word, \"mate\") != 0 // strings are not the same\n</code></pre> compstr1.cpp - Example comparison c-string in search for word <pre><code>// compstr1.cpp -- comparing strings using arrays\n#include &lt;iostream&gt;\n#include &lt;cstring&gt; // prototype for strcmp()\nint main()\n{\n    using namespace std;\n    char word[5] = \"?ate\";\n    for (char ch = 'a'; strcmp(word, \"mate\"); ch++)\n    {\n        cout &lt;&lt; word &lt;&lt; endl;\n        word[0] = ch;\n    }\n    cout &lt;&lt; \"After loop ends, word is \" &lt;&lt; word &lt;&lt; endl;\n    return 0;\n}\n</code></pre> compstr2.cpp - Example comparison string class in search for word <pre><code>// compstr2.cpp -- comparing strings using arrays\n#include &lt;iostream&gt;\n#include &lt;string&gt; // string class\nint main()\n{\n    using namespace std;\n    string word = \"?ate\";\n    for (char ch = 'a'; word != \"mate\"; ch++)\n    {\n        cout &lt;&lt; word &lt;&lt; endl;\n        word[0] = ch;\n    }\n    cout &lt;&lt; \"After loop ends, word is \" &lt;&lt; word &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"#when-use-other-loop-forms","title":"When use other loop forms","text":"while.cpp - while for verticalized and ASCIIized string class input <pre><code>// while.cpp -- introducing the while loop\n#include &lt;iostream&gt;\nconst int ArSize = 20;\nint main()\n{\n    using namespace std;\n    char name[ArSize];\n    cout &lt;&lt; \"Your first name, please: \";\n    cin &gt;&gt; name;\n    cout &lt;&lt; \"Here is your name, verticalized and ASCIIized:\\n\";\n    int i = 0;              // start at beginning of string\n    while (name[i] != '\\0') // process to end of string\n    {\n        cout &lt;&lt; name[i] &lt;&lt; \": \" &lt;&lt; int(name[i]) &lt;&lt; endl;\n        i++; // don\u2019t forget this step\n    }\n    return 0;\n}\n</code></pre> <p>You can rewrite the while line this way:</p> <pre><code>while (name[i])\n</code></pre> <p>because when <code>name[i]</code> is an ordinary character, its value is the character code, which is nonzero, or true. But when name[i] is the null character, its character-code value is 0, or false.This notation is more concise (and more commonly used)</p>"},{"location":"#time-delay-loop","title":"Time-Delay Loop","text":"<p>ctime header file (time.h on less current implementations) provides solution:</p> <ul> <li>First, it defines a symbolic constant, CLOCKS_PER_SEC, that equals the number of system time units per second. (So dividing the system time by this value yields seconds)</li> <li>Or you can multiply seconds by CLOCKS_PER_SEC to get time in the system units.</li> <li>ctime establishes clock_t as an alias for the clock() return type. (See the sidebar \u201cType Aliases,\u201d later in this chapter.) This means you can declare a variable as type clock_t, and the compiler converts it to long or unsigned int or whatever is the proper type for your system.</li> </ul> waiting.cpp - using clock() in a time-delay loop <pre><code>// waiting.cpp -- using clock() in a time-delay loop\n#include &lt;iostream&gt;\n#include &lt;ctime&gt; // describes clock() function, clock_t type\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter the delay time, in seconds: \";\n    float secs;\n    cin &gt;&gt; secs;\n    clock_t delay = secs * CLOCKS_PER_SEC; // convert to clock ticks\n    cout &lt;&lt; \"starting\\a\\n\";\n    clock_t start = clock();\n    while (clock() - start &lt; delay) // wait until time elapses\n        ;                           // note the semicolon\n    cout &lt;&lt; \"done \\a\\n\";\n    return 0;\n}\n</code></pre>       Type Aliases       C++ has two ways to establish a new name as an alias for a type. One is to use the preprocessor:  <pre><code>#define BYTE char // preprocessor replaces BYTE with char\n</code></pre>  The preprocessor then replaces all occurrences of BYTE with char when you compile a program, thus making `BYTE` an alias for `char`. The second method is to use the C++ (and C) keyword `typedef` to create an alias. For example, to make byte an alias for `char`, you use this:  <pre><code>typedef char byte; // makes byte an alias for char\ntypedef typeName aliasName; // general form\n</code></pre>  In other words, if you want `aliasName` to be an alias for a particular type, you declare `aliasName` as if it were a variable of that type and then prefix the declaration with the `typedef` keyword. For example, to make `byte_pointer` an alias for pointer-to-char, you could declare `byte_pointer` as a pointer-to-char and then stick `typedef` in front:  <pre><code>typedef char * byte_pointer; // pointer to char type\n</code></pre>  You could try something similar with #define, but that wouldn\u2019t work if you declared a list of variables. For example, consider the following  <pre><code>#define FLOAT_POINTER float *\nFLOAT_POINTER pa, pb;\n\n//Preprocessor substitution converts the declaration to this:\nfloat * pa, pb; // pa a pointer to float, pb just a float\n</code></pre>  The `typedef` approach doesn\u2019t have that problem. Its ability to handle more complex type aliases makes using `typedef` a better choice than #define\u2014and sometimes it is the only choice.  Notice that `typedef` doesn\u2019t create a new type. It just creates a new name for an old type. If you make `word` an alias for `int`, `cout` treats a type `word` value as the `int` it really is.  <p></p> dowhile.cpp - for user input in loop (instead strange for loops) <pre><code>// dowhile.cpp -- exit-condition loop\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int n;\n    cout &lt;&lt; \"Enter numbers in the range 1-10 to find \";\n    cout &lt;&lt; \"my favorite number\\n\";\n    do\n    {\n        cin &gt;&gt; n;     // execute body\n    } while (n != 7); // then test\n    cout &lt;&lt; \"Yes, 7 is my favorite.\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"#the-range-based-for-loop-c11","title":"The Range-Based <code>for</code> Loop (C++11)","text":"<pre><code>double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};\nfor (double x : prices)\n    cout &lt;&lt; x &lt;&lt; std::endl; // Here x initially represents the first member of the prices array\n</code></pre> <p>To modify array values, you need a different syntax for the loop variable:</p> <pre><code>for (double &amp;x : prices)\nx = x * 0.80; //20% off sale\n</code></pre> <p>It can be used with initialization lists</p> <pre><code>for (int x : {3, 5, 2, 8, 6})\ncout &lt;&lt; x &lt;&lt; \" \";\ncout &lt;&lt; \u2018\\n\u2019;\n</code></pre>"},{"location":"#loops-and-text-input","title":"Loops and Text Input","text":"textin1.cpp - reading chars with a while loop, enter # to quit - cin() PROBLEMS <pre><code>// textin1.cpp -- reading chars with a while loop\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    char ch;\n    int count = 0; // use basic input\n    cout &lt;&lt; \"Enter characters; enter # to quit:\\n\";\n    cin &gt;&gt; ch;        // get a character\n    while (ch != '#') // test the character\n    {\n        cout &lt;&lt; ch; // echo the character\n        ++count;    // count the character\n        cin &gt;&gt; ch;  // get the next character\n    }\n    cout &lt;&lt; endl\n         &lt;&lt; count &lt;&lt; \" characters read\\n\";\n    return 0;\n}\n\n/*\nHere\u2019s a sample run of the program in Listing 5.16:\n    Enter characters; enter # to quit:\n    see ken run#really fast\n    seekenrun\n    9 characters read\n\n - textin1.cpp uses an entry-condition loop, the program correctly skips the entire\nloop in that case.And because the variable count was previously set to 0, count has the\ncorrect value.\n - When reading type char values, just as when reading other basic types, \n cin skips over spaces and newline characters.The spaces in the input are not echoed, \n so they are not counted.\n - The input to cin is buffered.That means the characters you type don\u2019t get sent to \n the program until you press Enter\n*/\n</code></pre> textin2.cpp - reading chars with a while loop, enter # to quit - cin.get(char) SOLUTION <pre><code>// textin2.cpp -- using cin.get(char)\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    char ch;\n    int count = 0;\n    cout &lt;&lt; \"Enter characters; enter # to quit:\\n\";\n    cin.get(ch); // use the cin.get(ch) function\n    while (ch != '#')\n    {\n        cout &lt;&lt; ch;\n        ++count;\n        cin.get(ch); // use it again\n    }\n    cout &lt;&lt; endl\n         &lt;&lt; count &lt;&lt; \" characters read\\n\";\n    return 0;\n}\n\n/*\nEnter characters; enter # to quit:\n    Did you use a #2 pencil?\n    Did you use a\n    14 characters read\n\n - program echoes and counts every character, including the spaces. Input is still\nbuffered, so it is still possible to type more input than what eventually reaches the program.\n- cin.get() passes ch, not &amp;ch. In C, code like this won\u2019t work. In C++ it can work, provided\nthat the function declares the argument as a reference.\n- argument passing in C++ works just as it does in C. For cin.get(ch), however, it doesn\u2019t.\n*/\n</code></pre>"},{"location":"#end-of-file-condition-and-read-data-from-keyboard","title":"End-of-File Condition and Read data from keyboard","text":"<p>The program to take input from the <code>fishtale</code> file instead of from the keyboard. The <code>&lt;</code> symbol is the redirection operator for both Unix and the Windows Command Prompt mode.</p> <pre><code>gofish &lt;fishtale\n</code></pre> <p>When <code>cin</code> detects the <code>EOF</code>, it sets two bits (the <code>eofbit</code> and the <code>failbit</code>) to 1. You can use a member function named <code>eof()</code> to see whether the <code>eofbit</code> has been set; the call <code>cin.eof()</code> returns the bool value true if the <code>EOF</code> has been detected and false otherwise</p> <p>Some systems do not support simulated EOF from the keyboard. Other systems support it imperfectly. If you have been using cin.get() to freeze the screen until you can read it, that won\u2019t work here because detecting the EOF turns off further attempts to read input.</p> textin3.cpp - reading chars till EOF (keyboard break) <pre><code>// textin3.cpp -- reading chars to end of file\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    char ch;\n    int count = 0;\n    cin.get(ch);                // attempt to read a char\n    while (cin.fail() == false) // test for EOF\n    {\n        cout &lt;&lt; ch; // echo character\n        ++count;\n        cin.get(ch); // attempt to read another char\n    }\n    cout &lt;&lt; endl\n         &lt;&lt; count &lt;&lt; \" characters read\\n\";\n    return 0;\n}\n\n/*\nHere is sample output from the program in Listing 5.18:\n\n// Windows\n    The green bird sings in the winter.&lt;ENTER&gt;\n    The green bird sings in the winter.\n    Yes, but the crow flies in the dawn.&lt;ENTER&gt;\n    Yes, but the crow flies in the dawn.\n    &lt;CTRL&gt;+&lt;C&gt; \n    73 characters read\n\n// Unix\n    $ textin3 &lt; stuff\n    I am a Unix file. I am proud\n    to be a Unix file.\n    48 characters read\n    $\n*/\n</code></pre> <p>The following is the essential design of a loop intended to read text a character at a time until EOF:</p> <pre><code>cin.get(ch); // attempt to read a char\nwhile (cin.fail() == false) // test for EOF\n{\n    ... // do stuff\n    cin.get(ch); // attempt to read another char\n}\n\n// you can use instead:\nwhile (!cin.fail()) // while input has not failed  (`!` - 'not true' operator)\n\n// This is a bit more general than using !cin.fail() or !cin.eof() because it detects\n// other possible causes of failure, such as disk failure\nwhile (cin) // while input is successful\n</code></pre> <p><code>cin.get(ch)</code> can condense loop above: Here, <code>cin.get(char)</code> is called once in the test condition instead of twice\u2014once before the loop and once at the end of the loop.</p> <pre><code>while (cin.get(ch)) // while input is successful\n{\n... // do stuff\n}\n</code></pre> <p>The cin.get() member function with no arguments returns the next character from the input.That is, you use it in this way: <code>ch = cin.get();</code> (Recall that cin.get(ch) returns an object, not the character read.) Similarly, you can use the <code>cout.put(ch)</code></p> textin4.cpp - incorporates the cin.get() and codense code <pre><code>// textin4.cpp -- reading chars with cin.get()\n#include &lt;iostream&gt;\nint main(void)\n{\n    using namespace std;\n    int ch; // should be int, not char\n    int count = 0;\n    while ((ch = cin.get()) != EOF) // test for end-of-file\n    {\n        cout.put(char(ch));\n        ++count;\n    }\n    cout &lt;&lt; endl\n         &lt;&lt; count &lt;&lt; \" characters read\\n\";\n    return 0;\n}\n\n/*\nHere\u2019s a sample run of the program in Listing 5.19:\n    The sullen mackerel sulks in the shadowy shallows.&lt;ENTER&gt;\n    The sullen mackerel sulks in the shadowy shallows.\n    Yes, but the blue bird of happiness harbors secrets.&lt;ENTER&gt;\n    Yes, but the blue bird of happiness harbors secrets.\n    &lt;CTRL&gt;+&lt;Z&gt;&lt;ENTER&gt;\n    104 characters read\n\nLet\u2019s analyze the loop condition:\n\n    while ((ch = cin.get()) != EOF)\nThe parentheses that enclose the subexpression ch = cin.get() cause the program to\nevaluate that expression first.To do the evaluation, the program first has to call the\ncin.get() function. Next, it assigns the function return value to ch. Because the value of\nan assignment statement is the value of the left operand, the whole subexpression reduces\nto the value of ch. If this value is EOF, the loop terminates; otherwise, it continues.The\ntest condition needs all the parentheses. Suppose you leave some parentheses out:\n\n    while (ch = cin.get() != EOF)\nThe != operator has higher precedence than =, so first the program compares\ncin.get()\u2019s return value to EOF.A comparison produces a false or true result; that\nbool value is converted to 0 or 1, and that\u2019s the value that gets assigned to ch.\nUsing cin.get(ch) (with an argument) for input, on the other hand, doesn\u2019t create\nany type problems. Remember that the cin.get(char) function doesn\u2019t assign a special\nvalue to ch at the EOF. In fact, it doesn\u2019t assign anything to ch in that case. ch is never\ncalled on to hold a non-char value.Table 5.3 summarizes the differences between\ncin.get(char) and cin.get().\n\n*/\n</code></pre> Property <code>cin.get(ch)</code> <code>ch=cin.get()</code> Method for conveying input character Assign to argument ch Use function return value to assign to <code>ch</code> Function return value for character input A class <code>istream</code> object (true after <code>bool</code> conversion) Code for character as type <code>int</code> value Function return value at EOF A class <code>istream</code> object (false after <code>bool</code> conversion) EOF"},{"location":"#nested-loops-and-two-dimensional-arrays","title":"Nested Loops and Two-Dimensional Arrays","text":"<p>Initialize</p> <pre><code>int maxtemps[4][5] = // 2-D array\n{\n{96, 100, 87, 101, 105}, // values for maxtemps[0]\n{96, 98, 91, 107, 104}, // values for maxtemps[1]\n{97, 101, 93, 108, 107}, // values for maxtemps[2]\n{98, 103, 95, 109, 108} // values for maxtemps[3]\n};\n</code></pre> nested.cpp - nested loops and 2-D array <pre><code>// nested.cpp -- nested loops and 2-D array\n#include &lt;iostream&gt;\nconst int Cities = 5;\nconst int Years = 4;\nint main()\n{\n    using namespace std;\n    const char *cities[Cities] = // array of pointers\n        {                        // to 5 strings\n         \"Gribble City\",\n         \"Gribbletown\",\n         \"New Gribble\",\n         \"San Gribble\",\n         \"Gribble Vista\"};\n    int maxtemps[Years][Cities] = // 2-D array\n        {\n            {96, 100, 87, 101, 105}, // values for maxtemps[0]\n            {96, 98, 91, 107, 104},  // values for maxtemps[1]\n            {97, 101, 93, 108, 107}, // values for maxtemps[2]\n            {98, 103, 95, 109, 108}  // values for maxtemps[3]\n        };\n    cout &lt;&lt; \"Maximum temperatures for 2008 - 2011\\n\\n\";\n    for (int city = 0; city &lt; Cities; ++city)\n    {\n        cout &lt;&lt; cities[city] &lt;&lt; \":\\t\";\n        for (int year = 0; year &lt; Years; ++year)\n            cout &lt;&lt; maxtemps[year][city] &lt;&lt; \"\\t\";\n        cout &lt;&lt; endl;\n    }\n    // cin.get();\n    return 0;\n}\n</code></pre>"},{"location":"#chapter-6-branching-statements-and-logical-operators","title":"Chapter 6: Branching Statements and Logical Operators","text":"List of what you will learn      <pre><code> - The `if` statement\n - The `if else` statement\n - Logical operators: `&amp;&amp;`, `||`, and `!`\n - The `cctype` library of character functions\n - The conditional operator: `?:`\n - The switch statement\n - The continue and break statements\n - Number-reading loops\n - Basic file input/output\n</code></pre>"},{"location":"#statements-and-logical-operators","title":"Statements and logical operators","text":"if.cpp - (count spaces in while) simple use of if statement <pre><code>// if.cpp -- using the if statement\n#include &lt;iostream&gt;\n    int\n    main()\n{\n    using std::cin; // using declarations\n    using std::cout;\n    char ch;\n    int spaces = 0;\n    int total = 0;\n    cin.get(ch);\n    while (ch != '.') // quit at end of sentence\n    {\n        if (ch == ' ') // check if ch is a space\n            ++spaces;\n        ++total; // done every time\n        cin.get(ch);\n    }\n    cout &lt;&lt; spaces &lt;&lt; \" spaces, \" &lt;&lt; total;\n    cout &lt;&lt; \" characters total in sentence\\n\";\n    return 0;\n}\n\n/*\nHere\u2019s some sample output from the program in Listing 6.1:\n    The balloonist was an airhead\n    with lofty goals.\n    6 spaces, 46 characters total in sentence\n*/\n</code></pre> ifelse.cpp - (simplest cipher from keyboard) simple use of if else statement <pre><code>// ifelse.cpp -- using the if else statement\n#include &lt;iostream&gt;\nint main()\n{\n    char ch;\n\n    std::cout &lt;&lt; \"Type, and I shall repeat.\\n\";\n    std::cin.get(ch);\n    while (ch != '.')\n    {\n        if (ch == '\\n')\n            std::cout &lt;&lt; ch; // done if newline\n        else\n            std::cout &lt;&lt; ++ch; // done otherwise (try also with (ch+1) )\n        std::cin.get(ch);\n    }\n    // try ch + 1 instead of ++ch for interesting effect\n    std::cout &lt;&lt; \"\\nPlease excuse the slight confusion.\\n\";\n    // std::cin.get();\n    // std::cin.get();\n    return 0;\n}\n\n/*\nHere\u2019s some sample output from the program in Listing 6.2:\n    Type, and I shall repeat.\n    An ineffable joy suffused me as I beheld\n    Bo!jofggbcmf!kpz!tvggvtfe!nf!bt!J!cfifme\n    the wonders of modern computing.\n    uif!xpoefst!pg!npefso!dpnqvujoh\n    Please excuse the slight confusion.\n*/\n</code></pre> ifelseif.cpp -  simple use of if elseif else statement for guess game <pre><code>// ifelseif.cpp -- using if else if else\n#include &lt;iostream&gt;\nconst int Fave = 27;\nint main()\n{\n    using namespace std;\n    int n;\n    cout &lt;&lt; \"Enter a number in the range 1-100 to find \";\n    cout &lt;&lt; \"my favorite number: \";\n    do\n    {\n        cin &gt;&gt; n;\n        if (n &lt; Fave)\n            cout &lt;&lt; \"Too low -- guess again: \";\n        else if (n &gt; Fave)\n            cout &lt;&lt; \"Too high -- guess again: \";\n        else\n            cout &lt;&lt; Fave &lt;&lt; \" is right!\\n\";\n    } while (n != Fave);\n    return 0;\n}\n\n/*\nHere\u2019s some sample output from the program in Listing 6.3:\n    Enter a number in the range 1-100 to find my favorite number: 50\n    Too high -- guess again: 25\n    Too low -- guess again: 37\n    Too high -- guess again: 31\n    Too high -- guess again: 28\n    Too high -- guess again: 27\n    27 is right!\n*/\n</code></pre>"},{"location":"#conditional-operators-and-bug-prevention","title":"Conditional Operators and Bug Prevention","text":"<p>Many programmers reverse the more intuitive expression <code>variable == value</code> to <code>value == variable</code> in order to catch errors where the equality is mistyped as an assignment operator. For example, entering the conditional as follows is valid and will work properly: <code>if (3 == myNumber)</code> However, if you happen to mistype as follows, the compiler will generate an error message because it believes you are attempting to assign a value to a literal (3 always equals 3 and can\u2019t be assigned another value): <code>if (3 = myNumber)</code> Suppose you made a similar mistake, using the former notation: <code>if (myNumber = 3)</code> The compiler would simply assign the value 3 to myNumber, and the block within the if would run\u2014a very common error, and a difficult error to find. (However, many compilers will issue a warning, which you would be wise to heed.) As a general rule, writing code that allows the compiler to find errors is much easier than repairing the causes of mysterious faulty results.</p>"},{"location":"#logical-expressions","title":"Logical expressions","text":"<p><code>||</code> - Logical OR Operator is true, when one or both of two conditions satisfy a requirement. <code>&amp;&amp;</code> - Logical AND Operator is true only if both of the original expressions are true. <code>!</code> - Logical NOT Operator negates, or reverses the truth value of, the expression that follows it.</p> <p>logical OR and logical AND operators have a lower precedence than relational operators. This means that an expression such as this: <code>x &gt; 5 &amp;&amp; x &lt; 10</code> is interpreted this way: <code>(x &gt; 5) &amp;&amp; (x &lt; 10)</code></p> <p>The logical AND operator has a higher precedence than the logical OR, Thus this expression: <code>age &gt; 30 &amp;&amp; age &lt; 45 || weight &gt; 300</code>, means the following: <code>(age &gt; 30 &amp;&amp; age &lt; 45) || weight &gt; 300</code></p> <p>C++ guarantees that when a program evaluates a logical expression, it evaluates it from left to right and stops evaluation as soon as it knows what the answer is.</p> or.cpp - simple use of the logical OR operator <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"This program may reformat your hard disk\\n\"\n            \"and destroy all your data.\\n\"\n            \"Do you wish to continue? &lt;y/n&gt; \";\n    char ch;\n    cin &gt;&gt; ch;\n    if (ch == 'y' || ch == 'Y') // y or Y\n        cout &lt;&lt; \"You were warned!\\a\\a\\n\";\n    else if (ch == 'n' || ch == 'N') // n or N\n        cout &lt;&lt; \"A wise choice ... bye\\n\";\n    else\n        cout &lt;&lt; \"That wasn't a y or n! Apparently you \"\n                \"can't follow\\ninstructions, so \"\n                \"I'll trash your disk anyway.\\a\\a\\a\\n\";\n    return 0;\n}\n\n/*\n    This program may reformat your hard disk\n    and destroy all your data.\n    Do you wish to continue? &lt;y/n&gt; N\n    A wise choice ... bye\n*/\n</code></pre> and.cpp - simple use of the logical AND operator <pre><code>// and.cpp -- using the logical AND operator\n#include &lt;iostream&gt;\nconst int ArSize = 6;\nint main()\n{\n    using namespace std;\n    float naaq[ArSize];\n    cout &lt;&lt; \"Enter the NAAQs (New Age Awareness Quotients) \"\n         &lt;&lt; \"of\\nyour neighbors. Program terminates \"\n         &lt;&lt; \"when you make\\n\"\n         &lt;&lt; ArSize &lt;&lt; \" entries \"\n         &lt;&lt; \"or enter a negative value.\\n\";\n    int i = 0;\n    float temp;\n    cout &lt;&lt; \"First value: \";\n    cin &gt;&gt; temp;\n    while (i &lt; ArSize &amp;&amp; temp &gt;= 0) // 2 quitting criteria\n    {\n        naaq[i] = temp;\n        ++i;\n        if (i &lt; ArSize) // room left in the array,\n        {\n            cout &lt;&lt; \"Next value: \";\n            cin &gt;&gt; temp; // so get next value\n        }\n    }\n    if (i == 0)\n        cout &lt;&lt; \"No data--bye\\n\";\n    else\n    {\n        cout &lt;&lt; \"Enter your NAAQ: \";\n        float you;\n        cin &gt;&gt; you;\n        int count = 0;\n        for (int j = 0; j &lt; i; j++)\n            if (naaq[j] &gt; you)\n                ++count;\n        cout &lt;&lt; count;\n        cout &lt;&lt; \" of your neighbors have greater awareness of\\n\"\n             &lt;&lt; \"the New Age than you do.\\n\";\n    }\n    return 0;\n}\n\n/*\nSample runs:\n\nOne terminates after six entries:\n    Enter the NAAQs (New Age Awareness Quotients) of\n    your neighbors. Program terminates when you make\n    6 entries or enter a negative value.\n    First value: 28\n    Next value: 72\n    Next value: 15\n    Next value: 6\n    Next value: 130\n    Next value: 145\n    Enter your NAAQ: 50\n    3 of your neighbors have greater awareness of\n    the New Age than you do.\n\nThe second run terminates after a negative value is entered:\n    Enter the NAAQs (New Age Awareness Quotients) of\n    your neighbors. Program terminates when you make\n    6 entries or enter a negative value.\n    First value: 123\n    Next value: 119\n    Next value: 4\n    Next value: 89\n    Next value: -1\n    Enter your NAAQ: 123.031\n    0 of your neighbors have greater awareness of\n    the New Age than you do.\n*/\n</code></pre> more_and.cpp - range using AND operator <pre><code>// more_and.cpp -- using the logical AND operator\n#include &lt;iostream&gt;\nconst char *qualify[4] = // an array of pointers\n    {                    // to strings\n        \"10,000-meter race.\\n\",\n        \"mud tug-of-war.\\n\",\n        \"masters canoe jousting.\\n\",\n        \"pie-throwing festival.\\n\"};\nint main()\n{\n    using namespace std;\n    int age;\n    cout &lt;&lt; \"Enter your age in years: \";\n    cin &gt;&gt; age;\n    int index;\n    if (age &gt; 17 &amp;&amp; age &lt; 35)\n        index = 0;\n    else if (age &gt;= 35 &amp;&amp; age &lt; 50)\n        index = 1;\n    else if (age &gt;= 50 &amp;&amp; age &lt; 65)\n        index = 2;\n    else\n        index = 3;\n    cout &lt;&lt; \"You qualify for the \" &lt;&lt; qualify[index];\n    return 0;\n}\n\n/*\n    Enter your age in years: 87\n    You qualify for the pie-throwing festival\n*/\n</code></pre> not.cpp - simple use of NOT operator <pre><code>// not.cpp -- using the not operator\n#include &lt;iostream&gt;\n#include &lt;climits&gt;\nbool is_int(double);\nint main()\n{\n    using namespace std;\n    double num;\n    cout &lt;&lt; \"Yo, dude! Enter an integer value: \";\n    cin &gt;&gt; num;\n    while (!is_int(num)) // continue while num is not int-able\n    {\n        cout &lt;&lt; \"Out of range -- please try again: \";\n        cin &gt;&gt; num;\n    }\n    int val = int(num); // type cast\n    cout &lt;&lt; \"You've entered the integer \" &lt;&lt; val &lt;&lt; \"\\nBye\\n\";\n    return 0;\n}\nbool is_int(double x)\n{\n    if (x &lt;= INT_MAX &amp;&amp; x &gt;= INT_MIN) // use climits values\n        return true;\n    else\n        return false;\n}\n\n/*\n    Yo, dude! Enter an integer value: 6234128679\n    Out of range -- please try again: -8000222333\n    Out of range -- please try again: 99999\n    You've entered the integer 99999\n    Bye\n*/\n</code></pre>"},{"location":"#range-tests","title":"Range Tests","text":"<p>Note that each part of a range test should use the AND operator to join two complete relational expressions: <code>if (age &gt; 17 &amp;&amp; age &lt; 35) // OK</code> Don\u2019t borrow from mathematics and use the following notation: <code>if (17 &lt; age &lt; 35) // Don't do this!</code> If you make this mistake, the compiler won\u2019t catch it as an error because it is still valid C++ syntax. The <code>&lt;</code> operator associates from left to right, so the previous expression means the following: <code>if ( (17 &lt; age) &lt; 35)</code> But <code>17 &lt; age</code> is either <code>true</code>, or <code>1</code>, or else <code>false</code>, or <code>0</code>. In either case, the expression <code>17 &lt; age</code> is less than 35, so the entire test is always true!</p>"},{"location":"#cctype-library-of-character-functions","title":"<code>cctype</code> library of Character Functions","text":"<p>simplify such tasks as determining whether a character is an uppercase letter or a digit or punctuation</p> <p>Using these functions is more convenient than using the AND and OR operators. For example, here\u2019s how you might use AND and OR to test whether a character <code>ch</code> is an alphabetic character:</p> <pre><code>if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z'))\n</code></pre> <p>Is equivalent to:</p> <pre><code>if (isalpha(ch))\n</code></pre> <p>In program <code>cctypes.cpp</code> below <code>isalpha()</code>,  tests for alphabetic characters; <code>isdigits()</code>,  tests for digit characters, such as 3; <code>isspace()</code>, tests for whitespace characters, such as newlines, spaces, and tabs; <code>ispunct()</code>,  tests for punctuation characters</p> cctypes.cpp - demonstrates some functions of the ctype.h library <pre><code>// cctypes.cpp -- using the ctype.h library\n#include &lt;iostream&gt;\n#include &lt;cctype&gt; // prototypes for character functions\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter text for analysis, and type @\"\n            \" to terminate input.\\n\";\n    char ch;\n    int whitespace = 0;\n    int digits = 0;\n    int chars = 0;\n    int punct = 0;\n    int others = 0;\n    cin.get(ch);      // get first character\n    while (ch != '@') // test for sentinel\n    {\n        if (isalpha(ch)) // is it an alphabetic character?\n            chars++;\n        else if (isspace(ch)) // is it a whitespace character?\n            whitespace++;\n        else if (isdigit(ch)) // is it a digit?\n            digits++;\n        else if (ispunct(ch)) // is it punctuation?\n            punct++;\n        else\n            others++;\n        cin.get(ch); // get next character\n    }\n    cout &lt;&lt; chars &lt;&lt; \" letters, \"\n         &lt;&lt; whitespace &lt;&lt; \" whitespace, \"\n         &lt;&lt; digits &lt;&lt; \" digits, \"\n         &lt;&lt; punct &lt;&lt; \" punctuations, \"\n         &lt;&lt; others &lt;&lt; \" others.\\n\";\n    return 0;\n}\n\n/*\n    Enter text for analysis, and type @ to terminate input.\n    AdrenalVision International producer Adrienne Vismonger\n    announced production of their new 3-D film, a remake of\n    \"My Dinner with Andre,\" scheduled for 2013. \"Wait until\n    you see the the new scene with an enraged Collossipede!\"@\n    177 letters, 33 whitespace, 5 digits, 9 punctuations, 0 others.\n*/\n</code></pre> <p>Function Name</p> <ul> <li><code>isalnum()</code> - returns true if the argument is alphanumeric (that is, a letter or a digit).</li> <li><code>isalpha()</code> - returns true if the argument is alphabetic.</li> <li><code>isblank()</code> - returns true if the argument is a space or a horizontal tab.</li> <li><code>iscntrl()</code> - returns true if the argument is a control character.</li> <li><code>isdigit()</code> - returns true if the argument is a decimal digit (0\u20139).</li> <li><code>isgraph()</code> - returns true if the argument is any printing character other than a space.</li> <li><code>islower()</code> - returns true if the argument is a lowercase letter.</li> <li><code>isprint()</code> - returns true if the argument is any printing character, including a space.</li> <li><code>ispunct()</code> - returns true if the argument is a punctuation character.</li> <li><code>isspace()</code> - returns true if the argument is a standard whitespace character (that is, a space, formfeed, newline, carriage return, horizontal tab, vertical tab).</li> <li><code>isupper()</code> - returns true if the argument is an uppercase letter.</li> <li><code>isxdigit()</code> - returns true if the argument is a hexadecimal digit character (that is, 0\u20139, a\u2013f, or A\u2013F).</li> <li><code>tolower()</code> - If the argument is an uppercase character, tolower() returns the lowercase version of that character; otherwise, it returns the argument unaltered.</li> <li><code>toupper()</code> - If the argument is a lowercase character, toupper() returns the uppercase version of that character; otherwise, it returns the argument unaltered.</li> </ul>"},{"location":"#the-operator","title":"The <code>?:</code> Operator","text":"<p><code>expression1 ? expression2 : expression3</code> If <code>expression1</code> is <code>true</code>, then the value of the whole conditional expression is the value of <code>expression2</code>. Otherwise, the value of the whole expression is the value of <code>expression3</code>.</p> <pre><code>5 &gt; 3 ? 10 : 12 // 5 &gt; 3 is true, so expression value is 10\n3 == 9 ? 25 : 18 // 3 == 9 is false, so expression value is 18\n</code></pre> condit.cpp - example of ?: use <pre><code>// condit.cpp -- using the conditional operator\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int a, b;\n    cout &lt;&lt; \"Enter two integers: \";\n    cin &gt;&gt; a &gt;&gt; b;\n    cout &lt;&lt; \"The larger of \" &lt;&lt; a &lt;&lt; \" and \" &lt;&lt; b;\n    int c = a &gt; b ? a : b; // c = a if a &gt; b, else c = b\n    cout &lt;&lt; \" is \" &lt;&lt; c &lt;&lt; endl;\n    return 0;\n}\n\n/*\n    Enter two integers: 123 213\n    The larger of 123 and 213 is 213\n*/\n</code></pre>"},{"location":"#the-switch-statement","title":"The <code>switch</code> Statement","text":"switch.cpp - menu program, example of switch use <pre><code>// switch.cpp -- using the switch statement\n#include &lt;iostream&gt;\nusing namespace std;\nvoid showmenu(); // function prototypes\nvoid report();\nvoid comfort();\nint main()\n{\n    showmenu();\n    int choice;\n    cin &gt;&gt; choice;\n    while (choice != 5)\n    {\n        switch (choice)\n        {\n        case 1:\n            cout &lt;&lt; \"\\a\\n\";\n            break;\n        case 2:\n            report();\n            break;\n        case 3:\n            cout &lt;&lt; \"The boss was in all day.\\n\";\n            break;\n        case 4:\n            comfort();\n            break;\n        default:\n            cout &lt;&lt; \"That's not a choice.\\n\";\n        }\n        showmenu();\n        cin &gt;&gt; choice;\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\nvoid showmenu()\n{\n    cout &lt;&lt; \"Please enter 1, 2, 3, 4, or 5:\\n\"\n            \"1) alarm 2) report\\n\"\n            \"3) alibi 4) comfort\\n\"\n            \"5) quit\\n\";\n}\nvoid report()\n{\n    cout &lt;&lt; \"It's been an excellent week for business.\\n\"\n            \"Sales are up 120%. Expenses are down 35%.\\n\";\n}\nvoid comfort()\n{\n    cout &lt;&lt; \"Your employees think you are the finest CEO\\n\"\n            \"in the industry. The board of directors think\\n\"\n            \"you are the finest CEO in the industry.\\n\";\n}\n\n/*\nSample run of the executive menu program:\n    Please enter 1, 2, 3, 4, or 5:\n    1) alarm 2) report\n    3) alibi 4) comfort\n    5) quit\n    4\n    Your employees think you are the finest CEO\n    in the industry. The board of directors think\n    you are the finest CEO in the industry.\n    Please enter 1, 2, 3, 4, or 5:\n    1) alarm 2) report\n    3) alibi 4) comfort\n    5) quit\n    2\n    It's been an excellent week for business.\n    Sales are up 120%. Expenses are down 35%.\n    Please enter 1, 2, 3, 4, or 5:\n    1) alarm 2) report\n    3) alibi 4) comfort\n    5) quit\n    6\n    That's not a choice.\n    Please enter 1, 2, 3, 4, or 5:\n    1) alarm 2) report\n    3) alibi 4) comfort\n    5) quit\n    5\n    Bye!\n\nFor example, suppose you rewrote it using characters instead of integers as menu choices and switch labels. In that\ncase, you could use both an uppercase and a lowercase label for the same statements:\n\nchar choice;\ncin &gt;&gt; choice;\nwhile (choice != 'Q' &amp;&amp; choice != 'q')\n{\n    switch(choice)\n    {\n        case 'a':\n        case 'A': cout &lt;&lt; \"\\a\\n\";\n            break;\n        case 'r':\n        case 'R': report();\n            break;\n        case 'l':\n        case 'L': cout &lt;&lt; \"The boss was in all day.\\n\";\n            break;\n        case 'c':\n        case 'C': comfort();\n            break;\n        default : cout &lt;&lt; \"That's not a choice.\\n\";\n    }\n    showmenu();\n    cin &gt;&gt; choice;\n}\n*/\n</code></pre> enum.cpp - menu program with enum labels <pre><code>// enum.cpp -- using enum\n#include &lt;iostream&gt;\n// create named constants for 0 - 6\nenum {red, orange, yellow, green, blue, violet, indigo};\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter color code (0-6): \";\n    int code;\n    cin &gt;&gt; code;\n    while (code &gt;= red &amp;&amp; code &lt;= indigo)\n    {\n        switch (code)\n        {\n            case red : cout &lt;&lt; \"Her lips were red.\\n\"; break;\n            case orange : cout &lt;&lt; \"Her hair was orange.\\n\"; break;\n            case yellow : cout &lt;&lt; \"Her shoes were yellow.\\n\"; break;\n            case green : cout &lt;&lt; \"Her nails were green.\\n\"; break;\n            case blue : cout &lt;&lt; \"Her sweatsuit was blue.\\n\"; break;\n            case violet : cout &lt;&lt; \"Her eyes were violet.\\n\"; break;\n            case indigo : cout &lt;&lt; \"Her mood was indigo.\\n\"; break;\n        }\n        cout &lt;&lt; \"Enter color code (0-6): \";\n        cin &gt;&gt; code;\n    }\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\n/*\nHere\u2019s sample output from the program:\n    Enter color code (0-6): 3\n    Her nails were green.\n    Enter color code (0-6): 5\n    Her eyes were violet.\n    Enter color code (0-6): 2\n    Her shoes were yellow.\n    Enter color code (0-6): 8\n    Bye\n*/\n</code></pre>"},{"location":"#the-break-and-continue-statements","title":"The break and continue Statements","text":"<p><code>break</code> statement causes program execution to pass to the next statement following the switch or the loop <code>continue</code> statement is used in loops and causes a program to skip the rest of the body of the loop</p> jump.cpp - using continue and break <pre><code>#include &lt;iostream&gt;\nconst int ArSize = 80;\nint main()\n{\n    using namespace std;\n    char line[ArSize];\n    int spaces = 0;\n    cout &lt;&lt; \"Enter a line of text:\\n\";\n    cin.get(line, ArSize);\n    cout &lt;&lt; \"Complete line:\\n\"\n         &lt;&lt; line &lt;&lt; endl;\n    cout &lt;&lt; \"Line through first period:\\n\";\n    for (int i = 0; line[i] != '\\0'; i++)\n    {\n        cout &lt;&lt; line[i];    // display character\n        if (line[i] == '.') // quit if it's a period\n            break;\n        if (line[i] != ' ') // skip rest of loop\n            continue;\n        spaces++;\n    }\n    cout &lt;&lt; \"\\n\"\n         &lt;&lt; spaces &lt;&lt; \" spaces\\n\";\n    cout &lt;&lt; \"Done.\\n\";\n    return 0;\n}\n\n/*\n    Enter a line of text:\n    Let's do lunch today. You can pay!\n    Complete line:\n    Let's do lunch today. You can pay!\n    Line through first period:\n    Let's do lunch today.\n    3 spaces\n    Done.\n*/\n</code></pre> cinfish.cpp - to terminate input before filling the array example <pre><code>// cinfish.cpp -- non-numeric input terminates loop\n#include &lt;iostream&gt;\nconst int Max = 5;\nint main()\n{\n    using namespace std;\n    // get data\n    double fish[Max];\n    cout &lt;&lt; \"Please enter the weights of your fish.\\n\";\n    cout &lt;&lt; \"You may enter up to \" &lt;&lt; Max\n         &lt;&lt; \" fish &lt;q to terminate&gt;.\\n\";\n    cout &lt;&lt; \"fish #1: \";\n    int i = 0;\n    while (i &lt; Max &amp;&amp; cin &gt;&gt; fish[i])\n    {\n        if (++i &lt; Max)\n            cout &lt;&lt; \"fish #\" &lt;&lt; i + 1 &lt;&lt; \": \";\n    }\n    // calculate average\n    double total = 0.0;\n    for (int j = 0; j &lt; i; j++)\n        total += fish[j];\n    // report results\n    if (i == 0)\n        cout &lt;&lt; \"No fish\\n\";\n    else\n        cout &lt;&lt; total / i &lt;&lt; \" = average weight of \"\n             &lt;&lt; i &lt;&lt; \" fish\\n\";\n    cout &lt;&lt; \"Done.\\n\";\n    return 0;\n}\n\n/*\n    Please enter the weights of your fish.\n    You may enter up to 5 fish &lt;q to terminate&gt;.\n    fish #1: 30\n    fish #2: 35\n    fish #3: 25\n    fish #4: 40\n    fish #5: q\n    32.5 = average weight of 4 fish\n    Done.\n\nAs mentioned earlier, some execution environments require additional code to keep the window\nopen so that you can see the output. In this example, because the input 'q' turns off\nfurther input, the treatment is more elaborate:\n\n    if (!cin) // input terminated by non-numeric response\n    {\n        cin.clear(); // reset input\n        cin.get(); // read q\n    }\n    cin.get(); // read end of line after last input\n    cin.get(); // wait for user to press &lt;Enter&gt;\n*/\n</code></pre> cingolf.cpp - to terminate input before filling the array example and reset cin to accept new input. <pre><code>// cingolf.cpp -- non-numeric input skipped\n#include &lt;iostream&gt;\nconst int Max = 5;\nint main()\n{\n    using namespace std;\n    // get data\n    int golf[Max];\n    cout &lt;&lt; \"Please enter your golf scores.\\n\";\n    cout &lt;&lt; \"You must enter \" &lt;&lt; Max &lt;&lt; \" rounds.\\n\";\n    int i;\n    for (i = 0; i &lt; Max; i++)\n    {\n        cout &lt;&lt; \"round #\" &lt;&lt; i + 1 &lt;&lt; \": \";\n        while (!(cin &gt;&gt; golf[i]))\n        {\n            cin.clear(); // reset input\n            while (cin.get() != '\\n')\n                continue; // get rid of bad input\n            cout &lt;&lt; \"Please enter a number: \";\n        }\n    }\n    // calculate average\n    double total = 0.0;\n    for (i = 0; i &lt; Max; i++)\n        total += golf[i];\n    // report results\n    cout &lt;&lt; total / Max &lt;&lt; \" = average score \"\n         &lt;&lt; Max &lt;&lt; \" rounds\\n\";\n    return 0;\n}\n\n/*\n    Please enter your golf scores.\n    You must enter 5 rounds.\n    round #1: 88\n    round #2: 87\n    round #3: must i?\n    Please enter a number: 103\n    round #4: 94\n    round #5: 86\n    91.6 = average score 5 rounds\n*/\n</code></pre>"},{"location":"#file-inputoutput","title":"File Input/Output","text":""},{"location":"#write-to-file","title":"Write to file","text":"<p>You have to declare your own <code>ofstream</code> object, choosing a name for it and associating it with a file.</p> <p>Declaration:</p> <pre><code>ofstream outFile; // outFile an ofstream object\nofstream fout; // fout an ofstream object\n</code></pre> <p>Association with file (<code>open()</code> method requires a C-style string as its argument):</p> <pre><code>outFile.open(\"fish.txt\"); // outFile used to write to the fish.txt file\nchar filename[50];\ncin &gt;&gt; filename; // user specifies a name\nfout.open(filename); // fout used to read specified file\n</code></pre> <p>Use created object (after you\u2019ve declared an ofstream object and associated it with a file, you use it exactly as you would use cout):</p> <pre><code>double wt = 125.8;\noutFile &lt;&lt; wt; // write a number to fish.txt\nchar line[81] = \"Objects are closer than they appear.\";\nfout &lt;&lt; line &lt;&lt; endl; // write a line of text\n</code></pre> <p>Main steps for using file output:</p> <ol> <li>Include the fstream header file.</li> <li>Create an ofstream object.</li> <li>Associate the ofstream object with a file.</li> <li>Use the ofstream object in the same manner you would use cout.</li> </ol> outfile.cpp - write data to file. <pre><code>// outfile.cpp -- writing to a file\n#include &lt;iostream&gt;\n#include &lt;fstream&gt; // for file I/O\nint main()\n{\n    using namespace std;\n\n    char automobile[50];\n    int year;\n    double a_price;\n    double d_price;\n\n    ofstream outFile;            // create object for output\n    outFile.open(\"carinfo.txt\"); // associate with a file\n\n    cout &lt;&lt; \"Enter the make and model of automobile: \";\n    cin.getline(automobile, 50);\n    cout &lt;&lt; \"Enter the model year: \";\n    cin &gt;&gt; year;\n    cout &lt;&lt; \"Enter the original asking price: \";\n    cin &gt;&gt; a_price;\n    d_price = 0.913 * a_price;\n\n    // display information on screen with cout\n    cout &lt;&lt; fixed;\n    cout.precision(2);\n    cout.setf(ios_base::showpoint);\n    cout &lt;&lt; \"Make and model: \" &lt;&lt; automobile &lt;&lt; endl;\n    cout &lt;&lt; \"Year: \" &lt;&lt; year &lt;&lt; endl;\n    cout &lt;&lt; \"Was asking $\" &lt;&lt; a_price &lt;&lt; endl;\n    cout &lt;&lt; \"Now asking $\" &lt;&lt; d_price &lt;&lt; endl;\n\n    // now do exact same things using outFile instead of cout\n    outFile &lt;&lt; fixed;\n    outFile.precision(2);\n    outFile.setf(ios_base::showpoint);\n    outFile &lt;&lt; \"Make and model: \" &lt;&lt; automobile &lt;&lt; endl;\n    outFile &lt;&lt; \"Year: \" &lt;&lt; year &lt;&lt; endl;\n    outFile &lt;&lt; \"Was asking $\" &lt;&lt; a_price &lt;&lt; endl;\n    outFile &lt;&lt; \"Now asking $\" &lt;&lt; d_price &lt;&lt; endl;\n\n    outFile.close(); // done with file\n    return 0;\n}\n\n/*\nSample run of this program:\n    Enter the make and model of automobile: Flitz Perky\n    Enter the model year: 2009\n    Enter the original asking price: 13500\n    Make and model: Flitz Perky\n    Year: 2009\n    Was asking $13500.00\n    Now asking $12325.50\n\nNotice that the close() method doesn\u2019t require a filename.That\u2019s because outFile\nhas already been associated with a particular file.\n\nIf you forget to close a file, the program will close it automatically \nif the program terminates normally.\n\noutFile can not only use &lt;&lt; operator, but it can use the various formatting methods, such as setf() and\nprecision()\n*/\n</code></pre>"},{"location":"#read-from-file","title":"Read from file","text":"<p>You have to declare your own <code>ifstream</code> object, choosing a name for it and associating it with a file</p> <p>Declaration:</p> <pre><code>ifstream inFile; // inFile an ifstream object\nifstream fin; // fin an ifstream object\n</code></pre> <p>Association with file (open() method requires a C-style string as its argument):</p> <pre><code>inFile.open(\"bowling.txt\"); // inFile used to read bowling.txt file\nchar filename[50];\ncin &gt;&gt; filename; // user specifies a name\nfin.open(filename); // fin used to read specified file\n</code></pre> <p>Use created object:</p> <pre><code>double wt;\ninFile &gt;&gt; wt; // read a number from bowling.txt\nchar line[81];\nfin.getline(line, 81); // read a line of text\n</code></pre> <p>Check for nonexisting file (<code>is_open()</code> method)</p> <pre><code>inFile.open(\"bowling.txt\");\nif (!inFile.is_open()){\n    exit(EXIT_FAILURE);\n}\n</code></pre> <p>For program below - write <code>datsumafile.txt</code>, that should be local, or <code>.\\programs\\datsumafile.txt</code> if compiled in <code>$PATH$</code></p> sumafile.cpp - reading double data from file. <pre><code>// sumafile.cpp -- functions with an array argument\n#include &lt;iostream&gt;\n#include &lt;fstream&gt; // file I/O support\n#include &lt;cstdlib&gt; // support for exit()\nconst int SIZE = 60;\nint main()\n{\n    using namespace std;\n    char filename[SIZE];\n    ifstream inFile; // object for handling file input\n\n    cout &lt;&lt; \"Enter name of data file: \";\n    cin.getline(filename, SIZE);\n    inFile.open(filename); // associate inFile with a file\n    if (!inFile.is_open()) // failed to open file\n    {\n        cout &lt;&lt; \"Could not open the file \" &lt;&lt; filename &lt;&lt; endl;\n        cout &lt;&lt; \"Program terminating.\\n\";\n        exit(EXIT_FAILURE);\n    }\n    double value;\n    double sum = 0.0;\n    int count = 0;        // number of items read\n\n    inFile &gt;&gt; value;      // get first value\n    while (inFile.good()) // while input good and not at EOF\n    {\n        ++count;         // one more item read\n        sum += value;    // calculate running total\n        inFile &gt;&gt; value; // get next value\n    }\n    if (inFile.eof())\n        cout &lt;&lt; \"End of file reached.\\n\";\n    else if (inFile.fail())\n        cout &lt;&lt; \"Input terminated by data mismatch.\\n\";\n    else\n        cout &lt;&lt; \"Input terminated for unknown reason.\\n\";\n    if (count == 0)\n        cout &lt;&lt; \"No data processed.\\n\";\n    else\n    {\n        cout &lt;&lt; \"Items read: \" &lt;&lt; count &lt;&lt; endl;\n        cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; endl;\n        cout &lt;&lt; \"Average: \" &lt;&lt; sum / count &lt;&lt; endl;\n    }\n    inFile.close(); // finished with the file\n    return 0;\n}\n\n/*\nHere\u2019s a sample run of the program in Listing 6.16:\n    Enter name of data file: scores.txt\n    End of file reached.\n    Items read: 12\n    Sum: 204.5\n    Average: 17.0417\n*/\n</code></pre> datsumafile.txt - data for program. <pre><code>18 19 18.5 13.5 14\n16 19.5 20 18 12.5 18.5\n17.5\n</code></pre> <pre><code>// standard file-reading loop design\ninFile &gt;&gt; value; // get first value\nwhile (inFile.good()) // while input good and not at EOF\n{\n    // loop body goes here\n    inFile &gt;&gt; value; // get next value\n}\n</code></pre> <p><code>inFile</code>, when placed in a context in which a <code>bool</code> value is expected, evaluates to <code>inFile.good()</code> \u2014 that is, to <code>true</code> or <code>false</code>, thus you can make above code more concise:</p> <pre><code>// abbreviated file-reading loop design\n// omit pre-loop input\nwhile (inFile &gt;&gt; value) // read and test for success\n{\n    // loop body goes here\n    // omit end-of-loop input\n}\n</code></pre>"},{"location":"#chapter-7-cs-programming-modules","title":"Chapter 7: C++\u2019s Programming Modules","text":"List of what you will learn  <pre><code>- Function basics\n- Function prototypes\n- Passing function arguments by value\n- Designing functions to process arrays\n- Using const pointer parameters\n- Designing functions to process text strings\n- Designing functions to process structures\n- Designing functions to process objects of the string class\n- Functions that call themselves (recursion)\n- Pointers to functions\n</code></pre>"},{"location":"#functions","title":"Functions","text":"<p>You can group functions into two categories: those that don\u2019t have return values and those that do.</p> <pre><code>void functionName(parameterList)\n{\n    statement(s)\n    return; // optional\n}\n</code></pre> <p> </p>"},{"location":"#prototyping","title":"Prototyping","text":"<p>Prototype describes the function interface to the compiler.That is, it tells the compiler what type of return value, if any, the function has, and it tells the compiler the number and type of function arguments.</p> <p>A function prototype is a statement, so it must have a terminating semicolon. The simplest way to get a prototype is to copy the function header from the function definition and add a semicolon.</p> protos.cpp - Example of using prototypes and function calls. <pre><code>// protos.cpp -- using prototypes and function calls\n#include &lt;iostream&gt;\nvoid cheers(int);      // prototype: no return value\ndouble cube(double x); // prototype: returns a double\nint main()\n{\n    using namespace std;\n    cheers(5); // function call\n    cout &lt;&lt; \"Give me a number: \";\n    double side;\n    cin &gt;&gt; side;\n    double volume = cube(side); // function call\n    cout &lt;&lt; \"A \" &lt;&lt; side &lt;&lt; \"-foot cube has a volume of \";\n    cout &lt;&lt; volume &lt;&lt; \" cubic feet.\\n\";\n    cheers(cube(2)); // prototype protection at work\n    return 0;\n}\n\nvoid cheers(int n)\n{\n    using namespace std;\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; \"Cheers! \";\n    cout &lt;&lt; endl;\n}\n\ndouble cube(double x)\n{\n    return x * x * x;\n}\n\n/*\nCheers! Cheers! Cheers! Cheers! Cheers!\nGive me a number: 5\nA 5-foot cube has a volume of 125 cubic feet.\nCheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers!\n\nNote that main() calls the type void function cheers() by using the function name\nand arguments followed by a semicolon: cheers(5);.This is an example of a function call\nstatement. \n*/\n</code></pre>  C++ Versus ANSI C Prototyping, ellypsis (...)   ANSI C borrowed prototyping from C++, but the two languages do have some differences. The most important is that ANSI C, to preserve compatibility with classic C, made prototyping optional, whereas C++ makes prototyping mandatory. For example, consider the following function declaration:  <pre><code>void say_hi();\n</code></pre>  In C++, leaving the parentheses empty is the same as using the keyword void within the parentheses. It means the function has no arguments. In ANSI C, leaving the parentheses empty means that you are declining to state what the arguments are. That is, it means you\u2019re forgoing prototyping the argument list. The C++ equivalent for not identifying the argument list is to use an ellipsis:  <pre><code>void say_bye(...); // C++ abdication of responsibility\n</code></pre>  Normally this use of an ellipsis is needed only for interfacing with C functions having a variable number of arguments, such as printf().   <p></p> <p>They greatly reduce the chances of program errors. In particular, prototypes ensure the following:</p> <ul> <li>The compiler correctly handles the function return value.</li> <li>The compiler checks that you use the correct number of function arguments.</li> <li>The compiler checks that you use the correct type of arguments. If you don\u2019t, it converts the arguments to the correct type, if possible.</li> </ul> <p>Prototyping takes place during compile time and is termed <code>static type checking</code>. <code>Static type checking</code>, as you\u2019ve just seen, catches many errors that are much more difficult to catch during runtime.</p>"},{"location":"#passing-function-arguments","title":"Passing function arguments","text":"<p>A variable that\u2019s used to receive passed values is called a <code>formal argument</code> or <code>formal parameter</code>. The value passed to the function is called the <code>actual argument</code> or <code>actual parameter</code>.</p> <p>Variables, including parameters, declared within a function are private to the function. When a function is called, the computer allocates the memory needed for these variables. When the function terminates, the computer frees the memory that was used for those variables.</p> <p>Prototype examples with many arguments:</p> <pre><code>void fifi(float a, float b) // declare each variable separately\nvoid fufu(float a, b) // NOT acceptable\n\nvoid n_chars(char c, int n); // prototype, style 1\nvoid n_chars(char, int); // prototype, style 2\n</code></pre> twoarg.cpp - a function with 2 arguments. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid n_chars(char, int);\n\nint main()\n{\n    int times;\n    char ch;\n    cout &lt;&lt; \"Enter a character: \";\n    cin &gt;&gt; ch;\n    while (ch != 'q') // q to quit\n    {\n        cout &lt;&lt; \"Enter an integer: \";\n        cin &gt;&gt; times;\n        n_chars(ch, times); // function with two arguments\n        cout &lt;&lt; \"\\nEnter another character or press the\"\n                \" q-key to quit: \";\n        cin &gt;&gt; ch;\n    }\n    cout &lt;&lt; \"The value of times is \" &lt;&lt; times &lt;&lt; \".\\n\";\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\nvoid n_chars(char c, int n) // displays c n times\n{\n    while (n-- &gt; 0) // continue until n reaches 0\n        cout &lt;&lt; c;\n}\n\n/*\nEnter a character: W\nEnter an integer: 50\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nEnter another character or press the q-key to quit: a\nEnter an integer: 20\naaaaaaaaaaaaaaaaaaaa\nEnter another character or press the q-key to quit: q\nThe value of times is 20.\nBye\n*/\n</code></pre> lotto.cpp - calculate probability of winning. <pre><code>#include &lt;iostream&gt;\n\n// Note: some implementations require double instead of long double\nlong double probability(unsigned numbers, unsigned picks);\nint main()\n{\n    using namespace std;\n    double total, choices;\n    cout &lt;&lt; \"Enter the total number of choices on the game card and\\n\"\n            \"the number of picks allowed:\\n\";\n    while ((cin &gt;&gt; total &gt;&gt; choices) &amp;&amp; choices &lt;= total)\n    {\n        cout &lt;&lt; \"You have one chance in \";\n        cout &lt;&lt; probability(total, choices); // compute the odds\n        cout &lt;&lt; \" of winning.\\n\";\n        cout &lt;&lt; \"Next two numbers (q to quit): \";\n    }\n    cout &lt;&lt; \"bye\\n\";\n    return 0;\n}\n\n// the following function calculates the probability of picking picks\n// numbers correctly from numbers choices\nlong double probability(unsigned numbers, unsigned picks)\n{\n    long double result = 1.0; // here come some local variables\n    long double n;\n    unsigned p;\n    for (n = numbers, p = picks; p &gt; 0; n--, p--)\n        result = result * n / p;\n    return result;\n}\n\n/*\nEnter the total number of choices on the game card and\nthe number of picks allowed:\n49 6\nYou have one chance in 1.39838e+007 of winning.\nNext two numbers (q to quit): 51 6\nYou have one chance in 1.80095e+007 of winning.\nNext two numbers (q to quit): 38 6\nYou have one chance in 2.76068e+006 of winning.\nNext two numbers (q to quit): q\nbye\n*/\n</code></pre>"},{"location":"#functions-and-arrays","title":"Functions and Arrays","text":"<pre><code>int sum_arr(int arr[], int n) // arr = array name, n = size\n</code></pre> <p><code>arr</code> is not really an array; it\u2019s a pointer! The good news is that you can write the rest of <code>the</code> function just as if arr were an array.</p> <p>The design decision to use array addresses as arguments saves the time and memory needed to copy an entire array.</p> arrfun1.cpp - functions with an array argument. <pre><code>// arrfun1.cpp -- functions with an array argument\n#include &lt;iostream&gt;\nconst int ArSize = 8;\nint sum_arr(int arr[], int n); // prototype\nint main()\n{\n    using namespace std;\n    int cookies[ArSize] = {1, 2, 4, 8, 16, 32, 64, 128};\n    // some systems require preceding int with static to\n    // enable array initialization\n\n    int sum = sum_arr(cookies, ArSize);\n    cout &lt;&lt; \"Total cookies eaten: \" &lt;&lt; sum &lt;&lt; \"\\n\";\n    return 0;\n}\n\n// return the sum of an integer array\nint sum_arr(int arr[], int n)\n{\n    int total = 0;\n    for (int i = 0; i &lt; n; i++)\n        total = total + arr[i];\n    return total;\n}\n\n/*\nTotal cookies eaten: 255\n*/\n</code></pre> arrfun2.cpp - functions with an array argument. <pre><code>// arrfun2.cpp -- functions with an array argument\n#include &lt;iostream&gt;\nconst int ArSize = 8;\nint sum_arr(int arr[], int n);\n// use std:: instead of using directive\n\nint main()\n{\n    int cookies[ArSize] = {1, 2, 4, 8, 16, 32, 64, 128};\n    // some systems require preceding int with static to\n    // enable array initialization\n    std::cout &lt;&lt; cookies &lt;&lt; \" = array address, \";\n    // some systems require a type cast: unsigned (cookies)\n    std::cout &lt;&lt; sizeof cookies &lt;&lt; \" = sizeof cookies\\n\";\n    int sum = sum_arr(cookies, ArSize);\n    std::cout &lt;&lt; \"Total cookies eaten: \" &lt;&lt; sum &lt;&lt; std::endl;\n    sum = sum_arr(cookies, 3); // a lie\n    std::cout &lt;&lt; \"First three eaters ate \" &lt;&lt; sum &lt;&lt; \" cookies.\\n\";\n    sum = sum_arr(cookies + 4, 4); // another lie\n    std::cout &lt;&lt; \"Last four eaters ate \" &lt;&lt; sum &lt;&lt; \" cookies.\\n\";\n    return 0;\n}\n\n// return the sum of an integer array\nint sum_arr(int arr[], int n)\n{\n    int total = 0;\n    std::cout &lt;&lt; arr &lt;&lt; \" = arr, \";\n    // some systems require a type cast: unsigned (arr)\n    std::cout &lt;&lt; sizeof arr &lt;&lt; \" = sizeof arr\\n\";\n    for (int i = 0; i &lt; n; i++)\n        total = total + arr[i];\n    return total;\n}\n\n/*\n003EF9FC = array address, 32 = sizeof cookies\n003EF9FC = arr, 4 = sizeof arr\nTotal cookies eaten: 255\n003EF9FC = arr, 4 = sizeof arr\nFirst three eaters ate 7 cookies.\n003EFA0C = arr, 4 = sizeof arr\nLast four eaters ate 240 cookies.\n*/\n</code></pre> arrfun3.cpp - functions with an array argument. <pre><code>// arrfun3.cpp -- array functions and const\n#include &lt;iostream&gt;\nconst int Max = 5;\n\n// function prototypes\nint fill_array(double ar[], int limit);\nvoid show_array(const double ar[], int n); // don't change data\nvoid revalue(double r, double ar[], int n);\n\nint main()\n{\n    using namespace std;\n    double properties[Max];\n    int size = fill_array(properties, Max);\n    show_array(properties, size);\n    if (size &gt; 0)\n    {\n        cout &lt;&lt; \"Enter revaluation factor: \";\n        double factor;\n        while (!(cin &gt;&gt; factor)) // bad input\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                continue;\n            cout &lt;&lt; \"Bad input; Please enter a number: \";\n        }\n        revalue(factor, properties, size);\n        show_array(properties, size);\n    }\n    cout &lt;&lt; \"Done.\\n\";\n    cin.get();\n    cin.get();\n    return 0;\n}\n\nint fill_array(double ar[], int limit)\n{\n    using namespace std;\n    double temp;\n    int i;\n    for (i = 0; i &lt; limit; i++)\n    {\n        cout &lt;&lt; \"Enter value #\" &lt;&lt; (i + 1) &lt;&lt; \": \";\n        cin &gt;&gt; temp;\n        if (!cin) // bad input\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                continue;\n            cout &lt;&lt; \"Bad input; input process terminated.\\n\";\n            break;\n        }\n        else if (temp &lt; 0) // signal to terminate\n            break;\n        ar[i] = temp;\n    }\n    return i;\n}\n// the following function can use, but not alter,\n// the array whose address is ar\nvoid show_array(const double ar[], int n)\n{\n    using namespace std;\n    for (int i = 0; i &lt; n; i++)\n    {\n        cout &lt;&lt; \"Property #\" &lt;&lt; (i + 1) &lt;&lt; \": $\";\n        cout &lt;&lt; ar[i] &lt;&lt; endl;\n    }\n}\n\n// multiplies each element of ar[] by r\nvoid revalue(double r, double ar[], int n)\n{\n    for (int i = 0; i &lt; n; i++)\n        ar[i] *= r;\n}\n\n/*\nEnter value #1: 100000\nEnter value #2: 80000\nEnter value #3: 222000\nEnter value #4: 240000\nEnter value #5: 118000\nProperty #1: $100000\nProperty #2: $80000\nProperty #3: $222000\nProperty #4: $240000\nProperty #5: $118000\nEnter revaluation factor: 0.8\nProperty #1: $80000\nProperty #2: $64000\nProperty #3: $177600\nProperty #4: $192000\nProperty #5: $94400\nDone.\nEnter value #1: 200000\nEnter value #2: 84000\nEnter value #3: 160000\nEnter value #4: -2\nProperty #1: $200000\nProperty #2: $84000\nProperty #3: $160000\nEnter reevaluation factor: 1.20\nProperty #1: $240000\nProperty #2: $100800\nProperty #3: $192000\nDone.\n*/\n</code></pre> arrfun4.cpp - functions with an array range. <pre><code>// arrfun4.cpp -- functions with an array range\n#include &lt;iostream&gt;\nconst int ArSize = 8;\nint sum_arr(const int *begin, const int *end);\n\nint main()\n{\n    using namespace std;\n    int cookies[ArSize] = {1, 2, 4, 8, 16, 32, 64, 128};\n    // some systems require preceding int with static to\n    // enable array initialization\n    int sum = sum_arr(cookies, cookies + ArSize);\n    cout &lt;&lt; \"Total cookies eaten: \" &lt;&lt; sum &lt;&lt; endl;\n    sum = sum_arr(cookies, cookies + 3); // first 3 elements\n    cout &lt;&lt; \"First three eaters ate \" &lt;&lt; sum &lt;&lt; \" cookies.\\n\";\n    sum = sum_arr(cookies + 4, cookies + 8); // last 4 elements\n    cout &lt;&lt; \"Last four eaters ate \" &lt;&lt; sum &lt;&lt; \" cookies.\\n\";\n    return 0;\n}\n\n// return the sum of an integer array\nint sum_arr(const int *begin, const int *end)\n{\n    const int *pt;\n    int total = 0;\n    for (pt = begin; pt != end; pt++)\n        total = total + *pt;\n    return total;\n}\n\n/*\nTotal cookies eaten: 255\nFirst three eaters ate 7 cookies.\nLast four eaters ate 240 cookies.\n*/\n</code></pre> <p>C++ interprets an array name as the address of its first element:</p> <pre><code>cookies == &amp;cookies[0] // array name is address of first element\n</code></pre> <p>This suggests that the correct function header should be this:</p> <pre><code>int sum_arr(int * arr, int n) // arr = array name, n = size\n\narr[i] == *(ar + i) // values in two notations\n&amp;arr[i] == ar + i // addresses in two notations\n\n// You can also lie about where the array starts when calling:\nsum = sum_arr(cookies + 4, 4);\nsum = sum_arr(cookies, cookies + 3); // first 3 elements - array ranges\n\n// Protecting array with const to keep a function from accidentally altering the contents of\nan array argument,\nvoid show_array(const double ar[], int n);\n</code></pre> <p>Remember that adding one to a pointer, including an array name, actually adds a value equal to the size, in bytes, of the type to which the pointer points</p> <p> </p>"},{"location":"#pointers-and-const","title":"Pointers and <code>const</code>","text":"<p>Pointers of variables can't be addressed to const values.</p> <pre><code>int age = 39;\nconst int * pt = &amp;age;\n\n*pt += 1; // INVALID because pt points to a const int\ncin &gt;&gt; *pt; // INVALID for the same reason\n\n*pt = 20; // INVALID because pt points to a const int\nage = 20; // VALID because age is not declared to be const\n\nconst float g_earth = 9.80;\nconst float * pe = &amp;g_earth; // VALID\n\nconst float g_moon = 1.63;\nfloat * pm = &amp;g_moon; // INVALID\n</code></pre>  Using const When You Can       There are two strong reasons to declare pointer arguments as pointers to constant data:  - It protects you against programming errors that inadvertently alter data. - Using `const` allows a function to process both `const` and non-`const` actual arguments, whereas a function that omits `const` in the prototype can accept only non-`const` data.   <p></p> <p> </p>"},{"location":"#functions-and-two-dimensional-arrays","title":"Functions and Two-Dimensional Arrays","text":"<pre><code>int data[3][4] = {{1,2,3,4}, {9,8,7,6}, {2,4,6,8}};\nint total = sum(data, 3);\n\n// data is pointer-to-array-of-four-int,\n// so an appropriate prototype would be this:\nint sum(int (*ar2)[4], int size);\n\n// The simplest way is to use brackets twice, as in ar2[r][c].\ntotal += ar2[r][c];\n// But it is possible, if ungainly, to use the * operator twice\nar2[r][c] == *(*(ar2 + r) + c) // same thing\n\n// To understand this, you can work out the\n// meaning of the subexpressions from the inside out:\nar2 // pointer to first row of an array of 4 int\nar2 + r // pointer to row r (an array of 4 int)\n*(ar2 + r) // row r (an array of 4 int, hence the name of an array,\n// thus a pointer to the first int in the row, i.e., ar2[r]\n*(ar2 +r) + c // pointer int number c in row r, i.e., ar2[r] + c\n*(*(ar2 + r) + c // value of int number c in row r, i.e. ar2[r][c]\n</code></pre>"},{"location":"#functions-and-c-style-strings","title":"Functions and C-Style Strings","text":"<p>You have three choices for representing a string:</p> <ul> <li>An array of char</li> <li>A quoted string constant (also called a string literal)</li> <li>A pointer-to-char set to the address of a string</li> </ul> <pre><code>char ghost[15] = \"galloping\";\nchar * str = \"galumphing\";\nint n1 = strlen(ghost); // ghost is &amp;ghost[0]\nint n2 = strlen(str); // pointer to char\nint n3 = strlen(\"gamboling\"); // address of string\n</code></pre> strgfun.cpp - functions with a string argument. <pre><code>#include &lt;iostream&gt;\nunsigned int c_in_str(const char *str, char ch);\nint main()\n{\n    using namespace std;\n    char mmm[15] = \"minimum\"; // string in an array\n    // some systems require preceding char with static to\n    // enable array initialization\n    char *wail = \"ululate\"; // wail points to string\n    unsigned int ms = c_in_str(mmm, 'm');\n    unsigned int us = c_in_str(wail, 'u');\n    cout &lt;&lt; ms &lt;&lt; \" m characters in \" &lt;&lt; mmm &lt;&lt; endl;\n    cout &lt;&lt; us &lt;&lt; \" u characters in \" &lt;&lt; wail &lt;&lt; endl;\n    return 0;\n}\n\n// this function counts the number of ch characters\n// in the string str\nunsigned int c_in_str(const char *str, char ch)\n{\n    unsigned int count = 0;\n    while (*str) // quit when *str is '\\0'\n    {\n        if (*str == ch)\n            count++;\n        str++; // move pointer to next char\n    }\n    return count;\n}\n\n/*\n3 m characters in minimum\n2 u characters in ululate\n*/\n</code></pre> strgback.cpp - a function that returns a pointer to char. <pre><code>#include &lt;iostream&gt;\nchar *buildstr(char c, int n); // prototype\nint main()\n{\n    using namespace std;\n    int times;\n    char ch;\n    cout &lt;&lt; \"Enter a character: \";\n    cin &gt;&gt; ch;\n    cout &lt;&lt; \"Enter an integer: \";\n    cin &gt;&gt; times;\n    char *ps = buildstr(ch, times);\n    cout &lt;&lt; ps &lt;&lt; endl;\n    delete[] ps;            // free memory\n    ps = buildstr('+', 20); // reuse pointer\n    cout &lt;&lt; ps &lt;&lt; \"-DONE-\" &lt;&lt; ps &lt;&lt; endl;\n    delete[] ps; // free memory\n    return 0;\n}\n\n// builds string made of n c characters\nchar *buildstr(char c, int n)\n{\n    char *pstr = new char[n + 1];\n    pstr[n] = '\\0'; // terminate string\n    while (n-- &gt; 0)\n        pstr[n] = c; // fill rest of string\n    return pstr;\n}\n\n/*\nEnter a character: V\nEnter an integer: 46\nVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n++++++++++++++++++++-DONE-++++++++++++++++++++\n*/\n</code></pre>"},{"location":"#functions-and-structures","title":"Functions and Structures","text":"<p>Defining the structure is simple:</p> <pre><code>struct travel_time\n{\n    int hours;\n    int mins;\n};\n\n// Next, consider the prototype for a sum() function that\n// returns the sum of two such structures\ntravel_time sum(travel_time t1, travel_time t2);\n</code></pre> travel.cpp - using structures with functions. <pre><code>#include &lt;iostream&gt;\n\nstruct travel_time\n{\n    int hours;\n    int mins;\n};\nconst int Mins_per_hr = 60;\n\ntravel_time sum(travel_time t1, travel_time t2);\nvoid show_time(travel_time t);\n\nint main()\n{\n    using namespace std;\n    travel_time day1 = {5, 45}; // 5 hrs, 45 min\n    travel_time day2 = {4, 55}; // 4 hrs, 55 min\n    travel_time trip = sum(day1, day2);\n    cout &lt;&lt; \"Two-day total: \";\n    show_time(trip);\n    travel_time day3 = {4, 32};\n    cout &lt;&lt; \"Three-day total: \";\n    show_time(sum(trip, day3));\n    return 0;\n}\n\ntravel_time sum(travel_time t1, travel_time t2)\n{\n    travel_time total;\n    total.mins = (t1.mins + t2.mins) % Mins_per_hr;\n    total.hours = t1.hours + t2.hours +\n                  (t1.mins + t2.mins) / Mins_per_hr;\n    return total;\n}\n\nvoid show_time(travel_time t)\n{\n    using namespace std;\n    cout &lt;&lt; t.hours &lt;&lt; \" hours, \"\n         &lt;&lt; t.mins &lt;&lt; \" minutes\\n\";\n}\n\n/*\nTwo-day total: 10 hours, 40 minutes\nThree-day total: 15 hours, 12 minutes\n*/\n</code></pre> strctfun.cpp - functions with a structure argument. <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n// structure declarations\nstruct polar\n{\n    double distance; // distance from origin\n    double angle;    // direction from origin\n};\n\nstruct rect\n{\n    double x; // horizontal distance from origin\n    double y; // vertical distance from origin\n};\n\n// prototypes\npolar rect_to_polar(rect xypos);\nvoid show_polar(polar dapos);\n\nint main()\n{\n    using namespace std;\n    rect rplace;\n    polar pplace;\n    cout &lt;&lt; \"Enter the x and y values: \";\n    while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) // slick use of cin\n    {\n        pplace = rect_to_polar(rplace);\n        show_polar(pplace);\n        cout &lt;&lt; \"Next two numbers (q to quit): \";\n    }\n    cout &lt;&lt; \"Done.\\n\";\n    return 0;\n}\n\n// convert rectangular to polar coordinates\npolar rect_to_polar(rect xypos)\n{\n    using namespace std;\n    polar answer;\n    answer.distance =\n        sqrt(xypos.x * xypos.x + xypos.y * xypos.y);\n    answer.angle = atan2(xypos.y, xypos.x);\n    return answer; // returns a polar structure\n}\n\n// show polar coordinates, converting angle to degrees\nvoid show_polar(polar dapos)\n{\n    using namespace std;\n    const double Rad_to_deg = 57.29577951;\n    cout &lt;&lt; \"distance = \" &lt;&lt; dapos.distance;\n    cout &lt;&lt; \", angle = \" &lt;&lt; dapos.angle * Rad_to_deg;\n    cout &lt;&lt; \" degrees\\n\";\n}\n\n/*\nEnter the x and y values: 30 40\ndistance = 50, angle = 53.1301 degrees\nNext two numbers (q to quit): -100 100\ndistance = 141.421, angle = 135 degrees\nNext two numbers (q to quit): q\n*/\n</code></pre>"},{"location":"#passing-structure-addresses","title":"Passing Structure Addresses","text":"<p>Suppose you want to save time and space by passing the address of a structure instead of passing the entire structure.</p> <p>You need to make three changes:</p> <ul> <li>When calling the function, pass it the address of the structure (<code>&amp;pplace</code>) rather than the structure itself (<code>pplace</code>).</li> <li>Declare the formal parameter to be a pointer-to-polar\u2014that is, type polar <code>*</code>. Because the function shouldn\u2019t modify the structure, use the <code>const</code> modifier.</li> <li>Because the formal parameter is a pointer instead of a structure, use the indirect membership operator (<code>-&gt;</code>) rather than the membership operator (dot).</li> </ul> <pre><code>void show_polar (const polar * pda)\n{\n    cout &lt;&lt; \"distance = \" &lt;&lt; pda-&gt;distance;\n}\n</code></pre> strctptr.cpp - functions with a structure argument. <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\n// structure templates\nstruct polar\n{\n    double distance; // distance from origin\n    double angle;    // direction from origin\n};\n\nstruct rect\n{\n    double x; // horizontal distance from origin\n    double y; // vertical distance from origin\n};\n\n// prototypes\nvoid rect_to_polar(const rect *pxy, polar *pda);\nvoid show_polar(const polar *pda);\n\nint main()\n{\n    using namespace std;\n    rect rplace;\n    polar pplace;\n    cout &lt;&lt; \"Enter the x and y values: \";\n    while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)\n    {\n        rect_to_polar(&amp;rplace, &amp;pplace); // pass addresses\n        show_polar(&amp;pplace);             // pass address\n        cout &lt;&lt; \"Next two numbers (q to quit): \";\n    }\n    cout &lt;&lt; \"Done.\\n\";\n    return 0;\n}\n\n// show polar coordinates, converting angle to degrees\nvoid show_polar(const polar *pda)\n{\n    using namespace std;\n    const double Rad_to_deg = 57.29577951;\n    cout &lt;&lt; \"distance = \" &lt;&lt; pda-&gt;distance;\n    cout &lt;&lt; \", angle = \" &lt;&lt; pda-&gt;angle * Rad_to_deg;\n    cout &lt;&lt; \" degrees\\n\";\n}\n\n// convert rectangular to polar coordinates\nvoid rect_to_polar(const rect *pxy, polar *pda)\n{\n    using namespace std;\n    pda-&gt;distance =\n        sqrt(pxy-&gt;x * pxy-&gt;x + pxy-&gt;y * pxy-&gt;y);\n    pda-&gt;angle = atan2(pxy-&gt;y, pxy-&gt;x);\n}\n</code></pre>"},{"location":"#functions-and-string-class-objects","title":"Functions and string Class Objects","text":"<p><code>string</code> class object is more closely related to a structure than to an array.</p> <ul> <li>you can assign a structure to another structure and an object to another object</li> <li>You can pass a structure as a complete entity to a function, and you can pass an object as a complete entity.</li> <li>you can declare a one-dimensional array of <code>string</code> objects instead of a two-dimensional array of <code>char</code>.</li> </ul> topfive.cpp - handling an array of string objects. <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nconst int SIZE = 5;\nvoid display(const string sa[], int n);\n\nint main()\n{\n    string list[SIZE]; // an array holding 5 string object\n    cout &lt;&lt; \"Enter your \" &lt;&lt; SIZE &lt;&lt; \" favorite astronomical sights:\\n\";\n    for (int i = 0; i &lt; SIZE; i++)\n    {\n        cout &lt;&lt; i + 1 &lt;&lt; \": \";\n        getline(cin, list[i]);\n    }\n    cout &lt;&lt; \"Your list:\\n\";\n    display(list, SIZE);\n    return 0;\n}\n\nvoid display(const string sa[], int n)\n{\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; i + 1 &lt;&lt; \": \" &lt;&lt; sa[i] &lt;&lt; endl;\n}\n\n/*\nEnter your 5 favorite astronomical sights:\n1: Orion Nebula\n2: M13\n3: Saturn\n4: Jupiter\n5: Moon\nYour list:\n1: Orion Nebula\n2: M13\n3: Saturn\n4: Jupiter\n5: Moon\n*/\n</code></pre>"},{"location":"#functions-and-array-objects","title":"Functions and array Objects","text":"<p>Declared <code>array</code> object</p> <pre><code>std::array&lt;double, 4&gt; expenses;\n\nshow(expenses); // function display the contents\nshow(&amp;expenses); // if we want a function that modifies object\n\n// Prototypes\nvoid show(std::array&lt;double, 4&gt; da); // da an object\nvoid fill(std::array&lt;double, 4&gt; * pa); // pa a pointer to an object\n</code></pre> arrobj.cpp - functions with a structure argument. <pre><code>// arrobj.cpp -- functions with array objects (C++11)\n#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;string&gt;\n\n// constant data\nconst int Seasons = 4;\nconst std::array&lt;std::string, Seasons&gt; Snames =\n    {\"Spring\", \"Summer\", \"Fall\", \"Winter\"};\n\n// function to modify array object\nvoid fill(std::array&lt;double, Seasons&gt; *pa);\n// function that uses array object without modifying it\nvoid show(std::array&lt;double, Seasons&gt; da);\n\nint main()\n{\n    std::array&lt;double, Seasons&gt; expenses;\n    fill(&amp;expenses);\n    show(expenses);\n    return 0;\n}\n\nvoid fill(std::array&lt;double, Seasons&gt; *pa)\n{\n    using namespace std;\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; \"Enter \" &lt;&lt; Snames[i] &lt;&lt; \" expenses: \";\n        cin &gt;&gt; (*pa)[i];\n    }\n}\n\nvoid show(std::array&lt;double, Seasons&gt; da)\n{\n    using namespace std;\n    double total = 0.0;\n    cout &lt;&lt; \"\\nEXPENSES\\n\";\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; Snames[i] &lt;&lt; \": $\" &lt;&lt; da[i] &lt;&lt; endl;\n        total += da[i];\n    }\n    cout &lt;&lt; \"Total Expenses: $\" &lt;&lt; total &lt;&lt; endl;\n}\n\n/*\nEnter Spring expenses: 212\nEnter Summer expenses: 256\nEnter Fall expenses: 208\nEnter Winter expenses: 244\n\nEXPENSES\nSpring: $212\nSummer: $256\nFall: $208\nWinter: $244\nTotal: $920\n*/\n</code></pre>"},{"location":"#recursion","title":"Recursion","text":"<p>C++ function can <code>call</code> itself. This ability is termed recursion</p> <p>Recursive function example</p> <pre><code>// Single Recursive Call  \nvoid recurs(argumentlist)\n{\n    statements1\n    if (test)\n        recurs(arguments)\n    statements2\n}\n</code></pre> recur.cpp - using recursion (single). <pre><code>#include &lt;iostream&gt;\nvoid countdown(int n);\n\nint main()\n{\n    countdown(4); // call the recursive function\n    return 0;\n}\n\nvoid countdown(int n)\n{\n    using namespace std;\n    cout &lt;&lt; \"Counting down ... \" &lt;&lt; n &lt;&lt; endl;\n    if (n &gt; 0)\n        countdown(n - 1); // function calls itself\n    cout &lt;&lt; n &lt;&lt; \": Kaboom!\\n\";\n}\n\n/*\nCounting down ... 4 \u2039level 1; adding levels of recursion\nCounting down ... 3 \u2039level 2\nCounting down ... 2 \u2039level 3\nCounting down ... 1 \u2039level 4\nCounting down ... 0 \u2039level 5; final recursive call\n0: Kaboom! \u2039level 5; beginning to back out\n1: Kaboom! \u2039level 4\n2: Kaboom! \u2039level 3\n3: Kaboom! \u2039level 2\n4: Kaboom! \u2039level 1\n\n\ncout &lt;&lt; \"Counting down ... \" &lt;&lt; n &lt;&lt; \" (n at \" &lt;&lt; &amp;n &lt;&lt; \")\" &lt;&lt; endl;\n...\ncout &lt;&lt; n &lt;&lt; \": Kaboom!\"; &lt;&lt; \" (n at \" &lt;&lt; &amp;n &lt;&lt; \")\" &lt;&lt; endl;\n\nDoing so produces output like the following:\nCounting down ... 4 (n at 0012FE0C)\nCounting down ... 3 (n at 0012FD34)\nCounting down ... 2 (n at 0012FC5C)\nCounting down ... 1 (n at 0012FB84)\nCounting down ... 0 (n at 0012FAAC)\n0: Kaboom! (n at 0012FAAC)\n1: Kaboom! (n at 0012FB84)\n2: Kaboom! (n at 0012FC5C)\n3: Kaboom! (n at 0012FD34)\n4: Kaboom! (n at 0012FE0C)\n*/\n</code></pre> <p>This recursive approach below is sometimes called the <code>divide-and-conquer</code> strategy.</p> ruler.cpp - using recursion to subdivide a ruler. <pre><code>#include &lt;iostream&gt;\nconst int Len = 66;\nconst int Divs = 6;\nvoid subdivide(char ar[], int low, int high, int level);\n\nint main()\n{\n    char ruler[Len];\n    int i;\n    for (i = 1; i &lt; Len - 2; i++)\n        ruler[i] = ' ';\n    ruler[Len - 1] = '\\0';\n    int max = Len - 2;\n    int min = 0;\n    ruler[min] = ruler[max] = '|';\n    std::cout &lt;&lt; ruler &lt;&lt; std::endl;\n    for (i = 1; i &lt;= Divs; i++)\n    {\n        subdivide(ruler, min, max, i);\n        std::cout &lt;&lt; ruler &lt;&lt; std::endl;\n        for (int j = 1; j &lt; Len - 2; j++)\n            ruler[j] = ' '; // reset to blank ruler\n    }\n    return 0;\n}\n\nvoid subdivide(char ar[], int low, int high, int level)\n{\n    if (level == 0)\n        return;\n    int mid = (high + low) / 2;\n    ar[mid] = '|';\n    subdivide(ar, low, mid, level - 1);\n    subdivide(ar, mid, high, level - 1);\n}\n\n/*\n|                                                               |\n|                               |                               |\n|               |               |               |               |\n|       |       |       |       |       |       |       |       |\n|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n*/\n</code></pre>"},{"location":"#pointers-to-functions","title":"Pointers to Functions","text":"<p>it\u2019s possible to write a function that takes the address of another function as an argument. That enables the first function to find the second function and run it.</p> <p>You need to be able to do the following:</p> <ul> <li>Obtain the address of a function.</li> <li>Declare a pointer to a function.</li> <li>Use a pointer to a function to invoke the function.</li> </ul>"},{"location":"#obtaining-the-address-of-a-function","title":"Obtaining the address of a function","text":"<p>It is simple. You just use the function name without trailing parentheses</p> <pre><code>process(think); // passes address of think() to process()\nthought(think()); // passes return value of think() to thought()\n</code></pre>"},{"location":"#declaring-a-pointer-to-a-function","title":"Declaring a Pointer to a Function","text":"<p>Pointer to a function has to specify to what type of function the pointer point</p> <pre><code>double pam(int); // prototype of function to use\ndouble (*pf)(int); // pf points to a function that takes\n// one int argument and that\n// returns type double\n</code></pre>  Tip   In general, to declare a pointer to a particular kind of function, you can first write a prototype for a regular function of the desired kind and then replace the function name with an expression in the form `(*pf)`. In this case, `pf` is a pointer to a function of that type.  <p></p> <pre><code>double (*pf)(int); // pf points to a function that returns double\ndouble *pf(int); // pf() a function that returns a pointer-to-double\n\ndouble pam(int);\ndouble (*pf)(int);\npf = pam; // pf now points to the pam() function\n\ndouble ned(double);\nint ted(int);\ndouble (*pf)(int);\npf = ned; // invalid -- mismatched signature\npf = ted; // invalid -- mismatched return types\n\n// prototype:\nvoid estimate(int lines, double (*pf)(int));\n\nestimate(50, pam); // function call telling estimate() to use pam()\n\n// Using a Pointer to Invoke a Function\ndouble pam(int);\ndouble (*pf)(int);\npf = pam; // pf now points to the pam() function\ndouble x = pam(4); // call pam() using the function name\ndouble y = (*pf)(5); // call pam() using the pointer pf\n\ndouble y = pf(5); // also call pam() using the pointer pf\n</code></pre> fun_ptr.cpp - pointers to functions. <pre><code>#include &lt;iostream&gt;\n\ndouble betsy(int);\ndouble pam(int);\n\n// second argument is pointer to a type double function that\n// takes a type int argument\nvoid estimate(int lines, double (*pf)(int));\n\nint main()\n{\n    using namespace std;\n    int code;\n    cout &lt;&lt; \"How many lines of code do you need? \";\n    cin &gt;&gt; code;\n    cout &lt;&lt; \"Here's Betsy's estimate:\\n\";\n    estimate(code, betsy);\n    cout &lt;&lt; \"Here's Pam's estimate:\\n\";\n    estimate(code, pam);\n    return 0;\n}\n\ndouble betsy(int lns)\n{\n    return 0.05 * lns;\n}\n\ndouble pam(int lns)\n{\n    return 0.03 * lns + 0.0004 * lns * lns;\n}\n\nvoid estimate(int lines, double (*pf)(int))\n{\n    using namespace std;\n    cout &lt;&lt; lines &lt;&lt; \" lines will take \";\n    cout &lt;&lt; (*pf)(lines) &lt;&lt; \" hour(s)\\n\";\n}\n\n/*\nHow many lines of code do you need? 30\nHere's Betsy's estimate:\n30 lines will take 1.5 hour(s)\nHere's Pam's estimate:\n30 lines will take 1.26 hour(s)\n*/\n</code></pre> <pre><code>const double * f1(const double ar[], int n);\nconst double * f2(const double [], int);\nconst double * f3(const double *, int);\n</code></pre> <p>The signatures might look different, but they are the same.</p> <pre><code>const double * (*p1)(const double *, int);\n//This can be combined with initialization:\nconst double * (*p1)(const double *, int) = f1;\nauto p2 = f2; // C++11 automatic type deduction\n\n*pd[3] // an array of 3 pointers\n(*pd)[3] // a pointer to an array of 3 elements\n\n**&amp;pa == *pa == pa[0]\n</code></pre> arfupt.cpp - an array of function pointers. <pre><code>#include &lt;iostream&gt;\n\n// various notations, same signatures\nconst double *f1(const double ar[], int n);\nconst double *f2(const double[], int);\nconst double *f3(const double *, int);\n\nint main()\n{\n    using namespace std;\n    double av[3] = {1112.3, 1542.6, 2227.9};\n\n    // pointer to a function\n    const double *(*p1)(const double *, int) = f1;\n    auto p2 = f2; // C++11 automatic type deduction\n\n    // pre-C++11 can use the following code instead\n    // const double *(*p2)(const double *, int) = f2;\n    cout &lt;&lt; \"Using pointers to functions:\\n\";\n    cout &lt;&lt; \" Address Value\\n\";\n    cout &lt;&lt; (*p1)(av, 3) &lt;&lt; \": \" &lt;&lt; *(*p1)(av, 3) &lt;&lt; endl;\n    cout &lt;&lt; p2(av, 3) &lt;&lt; \": \" &lt;&lt; *p2(av, 3) &lt;&lt; endl;\n\n    // pa an array of pointers\n    // auto doesn't work with list initialization\n    const double *(*pa[3])(const double *, int) = {f1, f2, f3};\n    // but it does work for initializing to a single value\n    // pb a pointer to first element of pa\n    auto pb = pa;\n    // pre-C++11 can use the following code instead\n    // const double *(**pb)(const double *, int) = pa;\n    cout &lt;&lt; \"\\nUsing an array of pointers to functions:\\n\";\n    cout &lt;&lt; \" Address Value\\n\";\n    for (int i = 0; i &lt; 3; i++)\n        cout &lt;&lt; pa[i](av, 3) &lt;&lt; \": \" &lt;&lt; *pa[i](av, 3) &lt;&lt; endl;\n    cout &lt;&lt; \"\\nUsing a pointer to a pointer to a function:\\n\";\n    cout &lt;&lt; \" Address Value\\n\";\n    for (int i = 0; i &lt; 3; i++)\n        cout &lt;&lt; pb[i](av, 3) &lt;&lt; \": \" &lt;&lt; *pb[i](av, 3) &lt;&lt; endl;\n\n    // what about a pointer to an array of function pointers\n    cout &lt;&lt; \"\\nUsing pointers to an array of pointers:\\n\";\n    cout &lt;&lt; \" Address Value\\n\";\n    // easy way to declare pc\n    auto pc = &amp;pa;\n    // pre-C++11 can use the following code instead\n    // const double *(*(*pc)[3])(const double *, int) = &amp;pa;\n    cout &lt;&lt; (*pc)[0](av, 3) &lt;&lt; \": \" &lt;&lt; *(*pc)[0](av, 3) &lt;&lt; endl;\n    // hard way to declare pd\n    const double *(*(*pd)[3])(const double *, int) = &amp;pa;\n    // store return value in pdb\n    const double *pdb = (*pd)[1](av, 3);\n    cout &lt;&lt; pdb &lt;&lt; \": \" &lt;&lt; *pdb &lt;&lt; endl;\n    // alternative notation\n    cout &lt;&lt; (*(*pd)[2])(av, 3) &lt;&lt; \": \" &lt;&lt; *(*(*pd)[2])(av, 3) &lt;&lt; endl;\n    // cin.get();\n    return 0;\n}\n\n// some rather dull functions\nconst double *f1(const double *ar, int n)\n{\n    return ar;\n}\n\nconst double *f2(const double ar[], int n)\n{\n    return ar + 1;\n}\n\nconst double *f3(const double ar[], int n)\n{\n    return ar + 2;\n}\n\n/*\nUsing pointers to functions:\nAddress Value\n002AF9E0: 1112.3\n002AF9E8: 1542.6\n\nUsing an array of pointers to functions:\nAddress Value\n002AF9E0: 1112.3\n002AF9E8: 1542.6\n002AF9F0: 2227.9\n\nUsing a pointer to a pointer to a function:\nAddress Value\n002AF9E0: 1112.3\n002AF9E8: 1542.6\n002AF9F0: 2227.9\n\nUsing pointers to an array of pointers:\nAddress Value\n002AF9E0: 1112.3\n002AF9E8: 1542.6\n002AF9F0: 2227.9\n*/\n</code></pre>  Appreciating auto      One of the goals of C++11 is to make C++ easier to use, letting the programmer concentrate more on design and less on details. Listing 7.19 surely illustrates this point:  <pre><code>auto pc = &amp;pa; // C++11 automatic type deduction\nconst double *(*(*pd)[3])(const double *, int) = &amp;pa; // C++98, do it yourself\n</code></pre>  The automatic type deduction feature reflects a philosophical shift in the role of the compiler. In C++98, the compiler uses its knowledge to tell you when you are wrong. In C++11, at least with this feature, it uses its knowledge to help you get the right declaration. There is a potential drawback. Automatic type deduction ensures that the type of the variable matches the type of the initializer, but it still is possible that you might provide the wrong type of initializer:  <pre><code>auto pc = *pa; // oops! used *pa instead of &amp;pa\n</code></pre>  This declaration would make pc match the type of *pa, and that would result in a compiletime error when Listing 7.19 later uses pc, assuming that it is of the same type as &amp;pa.   <p></p>"},{"location":"#simplifying-with-typedef","title":"Simplifying with <code>typedef</code>","text":"<pre><code>typedef double real; // makes real another name for double\n\n// you can do this to make p_fun an alias for the function pointer type\ntypedef const double *(*p_fun)(const double *, int); // p_fun now a type name\np_fun p1 = f1; // p1 points to the f1() function\n\np_fun pa[3] = {f1,f2,f3}; // pa an array of 3 function pointers\np_fun (*pd)[3] = &amp;pa; // pd points to an array of 3 function pointers\n</code></pre>"},{"location":"#chapter-8-adventures-in-functions","title":"Chapter 8: Adventures in Functions","text":"List of what you will learn  <pre><code>- Inline functions\n- Reference variables\n- How to pass function arguments by reference\n- Default arguments\n- Function overloading\n- Function templates\n- Function template specializations\n</code></pre>"},{"location":"#inline-functions","title":"Inline functions","text":"inline.cpp - using an inline function. <pre><code>#include &lt;iostream&gt;\n// an inline function definition\ninline double square(double x) { return x * x; }\nint main()\n{\n    using namespace std;\n    double a, b;\n    double c = 13.0;\n\n    a = square(5.0);\n    b = square(4.5 + 7.5); // can pass expressions\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"c = \" &lt;&lt; c;\n    cout &lt;&lt; \", c squared = \" &lt;&lt; square(c++) &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"Now c = \" &lt;&lt; c &lt;&lt; \"\\n\";\n    return 0;\n}\n\n/*\na = 25, b = 144\nc = 13, c squared = 169\nNow c = 14\n*/\n</code></pre>  Inline Versus Macros        The `inline` facility is an addition to C++. C uses the preprocessor `#define` statement to provide *macros*, which are crude implementations of inline code. For example, here\u2019s a macro for squaring a number:  <pre><code>#define SQUARE(X) X*X\n</code></pre>  This works not by passing arguments but through text substitution, with the `X` acting as a symbolic label for the \u201cargument\u201d:  <pre><code>a = SQUARE(5.0); is replaced by a = 5.0*5.0;\nb = SQUARE(4.5 + 7.5); is replaced by b = 4.5 + 7.5 * 4.5 + 7.5;\nd = SQUARE(c++); is replaced by d = c++*c++;\n</code></pre>  Only the first example here works properly. You can improve matters with a liberal application of parentheses:  Still, the problem remains that macros don\u2019t pass by value. Even with this new definition, SQUARE(c++) increments c twice, but the inline square() function in Listing 8.1 evaluates c, passes that value to be squared, and then increments c once.  <pre><code>#define SQUARE(X) ((X)*(X))\n</code></pre>  Still, the problem remains that macros don\u2019t pass by value. Even with this new definition, `SQUARE(c++)` increments `c` twice, but the inline `square()` function in Listing 8.1 evaluates c, passes that value to be squared, and then increments `c` once.  The intent here is not to show you how to write C macros. Rather, it is to suggest that if you have been using C macros to perform function-like services, you should consider converting them to C++ inline functions"},{"location":"#reference-variables","title":"Reference Variables","text":"<p>reference is a name that acts as an alias, or an alternative name, for a previously defined variable. For example, if you make <code>twain</code> a reference to the <code>clemens</code> variable, you can use <code>twain</code> and <code>clemens</code> interchangeably to represent that variable.</p> <p>Unlike po0inters you can\u2019t declare the reference and then assign it a value later the way you can with a pointer:</p> <pre><code>int rat;\nint &amp; rodent;\nrodent = rat; // No, you can't do this.\n</code></pre> firstref.cpp - defining and using a reference. <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int rats = 101;\n    int &amp;rodents = rats; // rodents is a reference\n    cout &lt;&lt; \"rats = \" &lt;&lt; rats;\n    cout &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt; endl;\n    rodents++;\n    cout &lt;&lt; \"rats = \" &lt;&lt; rats;\n    cout &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt; endl;\n\n    // some implementations require type casting the following\n    // addresses to type unsigned\n    cout &lt;&lt; \"rats address = \" &lt;&lt; &amp;rats;\n    cout &lt;&lt; \", rodents address = \" &lt;&lt; &amp;rodents &lt;&lt; endl;\n    return 0;\n}\n</code></pre> secref.cpp - defining and using a reference. <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    int rats = 101;\n    int &amp;rodents = rats; // rodents is a reference\n\n    cout &lt;&lt; \"rats = \" &lt;&lt; rats;\n    cout &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt; endl;\n\n    cout &lt;&lt; \"rats address = \" &lt;&lt; &amp;rats;\n    cout &lt;&lt; \", rodents address = \" &lt;&lt; &amp;rodents &lt;&lt; endl;\n\n    int bunnies = 50;\n    rodents = bunnies; // can we change the reference?\n    cout &lt;&lt; \"bunnies = \" &lt;&lt; bunnies;\n    cout &lt;&lt; \", rats = \" &lt;&lt; rats;\n    cout &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt; endl;\n\n    cout &lt;&lt; \"bunnies address = \" &lt;&lt; &amp;bunnies;\n    cout &lt;&lt; \", rodents address = \" &lt;&lt; &amp;rodents &lt;&lt; endl;\n    return 0;\n}\n\n/*\nrats = 101, rodents = 101\nrats address = 0x0065fd44, rodents address = 0x0065fd44\nbunnies = 50, rats = 50, rodents = 50\nbunnies address = 0x0065fd48, rodents address = 0x0065fd4\n*/\n</code></pre> <p> </p> swaps.cpp - swapping with references and with pointers. <pre><code>#include &lt;iostream&gt;\nvoid swapr(int &amp;a, int &amp;b); // a, b are aliases for ints\nvoid swapp(int *p, int *q); // p, q are addresses of ints\nvoid swapv(int a, int b);   // a, b are new variables\nint main()\n{\n    using namespace std;\n    int wallet1 = 300;\n    int wallet2 = 350;\n\n    cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1;\n    cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl;\n\n    cout &lt;&lt; \"Using references to swap contents:\\n\";\n    swapr(wallet1, wallet2); // pass variables\n    cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1;\n    cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl;\n\n    cout &lt;&lt; \"Using pointers to swap contents again:\\n\";\n    swapp(&amp;wallet1, &amp;wallet2); // pass addresses of variables\n    cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1;\n    cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl;\n\n    cout &lt;&lt; \"Trying to use passing by value:\\n\";\n    swapv(wallet1, wallet2); // pass values of variables\n    cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1;\n    cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl;\n    return 0;\n}\n\nvoid swapr(int &amp;a, int &amp;b) // use references\n{\n    int temp;\n    temp = a; // use a, b for values of variables\n    a = b;\n    b = temp;\n}\n\nvoid swapp(int *p, int *q) // use pointers\n{\n    int temp;\n    temp = *p; // use *p, *q for values of variables\n    *p = *q;\n    *q = temp;\n}\n\nvoid swapv(int a, int b) // try using values\n{\n    int temp;\n    temp = a; // use a, b for values of variables\n    a = b;\n    b = temp;\n}\n\n/*\nwallet1 = $300 wallet2 = $350 &lt;&lt; original values\nUsing references to swap contents:\nwallet1 = $350 wallet2 = $300 &lt;&lt; values swapped\nUsing pointers to swap contents again:\nwallet1 = $300 wallet2 = $350 &lt;&lt; values swapped again\nTrying to use passing by value:\nwallet1 = $300 wallet2 = $350 &lt;&lt; swap failed\n*/\n</code></pre> cubes.cpp - regular and reference arguments. <pre><code>// cubes.cpp -- regular and reference arguments\n#include &lt;iostream&gt;\ndouble cube(double a);\ndouble refcube(double &amp;ra);\nint main()\n{\n    using namespace std;\n    double x = 3.0;\n    cout &lt;&lt; cube(x);\n    cout &lt;&lt; \" = cube of \" &lt;&lt; x &lt;&lt; endl;\n    cout &lt;&lt; refcube(x);\n    cout &lt;&lt; \" = cube of \" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n\ndouble cube(double a)\n{\n    a *= a * a;\n    return a;\n}\n\ndouble refcube(double &amp;ra)\n{\n    ra *= ra * ra;\n    return ra;\n}\n\n/*\n27 = cube of 3\n27 = cube of 27\n*/\n</code></pre>"},{"location":"#temporary-variables-reference-arguments-and-const","title":"Temporary Variables, Reference Arguments, and <code>const</code>","text":"<p>First, when is a temporary variable created? Provided that the reference parameter is a const, the compiler generates a temporary variable in two kinds of situations:</p> <ul> <li>When the actual argument is the correct type but isn\u2019t an lvalue</li> <li>When the actual argument is of the wrong type, but it\u2019s of a type that can be converted to the correct type</li> </ul> <p>An argument that\u2019s an <code>lvalue</code> is a data object that can be referenced by <code>address</code>. For example, a variable, an array element, a structure member, a reference, and a dereferenced pointer are lvalues. Non-lvalues include literal constants (aside from quoted strings, which are represented by their addresses) and expressions with multiple terms.</p> <p>Regular variable can be further characterized as being a <code>modifiable lvalue</code> and the const variable as a <code>non-modifiable lvalue</code>.</p> <pre><code>double refcube(const double &amp;ra)\n{\nreturn ra * ra * ra;\n}\n\ndouble side = 3.0;\ndouble * pd = &amp;side;\ndouble &amp; rd = side;\nlong edge = 5L;\ndouble lens[4] = { 2.0, 5.0, 10.0, 12.0};\ndouble c1 = refcube(side); // ra is side\ndouble c2 = refcube(lens[2]); // ra is lens[2]\ndouble c3 = refcube(rd); // ra is rd is side\ndouble c4 = refcube(*pd); // ra is *pd is side\ndouble c5 = refcube(edge); // ra is temporary variable\ndouble c6 = refcube(7.0); // ra is temporary variable\ndouble c7 = refcube(side + 10.0); // ra is temporary variable\n</code></pre>  Note        If a function call argument isn\u2019t an `lvalue` or does not match the type of the corresponding `const` reference parameter, C++ creates an anonymous variable of the correct type, assigns the value of the function call argument to the anonymous variable, and has the parameter refer to that variable.   <p></p>  Use `const` When You Can        There are three strong reasons to declare reference arguments as references to constant data:  - Using `const` protects you against programming errors that inadvertently alter data. - Using `const` allows a function to process both `const` and `non-const` actual arguments, whereas a function that omits `const` in the prototype only can accept nonconst data. - Using a `const` reference allows the function to generate and use a temporary variable appropriately.  You should declare formal reference arguments as `const` whenever it\u2019s appropriate to do so.   <p></p> <p>C++11 introduces a second kind of reference, called an rvalue reference, that can refer to an rvalue. It\u2019s declared using &amp;&amp;:</p> <pre><code>double &amp;&amp; rref = std::sqrt(36.00); // not allowed for double &amp;\ndouble j = 15.0;\ndouble &amp;&amp; jref = 2.0* j + 18.5; // not allowed for double &amp;\nstd::cout &lt;&lt; rref &lt;&lt; '\\n'; // display 6.0\nstd::cout &lt;&lt; jref &lt;&lt; '\\n'; // display 48.5;\n</code></pre> <p>The <code>rvalue</code> reference was introduced mainly to help library designers provide more efficient implementations of certain operations. Chapter 18,\u201cVisiting will the New C++ Standard,\u201d discusses how rvalue references are used to implement an approach called move semantics.The original reference type (the one declared using a single &amp;) is now called an <code>lvalue</code> reference.</p>"},{"location":"#using-references-with-a-structure","title":"Using References with a Structure","text":"<p>References work wonderfully with <code>structures</code> and <code>classes</code> References were introduced primarily for use with these types, not for use with the basic built-in types.</p> <p>Suppose we have the following definition of a structure:</p> <pre><code>struct free_throws\n{\n    std::string name;\n    int made;\n    int attempts;\n    float percent;\n};\n</code></pre> <p>Then a function using a reference to this type could be prototyped as follows:</p> <pre><code>void set_pc(free_throws &amp; ft); // use a reference to a structure\n</code></pre> <p>If the intent is that the function doesn\u2019t alter the structure, use const:</p> <pre><code>void display(const free_throws &amp; ft); // don't allow changes to structure\n</code></pre> strc_ref.cpp - using structure references. <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct free_throws\n{\n    std::string name;\n    int made;\n    int attempts;\n    float percent;\n};\n\nvoid display(const free_throws &amp;ft);\nvoid set_pc(free_throws &amp;ft);\nfree_throws &amp;accumulate(free_throws &amp;target, const free_throws &amp;source);\n\nint main()\n{\n    // partial initializations \u2013 remaining members set to 0\n    free_throws one = {\"Ifelsa Branch\", 13, 14};\n    free_throws two = {\"Andor Knott\", 10, 16};\n    free_throws three = {\"Minnie Max\", 7, 9};\n    free_throws four = {\"Whily Looper\", 5, 9};\n    free_throws five = {\"Long Long\", 6, 14};\n    free_throws team = {\"Throwgoods\", 0, 0};\n    // no initialization\n    free_throws dup;\n\n    set_pc(one);\n    display(one);\n    accumulate(team, one);\n    display(team);\n    // use return value as argument\n    display(accumulate(team, two));\n    accumulate(accumulate(team, three), four);\n    display(team);\n    // use return value in assignment\n    dup = accumulate(team, five);\n    std::cout &lt;&lt; \"Displaying team:\\n\";\n    display(team);\n    std::cout &lt;&lt; \"Displaying dup after assignment:\\n\";\n    display(dup);\n\n    set_pc(four);\n    // ill-advised assignment\n    accumulate(dup, five) = four;\n    std::cout &lt;&lt; \"Displaying dup after ill-advised assignment:\\n\";\n    display(dup);\n    return 0;\n}\n\nvoid display(const free_throws &amp;ft)\n{\n    using std::cout;\n    cout &lt;&lt; \"Name: \" &lt;&lt; ft.name &lt;&lt; '\\n';\n    cout &lt;&lt; \" Made: \" &lt;&lt; ft.made &lt;&lt; '\\t';\n    cout &lt;&lt; \"Attempts: \" &lt;&lt; ft.attempts &lt;&lt; '\\t';\n    cout &lt;&lt; \"Percent: \" &lt;&lt; ft.percent &lt;&lt; '\\n';\n}\n\nvoid set_pc(free_throws &amp;ft)\n{\n    if (ft.attempts != 0)\n        ft.percent = 100.0f * float(ft.made) / float(ft.attempts);\n    else\n        ft.percent = 0;\n}\n\nfree_throws &amp;accumulate(free_throws &amp;target, const free_throws &amp;source)\n{\n    target.attempts += source.attempts;\n    target.made += source.made;\n    set_pc(target);\n    return target;\n}\n\n/*\nName: Ifelsa Branch\nMade: 13 Attempts: 14 Percent: 92.8571\nName: Throwgoods\nMade: 13 Attempts: 14 Percent: 92.8571\nName: Throwgoods\nMade: 23 Attempts: 30 Percent: 76.6667\nName: Throwgoods\nMade: 35 Attempts: 48 Percent: 72.9167\nDisplaying team:\nName: Throwgoods\nMade: 41 Attempts: 62 Percent: 66.129\nDisplaying dup after assignment:\nName: Throwgoods\nMade: 41 Attempts: 62 Percent: 66.129\nDisplaying dup after ill-advised assignment:\nName: Whily Looper\nMade: 5 Attempts: 9 Percent: 55.5556\n*/\n</code></pre> <p>A function that returns a reference is actually an alias for the referred-to variable.</p>"},{"location":"#being-careful-about-what-a-return-reference-refers-to","title":"Being Careful About What a Return Reference Refers To","text":"<pre><code>const free_throws &amp; clone2(free_throws &amp; ft)\n{\n    free_throws newguy; // first step to big error\n    newguy = ft; // copy info\n    return newguy; // return reference to copy\n}\n</code></pre> <p>This has the unfortunate effect of returning a reference to a temporary variable (newguy) that passes from existence as soon as the function terminates.</p> <p>Here\u2019s how you could do something similar with a reference:</p> <pre><code>const free_throws &amp; clone(free_throws &amp; ft)\n{\n    free_throws * pt;\n    *pt = ft; // copy info\n    return *pt; // return reference to copy\n}\n</code></pre>"},{"location":"#using-references-with-a-class-object","title":"Using References with a Class Object","text":"<p>The general idea is to create a function that adds a given string to each end of another string. Listing 8.7 (strquote) provides three functions that are intended to do this. However, one of the designs is so flawed that it may cause the program to crash or even not compile.</p> strquote.cpp - different designs. <pre><code>// strquote.cpp -- different designs\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nstring version1(const string &amp;s1, const string &amp;s2);\nconst string &amp;version2(string &amp;s1, const string &amp;s2); // has side effect\nconst string &amp;version3(string &amp;s1, const string &amp;s2); // bad design\n\nint main()\n{\n    string input;\n    string copy;\n    string result;\n\n    cout &lt;&lt; \"Enter a string: \";\n    getline(cin, input);\n    copy = input;\n    cout &lt;&lt; \"Your string as entered: \" &lt;&lt; input &lt;&lt; endl;\n    result = version1(input, \"***\");\n    cout &lt;&lt; \"Your string enhanced: \" &lt;&lt; result &lt;&lt; endl;\n    cout &lt;&lt; \"Your original string: \" &lt;&lt; input &lt;&lt; endl;\n\n    result = version2(input, \"###\");\n    cout &lt;&lt; \"Your string enhanced: \" &lt;&lt; result &lt;&lt; endl;\n    cout &lt;&lt; \"Your original string: \" &lt;&lt; input &lt;&lt; endl;\n    cout &lt;&lt; \"Resetting original string.\\n\";\n\n    input = copy;\n    result = version3(input, \"@@@\");\n    cout &lt;&lt; \"Your string enhanced: \" &lt;&lt; result &lt;&lt; endl;\n    cout &lt;&lt; \"Your original string: \" &lt;&lt; input &lt;&lt; endl;\n\n    return 0;\n}\n\nstring version1(const string &amp;s1, const string &amp;s2)\n{\n    string temp;\n\n    temp = s2 + s1 + s2;\n    return temp;\n}\n\nconst string &amp;version2(string &amp;s1, const string &amp;s2) // has side effect\n{\n    s1 = s2 + s1 + s2;\n    // safe to return reference passed to function\n    return s1;\n}\n\nconst string &amp;version3(string &amp;s1, const string &amp;s2) // bad design\n{\n    string temp;\n    temp = s2 + s1 + s2;\n    // unsafe to return reference to local variable\n    return temp;\n}\n\n/*\nEnter a string: It\u2019s not my fault.\nYour string as entered: It's not my fault.\nYour string enhanced: ***It's not my fault.***\nYour original string: It's not my fault.\nYour string enhanced: ###It's not my fault.###\nYour original string: ###It's not my fault.###\nResetting original string.\n*/\n</code></pre>  Passing a C-Style String Argument to a string Object Reference Parameter        You may have noticed a rather interesting fact about the `version1()` function: Both formal parameters (`s1` and `s2`) are type const string `&amp;`, but the actual arguments (`input` and `\"***\"`) are type string and `const char *`, respectively. Because `input` is type `string`, there is no problem having `s1` refer to it. But how is it that the program accepts passing a `pointer-to-char` argument to a string reference?  Two things are going on here. One is that the `string` class defines a `char *-to-string` conversion, which makes it possible to initialize a string `object` to a C-style string. The second is a property of `const` reference formal parameters that is discussed earlier in this chapter. Suppose the actual argument type doesn\u2019t match the reference parameter type but can be converted to the reference type. Then the program creates a temporary variable of the correct type, initializes it to the converted value, and passes a reference to the temporary variable. Earlier this chapter you saw, for instance, that a `const double &amp;` parameter can handle an int argument in this fashion. Similarly, a `const string &amp;` parameter can handle a `char *` or `const char *` argument in this fashion.  The convenient outcome of this is that if the formal parameter is type `const string &amp;`, the actual argument used in the function call can be a `string` object or a C-style string, such as a quoted string literal, a null-terminated array of `char`, or a pointer variable that points to a `char`. Hence the following works fine:  <pre><code>result = version1(input, \"***\");\n</code></pre> <p></p>"},{"location":"#another-object-lesson-objects-inheritance-and-references","title":"Another Object Lesson: Objects, Inheritance, and References","text":"<p>The language feature that makes it possible to pass features from one class to another is called inheritance. Eg.: objects of the <code>ofstream</code> type can use <code>ostream</code> methods, allowing file input/output to use the same forms as console input/output.</p> filefunc.cpp - function with ostream &amp; parameter. <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\nvoid file_it(ostream &amp;os, double fo, const double fe[], int n);\nconst int LIMIT = 5;\n\nint main()\n{\n    ofstream fout;\n    const char *fn = \"ep-data.txt\";\n    fout.open(fn);\n    if (!fout.is_open())\n    {\n        cout &lt;&lt; \"Can't open \" &lt;&lt; fn &lt;&lt; \". Bye.\\n\";\n        exit(EXIT_FAILURE);\n    }\n    double objective;\n    cout &lt;&lt; \"Enter the focal length of your \"\n            \"telescope objective in mm: \";\n    cin &gt;&gt; objective;\n    double eps[LIMIT];\n    cout &lt;&lt; \"Enter the focal lengths, in mm, of \" &lt;&lt; LIMIT\n         &lt;&lt; \" eyepieces:\\n\";\n    for (int i = 0; i &lt; LIMIT; i++)\n    {\n        cout &lt;&lt; \"Eyepiece #\" &lt;&lt; i + 1 &lt;&lt; \": \";\n        cin &gt;&gt; eps[i];\n    }\n    file_it(fout, objective, eps, LIMIT);\n    file_it(cout, objective, eps, LIMIT);\n    cout &lt;&lt; \"Done\\n\";\n    return 0;\n}\n\nvoid file_it(ostream &amp;os, double fo, const double fe[], int n)\n{\n    ios_base::fmtflags initial;\n    initial = os.setf(ios_base::fixed); // save initial formatting state\n    os.precision(0);\n    os &lt;&lt; \"Focal length of objective: \" &lt;&lt; fo &lt;&lt; \" mm\\n\";\n    os.setf(ios::showpoint);\n    os.precision(1);\n    os.width(12);\n    os &lt;&lt; \"f.l. eyepiece\";\n    os.width(15);\n    os &lt;&lt; \"magnification\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n; i++)\n    {\n        os.width(12);\n        os &lt;&lt; fe[i];\n        os.width(15);\n        os &lt;&lt; int(fo / fe[i] + 0.5) &lt;&lt; endl;\n    }\n    os.setf(initial); // restore initial formatting state\n}\n\n/*\nEnter the focal length of your telescope objective in mm: 1800\nEnter the focal lengths, in mm, of 5 eyepieces:\nEyepiece #1: 30\nEyepiece #2: 19\nEyepiece #3: 14\nEyepiece #4: 8.8w\nEyepiece #5: 7.5\nFocal length of objective: 1800 mm\nf.l. eyepiece magnification\n    30.0    60\n    19.0    95\n    14.0    129\n    8.8     205\n    7.5     240\nDone\n*/\n</code></pre>"},{"location":"#when-to-use-referencepointervalue-arguments","title":"When to Use Reference/Pointer/Value Arguments","text":"<p>There are two main reasons for using reference arguments:</p> <ul> <li>To allow you to alter a data object in the calling function</li> <li>To speed up a program by passing a reference instead of an entire data object</li> </ul> <p>So when should you use a reference? Use a pointer? Pass by value? The following are some guidelines. A function uses passed data without modifying it:</p> <ul> <li>If the data object is small, such as a built-in data type or a small structure, pass it by value.</li> <li>If the data object is an array, use a pointer because that\u2019s your only choice. Make the pointer a pointer to <code>const</code>.</li> <li>If the data object is a good-sized structure, use a <code>const</code> pointer or a <code>const</code> reference to increase program efficiency.You save the time and space needed to copy a structure or a class design. Make the pointer or reference <code>const</code>.</li> <li>If the data object is a class object, use a <code>const</code> reference.The semantics of class</li> </ul> <p>design often require using a reference, which is the main reason C++ added this feature.Thus, the standard way to pass class object arguments is by reference. A function modifies data in the calling function:</p> <ul> <li>If the data object is a built-in data type, use a pointer. If you spot code like <code>fixit(&amp;x)</code>, where <code>x</code> is an <code>int</code>, it\u2019s pretty clear that this function intends to modify <code>x</code>.</li> <li>If the data object is an array, use your only choice: a pointer.</li> <li>If the data object is a structure, use a reference or a pointer.</li> <li>If the data object is a class object, use a reference.</li> </ul>"},{"location":"#default-arguments","title":"Default Arguments","text":"<p><code>default argument</code> is a value that\u2019s used automatically if you omit the corresponding actual argument from a function call.</p> <p>You must use the function prototype. Because the compiler looks at the prototype to see how many arguments a function uses, the function prototype also has to alert the program to the possibility of default arguments. The method is to assign a value to the argument in the prototype. For example, here\u2019s the prototype fitting this description of <code>left()</code>:</p> <pre><code>char * left(const char * str, int n = 1);\n\nint harpo(int n, int m = 4, int j = 5); // VALID\nint chico(int n, int m = 6, int j); // INVALID\nint groucho(int k = 1, int m = 2, int n = 3); // VALID\n\nbeeps = harpo(2); // same as harpo(2,4,5)\nbeeps = harpo(1,8); // same as harpo(1,8,5)\nbeeps = harpo (8,7,6); // no default arguments used\n\nbeeps = harpo(3, ,8); // invalid, doesn't set m to 4\n</code></pre> left.cpp - string function with a default argument. <pre><code>#include &lt;iostream&gt;\nconst int ArSize = 80;\nchar *left(const char *str, int n = 1);\nint main()\n{\n    using namespace std;\n    char sample[ArSize];\n    cout &lt;&lt; \"Enter a string:\\n\";\n    cin.get(sample, ArSize);\n    char *ps = left(sample, 4);\n    cout &lt;&lt; ps &lt;&lt; endl;\n    delete[] ps; // free old string\n    ps = left(sample);\n    cout &lt;&lt; ps &lt;&lt; endl;\n    delete[] ps; // free new string\n    return 0;\n}\n\n// This function returns a pointer to a new string\n// consisting of the first n characters in the str string.\nchar *left(const char *str, int n)\n{\n    if (n &lt; 0)\n        n = 0;\n    char *p = new char[n + 1];\n    int i;\n    for (i = 0; i &lt; n &amp;&amp; str[i]; i++)\n        p[i] = str[i]; // copy characters\n    while (i &lt;= n)\n        p[i++] = '\\0'; // set rest of string to '\\0'\n    return p;\n}\n\n/*\nEnter a string:\nforthcoming\nfort\nf\n*/\n</code></pre>"},{"location":"#function-overloading","title":"Function Overloading","text":"<p><code>Function polymorphism</code> is a neat C++ addition to C\u2019s capabilities. Whereas default arguments let you call the same function by using varying numbers of arguments, function polymorphism, also called <code>function overloading</code>, lets you use multiple functions sharing the same name.</p> <p>You can use function overloading to design a family of functions that do essentially the same thing but using different argument lists.</p> <pre><code>void print(const char * str, int width); // #1\nvoid print(double d, int width); // #2\nvoid print(long l, int width); // #3\nvoid print(int i, int width); // #4\nvoid print(const char *str); // #5\n\nprint(\"Pancakes\", 15); // use #1\nprint(\"Syrup\"); // use #5\nprint(1999.0, 10); // use #2\nprint(1999, 12); // use #4\nprint(1999L, 15); // use #3\n</code></pre>  Overloading Reference Parameters       Class designs and the STL often use reference parameters, and it\u2019s useful to know how overloading works with different reference types. Consider the following three prototypes:  <pre><code>void sink(double &amp; r1); // matches modifiable lvalue\nvoid sank(const double &amp; r2); // matches modifiable or const lvalue, rvalue\nvoid sunk(double &amp;&amp; r3); // matches rvalue\n</code></pre>  The lvalue reference parameter `r1` matches a modifiable lvalue argument, such as a double variable. The `const` lvalue reference parameter `r2` matches a modifiable lvalue argument, a `const` lvalue argument, and an rvalue argument, such as the sum of two double values. Finally, the rvalue reference `r3` matches an rvalue. Note how `r2` can match the same sort of arguments that `r1` and `r3` match. This raises the question of what happens when you overload a function on these three types of parameters. The answer is that the more exact match is made:  <pre><code>void staff(double &amp; rs); // matches modifiable lvalue\nvoid staff(const double &amp; rcs); // matches rvalue, const lvalue\nvoid stove(double &amp; r1); // matches modifiable lvalue\nvoid stove(const double &amp; r2); // matches const lvalue\nvoid stove(double &amp;&amp; r3); // matches rvalue\n</code></pre>  This allows you to customize the behavior of a function based on the `lvalue`, `const`, or rvalue nature of the argument:  <pre><code>double x = 55.5;\nconst double y = 32.0;\nstove(x); // calls stove(double &amp;)\nstove(y); // calls stove(const double &amp;)\nstove(x+y); // calls stove(double &amp;&amp;)\n</code></pre>  If, say, you omit the `stove(double &amp;&amp;)` function, then `stove(x+y)` will call the `stove(const double &amp;)` function instead.   <p></p> leftover.cpp - overloading the left() function. <pre><code>#include &lt;iostream&gt;\n\nunsigned long left(unsigned long num, unsigned ct);\nchar *left(const char *str, int n = 1);\n\nint main()\n{\n    using namespace std;\n    char *trip = \"Hawaii!!\";    // test value\n    unsigned long n = 12345678; // test value\n    int i;\n    char *temp;\n    for (i = 1; i &lt; 10; i++)\n    {\n        cout &lt;&lt; left(n, i) &lt;&lt; endl;\n        temp = left(trip, i);\n        cout &lt;&lt; temp &lt;&lt; endl;\n        delete[] temp; // point to temporary storage\n    }\n    return 0;\n}\n\n// This function returns the first ct digits of the number num.\nunsigned long left(unsigned long num, unsigned ct)\n{\n    unsigned digits = 1;\n    unsigned long n = num;\n    if (ct == 0 || num == 0)\n        return 0; // return 0 if no digits\n    while (n /= 10)\n        digits++;\n    if (digits &gt; ct)\n    {\n        ct = digits - ct;\n        while (ct--)\n            num /= 10;\n        return num; // return left ct digits\n    }\n    else            // if ct &gt;= number of digits\n        return num; // return the whole number\n}\n\n// This function returns a pointer to a new string\n// consisting of the first n characters in the str string.\nchar *left(const char *str, int n)\n{\n    if (n &lt; 0)\n        n = 0;\n    char *p = new char[n + 1];\n    int i;\n    for (i = 0; i &lt; n &amp;&amp; str[i]; i++)\n        p[i] = str[i]; // copy characters\n    while (i &lt;= n)\n        p[i++] = '\\0'; // set rest of string to '\\0'\n    return p;\n}\n\n/*\n1\nH\n12\nHa\n123\nHaw\n1234\nHawa\n12345\nHawai\n123456\nHawaii\n1234567\nHawaii!\n12345678\nHawaii!!\n12345678\nHawaii!!\n*/\n</code></pre> <p>You might find function overloading fascinating, but you shouldn\u2019t overuse it. You should reserve function overloading for functions that perform basically the same task but with different forms of data.</p> <pre><code>char * left(const char * str, unsigned n); // two arguments\nchar * left(const char * str); // one argument\n</code></pre>  What Is Name Decoration?        How does C++ keep track of which overloaded function is which? It assigns a secret identity to each of these functions. When you use the editor of your C++ development tool to write and compile programs, your C++ compiler performs a bit of magic on your behalf\u2014known as name decoration or name mangling\u2014through which each function name is encrypted, based on the formal parameter types specified in the function\u2019s prototype. Consider the following undecorated function prototype:  <pre><code>long MyFunctionFoo(int, float);\n</code></pre>  This format is fine for us humans; we know that the function accepts two arguments of type `int` and `float`, and it returns a value of type `long`. For its own use, the compiler documents this interface by transforming the name into an internal representation with a more unsightly appearance, perhaps something like this:  <pre><code>?MyFunctionFoo@@YAXH\n</code></pre>  The apparent gibberish decorating the original name (or mangling it, depending on your attitude) encodes the number and types of parameters. A different function signature would result in a different set of symbols being added, and different compilers would use different conventions for their efforts at decorating.   <p></p>"},{"location":"#function-templates","title":"Function Templates","text":"<p>A function template is a generic function description; that is, it defines a function in terms of a generic type for which a specific type, such as int or double, can be substituted. By passing a type as a parameter to a template, you cause the compiler to generate a function for that particular type.</p> <p>Because templates let you program in terms of a generic type instead of a specific type, the process is sometimes termed generic programming.</p> <p>Because types are represented by parameters, the template feature is sometimes referred to as parameterized types.</p> <p>Function templates enable you to define a function in terms of some arbitrary type. For example, you can set up a swapping template like this:</p> <pre><code>template &lt;typename AnyType&gt;\nvoid Swap(AnyType &amp;a, AnyType &amp;b)\n{\n    AnyType temp;\n    temp = a;\n    a = b;\n    b = temp;\n}\n</code></pre> <p>The first line specifies that you are setting up a template and that you\u2019re naming the arbitrary type AnyType.The keywords <code>template</code> and <code>typename</code> are obligatory, except that you can use the keyword <code>class</code> instead of <code>typename</code>. Also you must use the angle brackets.</p>  Tip        You should use templates if you need functions that apply the same algorithm to a variety of types. If you aren\u2019t concerned with backward compatibility and can put up with the effort of typing a longer word, you can use the keyword `typename` rather than `class` when you declare type parameters.  <p></p> <p>To let the compiler know that you need a particular form of swap function, you just use a function called Swap() in your program.</p> funtemp.cpp - using a function template. <pre><code>#include &lt;iostream&gt;\n\n// function template prototype\ntemplate &lt;typename T&gt; // or class T\nvoid Swap(T &amp;a, T &amp;b);\n\nint main()\n{\n    using namespace std;\n    int i = 10;\n    int j = 20;\n    cout &lt;&lt; \"i, j = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \".\\n\";\n    cout &lt;&lt; \"Using compiler-generated int swapper:\\n\";\n    Swap(i, j); // generates void Swap(int &amp;, int &amp;)\n    cout &lt;&lt; \"Now i, j = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \".\\n\";\n    double x = 24.5;\n    double y = 81.7;\n    cout &lt;&lt; \"x, y = \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \".\\n\";\n    cout &lt;&lt; \"Using compiler-generated double swapper:\\n\";\n    Swap(x, y); // generates void Swap(double &amp;, double &amp;)\n    cout &lt;&lt; \"Now x, y = \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \".\\n\";\n    // cin.get();\n    return 0;\n}\n\n// function template definition\ntemplate &lt;typename T&gt; // or class T\nvoid Swap(T &amp;a, T &amp;b)\n{\n    T temp; // temp a variable of type T\n    temp = a;\n    a = b;\n    b = temp;\n}\n\n/*\ni, j = 10, 20.\nUsing compiler-generated int swapper:\nNow i, j = 20, 10.\nx, y = 24.5, 81.7.\nUsing compiler-generated double swapper:\nNow x, y = 81.7, 24.5.\n\n\nThe second Swap() function has two double arguments, so the compiler generates a\ndouble version. That is, it replaces T with double.\n*/\n</code></pre>"},{"location":"#overloaded-templates","title":"Overloaded Templates","text":"<p>You use templates when you need functions that apply the same algorithm to a variety of types. To handle this possibility, you can overload template definitions, just as you overload regular function definitions.</p> twotemps.cpp - using overloaded template functions. <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; // original template\nvoid Swap(T &amp;a, T &amp;b);\n\ntemplate &lt;typename T&gt; // new template\nvoid Swap(T *a, T *b, int n);\n\nvoid Show(int a[]);\nconst int Lim = 8;\n\nint main()\n{\n    using namespace std;\n    int i = 10, j = 20;\n    cout &lt;&lt; \"i, j = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \".\\n\";\n    cout &lt;&lt; \"Using compiler-generated int swapper:\\n\";\n    Swap(i, j); // matches original template\n    cout &lt;&lt; \"Now i, j = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \".\\n\";\n    int d1[Lim] = {0, 7, 0, 4, 1, 7, 7, 6};\n    int d2[Lim] = {0, 7, 2, 0, 1, 9, 6, 9};\n    cout &lt;&lt; \"Original arrays:\\n\";\n    Show(d1);\n    Show(d2);\n    Swap(d1, d2, Lim); // matches new template\n    cout &lt;&lt; \"Swapped arrays:\\n\";\n    Show(d1);\n    Show(d2);\n    // cin.get();\n    return 0;\n}\n\ntemplate &lt;typename T&gt;\nvoid Swap(T &amp;a, T &amp;b)\n{\n    T temp;\n    temp = a;\n    a = b;\n    b = temp;\n}\n\ntemplate &lt;typename T&gt;\nvoid Swap(T a[], T b[], int n)\n{\n    T temp;\n    for (int i = 0; i &lt; n; i++)\n    {\n        temp = a[i];\n        a[i] = b[i];\n        b[i] = temp;\n    }\n}\n\nvoid Show(int a[])\n{\n    using namespace std;\n    cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; \"/\";\n    cout &lt;&lt; a[2] &lt;&lt; a[3] &lt;&lt; \"/\";\n    for (int i = 4; i &lt; Lim; i++)\n        cout &lt;&lt; a[i];\n    cout &lt;&lt; endl;\n}\n\n/*\ni, j = 10, 20.\nUsing compiler-generated int swapper:\nNow i, j = 20, 10.\nOriginal arrays:\n07/04/1776\n07/20/1969\nSwapped arrays:\n07/20/1969\n07/04/1776\n*/\n</code></pre>"},{"location":"#template-limitations","title":"Template Limitations","text":"<p>Suppose you have a template function:</p> <pre><code>template &lt;class T&gt; // or template &lt;typename T&gt;\nvoid f(T a, T b)\n{...}\n</code></pre> <p>Often the code makes assumptions about what operations are possible for the type. For instance, the following statement assumes that assignment is defined, and this would not be true if type T is a built-in array type:</p> <pre><code>a = b;\n</code></pre> <p>Similarly, the following assumes &gt; is defined, which is not true if T is an ordinary structure:</p> <pre><code>if (a &gt; b)\n</code></pre> <p>Also the &gt; operator is defined for array names, but because array names are addresses, it compares the addresses of the arrays, which may not be what you have in mind.And the following assumes the multiplication operator is defined for type T, which is not the case if T is an array, a pointer, or a structure:</p> <pre><code>T c = a*b;\n</code></pre> <p>In short, it\u2019s easy to write a template function that cannot handle certain types</p>"},{"location":"#explicit-specializations","title":"Explicit Specializations","text":"<p>You can supply a specialized function definition, called an explicit specialization, with the required code. If the compiler finds a specialized definition that exactly matches a function call, it uses that definition without looking for templates. The specialization mechanism has changed with the evolution of C++.We\u2019ll look</p>"},{"location":"#third-generation-specialization-isoansi-c-standard","title":"Third-Generation Specialization (ISO/ANSI C++ Standard)","text":"<p>After some youthful experimentation with other approaches, the C++98 Standard settled on this approach:</p> <ul> <li>For a given function name, you can have a non template function, a template function, and an explicit specialization template function, along with overloaded versions of all of these.</li> <li>The prototype and definition for an explicit specialization should be preceded by <code>template &lt;&gt;</code> and should mention the specialized type by name.</li> <li>A specialization overrides the regular template, and a non template function overrides both</li> </ul> <p>Here\u2019s how prototypes for swapping type job structures would look for these three forms:</p> <pre><code>// non template function prototype\nvoid Swap(job &amp;, job &amp;);\n\n// template prototype\ntemplate &lt;typename T&gt;\nvoid Swap(T &amp;, T &amp;);\n\n// explicit specialization for the job type\ntemplate &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;);\n</code></pre> twoswap.cpp - specialization overrides a template. <pre><code>#include &lt;iostream&gt;\ntemplate &lt;typename T&gt;\nvoid Swap(T &amp;a, T &amp;b);\n\nstruct job\n{\n    char name[40];\n    double salary;\n    int floor;\n};\n\n// explicit specialization\ntemplate &lt;&gt;\nvoid Swap&lt;job&gt;(job &amp;j1, job &amp;j2);\nvoid Show(job &amp;j);\n\nint main()\n{\n    using namespace std;\n    cout.precision(2);\n    cout.setf(ios::fixed, ios::floatfield);\n    int i = 10, j = 20;\n    cout &lt;&lt; \"i, j = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \".\\n\";\n    cout &lt;&lt; \"Using compiler-generated int swapper:\\n\";\n    Swap(i, j); // generates void Swap(int &amp;, int &amp;)\n    cout &lt;&lt; \"Now i, j = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \".\\n\";\n    job sue = {\"Susan Yaffee\", 73000.60, 7};\n    job sidney = {\"Sidney Taffee\", 78060.72, 9};\n    cout &lt;&lt; \"Before job swapping:\\n\";\n    Show(sue);\n    Show(sidney);\n    Swap(sue, sidney); // uses void Swap(job &amp;, job &amp;)\n    cout &lt;&lt; \"After job swapping:\\n\";\n    Show(sue);\n    Show(sidney);\n    // cin.get();\n    return 0;\n}\n\ntemplate &lt;typename T&gt;\nvoid Swap(T &amp;a, T &amp;b) // general version\n{\n    T temp;\n    temp = a;\n    a = b;\n    b = temp;\n}\n\n// swaps just the salary and floor fields of a job structure\ntemplate &lt;&gt;\nvoid Swap&lt;job&gt;(job &amp;j1, job &amp;j2) // specialization\n{\n    double t1;\n    int t2;\n    t1 = j1.salary;\n    j1.salary = j2.salary;\n    j2.salary = t1;\n    t2 = j1.floor;\n    j1.floor = j2.floor;\n    j2.floor = t2;\n}\n\nvoid Show(job &amp;j)\n{\n    using namespace std;\n    cout &lt;&lt; j.name &lt;&lt; \": $\" &lt;&lt; j.salary\n         &lt;&lt; \" on floor \" &lt;&lt; j.floor &lt;&lt; endl;\n}\n\n/*\ni, j = 10, 20.\nUsing compiler-generated int swapper:\nNow i, j = 20, 10.\nBefore job swapping:\nSusan Yaffee: $73000.60 on floor 7\nSidney Taffee: $78060.72 on floor 9\nAfter job swapping:\nSusan Yaffee: $78060.72 on floor 9\nSidney Taffee: $73000.60 on floor 7\n*/\n</code></pre>"},{"location":"#instantiations-and-specializations","title":"Instantiations and Specializations","text":"<p>To extend your understanding of templates, let\u2019s investigate the terms <code>instantiation</code> and <code>specialization</code>. Keep in mind that including a function template in your code does not in itself generate a function definition. It\u2019s merely a plan for generating a function definition.</p> <pre><code>template void Swap&lt;int&gt;(int, int); // explicit instantiation\ntemplate &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;); // explicit specialization\ntemplate &lt;&gt; void Swap(int &amp;, int &amp;); // explicit specialization\n</code></pre> <p>Caution It is an error to try to use both an explicit instantiation and an explicit specialization for the same type(s) in the same file, or, more generally, the same translation unit.</p> <pre><code>template &lt;class T&gt;\nvoid Swap (T &amp;, T &amp;); // template prototype\ntemplate &lt;&gt; void Swap&lt;job&gt;(job &amp;, job &amp;); // explicit specialization for job\nint main(void)\n{\n    template void Swap&lt;char&gt;(char &amp;, char &amp;); // explicit instantiation for char\n    short a, b;\n    ...\n    Swap(a,b); // implicit template instantiation for short\n    job n, m;\n    ...\n    Swap(n, m); // use explicit specialization for job\n    char g, h;\n    ...\n    Swap(g, h); // use explicit template instantiation for char\n    ...\n}\n</code></pre>"},{"location":"#which-function-version-does-the-compiler-pick","title":"Which Function Version Does the Compiler Pick?","text":"<p>What with function overloading, function templates, and function template overloading, C++ needs, and has, a well-defined strategy for deciding which function definition to use for a function call, particularly when there are multiple arguments.The process is called overload resolution. Detailing the complete strategy would take a small chapter, so let\u2019s take just a broad look at how the process works:</p> <ul> <li>Phase 1\u2014Assemble a list of candidate functions.These are functions and template functions that have the same names as the called functions.</li> <li>Phase 2\u2014From the candidate functions, assemble a list of viable functions.These are functions with the correct number of arguments and for which there is an implicit conversion sequence, which includes the case of an exact match for each type of actual argument to the type of the corresponding formal argument. For example, a function call with a type <code>float</code> argument could have that value converted to a <code>double</code> to match a type <code>double</code> formal parameter, and a template could generate an instantiation for float.</li> <li>Phase 3\u2014Determine whether there is a best viable function. If so, you use that function. Otherwise, the function call is an error.</li> </ul>"},{"location":"#a-partial-ordering-rules-example","title":"A Partial Ordering Rules Example","text":"<p>Let\u2019s examine a complete program that uses the partial ordering rules for identifying which template definition to use.</p> <p>If you remove Template B from the program, the compiler then uses Template A for listing the contents of <code>pd</code>, so it lists the addresses instead of the values.</p> tempover.cpp - template overloading. <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; // template A\nvoid ShowArray(T arr[], int n);\ntemplate &lt;typename T&gt; // template B\nvoid ShowArray(T *arr[], int n);\n\nstruct debts\n{\n    char name[50];\n    double amount;\n};\n\nint main()\n{\n    using namespace std;\n    int things[6] = {13, 31, 103, 301, 310, 130};\n    struct debts mr_E[3] =\n        {\n            {\"Ima Wolfe\", 2400.0},\n            {\"Ura Foxe\", 1300.0},\n            {\"Iby Stout\", 1800.0}};\n    double *pd[3];\n    // set pointers to the amount members of the structures in mr_E\n    for (int i = 0; i &lt; 3; i++)\n        pd[i] = &amp;mr_E[i].amount;\n    cout &lt;&lt; \"Listing Mr. E's counts of things:\\n\";\n    // things is an array of int\n    ShowArray(things, 6); // uses template A\n    cout &lt;&lt; \"Listing Mr. E's debts:\\n\";\n    // pd is an array of pointers to double\n    ShowArray(pd, 3); // uses template B (more specialized)\n    return 0;\n}\n\ntemplate &lt;typename T&gt;\nvoid ShowArray(T arr[], int n)\n{\n    using namespace std;\n    cout &lt;&lt; \"template A\\n\";\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; ' ';\n    cout &lt;&lt; endl;\n}\n\ntemplate &lt;typename T&gt;\nvoid ShowArray(T *arr[], int n)\n{\n    using namespace std;\n    cout &lt;&lt; \"template B\\n\";\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; *arr[i] &lt;&lt; ' ';\n    cout &lt;&lt; endl;\n}\n\n/*\nListing Mr. E's counts of things:\ntemplate A\n13 31 103 301 310 130\nListing Mr. E's debts:\ntemplate B\n2400 1300 1800\nIf you remove\n*/\n</code></pre> <p>In some circumstances, you can lead the compiler to make the choice you want by suitably writing the function call. Consider Listing 8.15, which, by the way, eliminates the template prototype and places the template function definition at the top of the file</p> choicesTemplate.cpp - choosing a template. <pre><code>#include &lt;iostream&gt;\ntemplate &lt;class T&gt; // or template &lt;typename T&gt;\n\nT lesser(T a, T b) // #1\n{\n    return a &lt; b ? a : b;\n}\n\nint lesser(int a, int b) // #2\n{\n    a = a &lt; 0 ? -a : a;\n    b = b &lt; 0 ? -b : b;\n    return a &lt; b ? a : b;\n}\n\nint main()\n{\n    using namespace std;\n    int m = 20;\n    int n = -30;\n    double x = 15.5;\n    double y = 25.9;\n    cout &lt;&lt; lesser(m, n) &lt;&lt; endl;      // use #2\n    cout &lt;&lt; lesser(x, y) &lt;&lt; endl;      // use #1 with double\n    cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl;    // use #1 with int\n    cout &lt;&lt; lesser&lt;int&gt;(x, y) &lt;&lt; endl; // use #1 with int\n    return 0;\n}\n\n/*\n20\n15.5\n-30\n15\n*/\n</code></pre>"},{"location":"#the-decltype-keyword-c11","title":"The <code>decltype</code> Keyword (C++11)","text":"<p>It can be used in this way:</p> <pre><code>int x;\ndecltype(x) y; // make y the same type as x\n\n// The argument to decltype can be an expression, so in the ft() example, we could use\nthis code:\ndecltype(x + y) xpy; // make xpy the same type as x + y\nxpy = x + y;\n\n// Alternatively, we could combine these two statements into an initialization:\ndecltype(x + y) xpy = x + y;\n\n//--------\n// We can fix the ft() template this way:\ntemplate&lt;class T1, class T2&gt;\nvoid ft(T1 x, T2 y)\n{\n    ...\n    decltype(x + y) xpy = x + y;\n    ...\n}\n\n\n// Stage 1: If expression is an unparenthesized identifier (that is, no additional parentheses),\n// then var is of the same type as the identifier, including qualifiers such as const:\ndouble x = 5.5;\ndouble y = 7.9;\ndouble &amp;rx = x;\nconst double * pd;\ndecltype(x) w; // w is type double\ndecltype(rx) u = y; // u is type double &amp;\ndecltype(pd) v; // v is type const double *\n\n// Stage 2: If expression is a function call, then var has the type of the function\nreturn type:\nlong indeed(int);\ndecltype (indeed(3)) m; // m is type int\n\n// Stage 3: If expression is an lvalue, then var is a reference to the expression type.\n// This might seem to imply that earlier examples such as w should have been reference\n// types, given that w is an lvalue. However, keep in mind that case was already captured in\n// Stage 1. For this stage to apply, expression can\u2019t be an unparenthesized identifier. So\n// what can it be? One obvious possibility is a parenthesized identifier:\ndouble xx = 4.4;\ndecltype ((xx)) r2 = xx; // r2 is double &amp;\ndecltype(xx) w = xx; // w is double (Stage 1 match)\n\n// Stage 4: If none of the preceding special cases apply, var is of the same type as\n// expression:\nint j = 3;\nint &amp;k = j\nint &amp;n = j;\ndecltype(j+6) i1; // i1 type int\ndecltype(100L) i2; // i2 type long\ndecltype(k+n) i3; // i3 type int;\n</code></pre>"},{"location":"#alternative-function-syntax-c11-trailing-return-type","title":"Alternative Function Syntax (C++11 Trailing Return Type)","text":"<p>The decltype mechanism by itself leaves another related problem unsolved. Consider this incomplete template function:</p> <pre><code>template&lt;class T1, class T2&gt;\n?type? gt(T1 x, T2 y)\n{\n    ...\n    return x + y;\n}\n</code></pre> <p>C++11 allows a new syntax for declaring and defining functions. Here\u2019s how it works using built-in types.The prototype</p> <pre><code>double h(int x, float y);\n</code></pre> <p>can be written with this alternative syntax:</p> <pre><code>auto h(int x, float y) -&gt; double;\n</code></pre> <p>This moves the return type to after the parameter declarations.The combination -&gt; double is called a <code>trailing return type</code>.</p> <pre><code>template&lt;class T1, class T2&gt;\nauto gt(T1 x, T2 y) -&gt; decltype(x + y)\n{\n...\nreturn x + y;\n}\n</code></pre>"},{"location":"#chapter-9-memory-models-and-namespaces","title":"Chapter 9 Memory Models and Namespaces","text":"List of what you will learn  <pre><code>- Separate compilation of programs\n- Storage duration, scope, and linkage\n- Placement new\n- Namespaces\n</code></pre>"},{"location":"#separate-compilation","title":"Separate Compilation","text":"<p>Unix and Linux systems, for example, have make programs, which keep track of which files a program depends on and when they were last modified. If you run make, and it detects that you\u2019ve changed one or more source files since the last compilation, make remembers the proper steps needed to reconstitute the program. Most integrated development environments (IDEs), including Embarcadero C++ Builder, Microsoft Visual C++,Apple Xcode, and Freescale CodeWarrior, provide similar facilities with their Project menus.</p> <p><code>#include</code> - Instead of placing the structure declarations in each file, you can place them in a header file and then include that header file in each source code file.</p> <p>You can divide the original program into three parts:</p> <ul> <li>A header file that contains the structure declarations and prototypes for functions that use those structures</li> <li>A source code file that contains the code for the structure-related functions</li> <li>A source code file that contains the code that calls the structure-related functions</li> </ul> <p>Things commonly found in header files:</p> <ul> <li>Function prototypes</li> <li>Symbolic constants defined using <code>#define</code> or <code>const</code></li> <li>Structure declarations</li> <li>Class declarations</li> <li>Template declarations</li> <li>Inline functions</li> </ul> <p>It\u2019s okay to put structure declarations in a header file because they don\u2019t create variables;</p> <p><code>\"coordin.h\"</code> - if the filename is enclosed in double quotation marks, the compiler first looks at the current working directory or at the source code directory</p> <p><code>&lt;coordin.h&gt;</code> - filename is enclosed in angle brackets, the C++ compiler looks at the part of the host system\u2019s file system that holds the standard header files</p> coordin.h - structure templates and function prototypes. <pre><code>// coordin.h -- structure templates and function prototypes\n// structure templates\n\n#ifndef COORDIN_H_\n#define COORDIN_H_\n\nstruct polar\n{\n    double distance; // distance from origin\n    double angle;    // direction from origin\n};\n\nstruct rect\n{\n    double x; // horizontal distance from origin\n    double y; // vertical distance from origin\n};\n\n// prototypes\npolar rect_to_polar(rect xypos);\nvoid show_polar(polar dapos);\n\n#endif\n</code></pre>  Header File Management   You should include a header file just once in a file. That might seem to be an easy thing to remember, but it\u2019s possible to include a header file several times without knowing you did so. For example, you might use a header file that includes another header file. There\u2019s a standard C/C++ technique for avoiding multiple inclusions of header files. It\u2019s based on the preprocessor `#ifndef` (for if not defined) directive. A code segment like the following means \u201cprocess the statements between the `#ifndef` and #endif only if the name `COORDIN_H_` has not been defined previously by the preprocessor #define directive\u201d:  <pre><code>#ifndef COORDIN_H_\n...\n#endif\n</code></pre>  Normally, you use the #define statement to create symbolic constants, as in the following:  <pre><code>#define MAXIMUM 4096\n</code></pre>  But simply using `#define` with a name is enough to establish that a name is defined, as in the following:  <pre><code>#define COORDIN_H_\n</code></pre>  The technique that Listing 9.1 uses is to wrap the file contents in an #ifndef:  <pre><code>#ifndef COORDIN_H_\n#define COORDIN_H_\n// place include file contents here\n#endif\n</code></pre>  The first time the compiler encounters the file, the name `COORDIN_H_` should be undefined. (I chose a name based on the include filename, with a few underscore characters tossed in to create a name that is unlikely to be defined elsewhere.) That being the case, the compiler looks at the material between the #ifndef and the `#endif`, which is what you want. In the process of looking at the material, the compiler reads the line defining `COORDIN_H_`. If it then encounters a second inclusion of `coordin.h` in the same file, the compiler notes that `COORDIN_H_` is defined and skips to the line following the `#endif`. Note that this method doesn\u2019t keep the compiler from including a file twice. Instead, it makes the compiler ignore the contents of all but the first inclusion. Most of the standard C and C++ header files use this guarding scheme. Otherwise you might get the same structure defined twice in one file, and that will produce a compile error.   <p></p> <p>Link it <code>g++ .\\Notes\\C++PrimerPlus\\programs\\file1.cpp .\\Notes\\C++PrimerPlus\\programs\\file2.cpp</code></p> file1.cpp - example of a three-file program <pre><code>// file1.cpp -- example of a three-file program\n#include &lt;iostream&gt;\n#include \"coordin.h\" // structure templates, function prototypes\nusing namespace std;\nint main()\n{\n    rect rplace;\n    polar pplace;\n\n    cout &lt;&lt; \"Enter the x and y values: \";\n    while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y) // slick use of cin\n    {\n        pplace = rect_to_polar(rplace);\n        show_polar(pplace);\n        cout &lt;&lt; \"Next two numbers (q to quit): \";\n    }\n\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\n\n// g++ .\\Notes\\C++PrimerPlus\\programs\\file1.cpp .\\Notes\\C++PrimerPlus\\programs\\file2.cpp\n\n/*\nEnter the x and y values: 120 80\ndistance = 144.222, angle = 33.6901 degrees\nNext two numbers (q to quit): 120 50\ndistance = 130, angle = 22.6199 degrees\nNext two numbers (q to quit): q\n*/\n</code></pre> file2.cpp - contains functions called in file1.cpp <pre><code>// file2.cpp -- contains functions called in file1.cpp\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include \"coordin.h\" // structure templates, function prototypes\n// convert rectangular to polar coordinates\n\npolar rect_to_polar(rect xypos)\n{\n    using namespace std;\n    polar answer;\n    answer.distance =\n        sqrt(xypos.x * xypos.x + xypos.y * xypos.y);\n    answer.angle = atan2(xypos.y, xypos.x);\n    return answer; // returns a polar structure\n}\n\n// show polar coordinates, converting angle to degrees\nvoid show_polar(polar dapos)\n{\n    using namespace std;\n    const double Rad_to_deg = 57.29577951;\n    cout &lt;&lt; \"distance = \" &lt;&lt; dapos.distance;\n    cout &lt;&lt; \", angle = \" &lt;&lt; dapos.angle * Rad_to_deg;\n    cout &lt;&lt; \" degrees\\n\";\n}\n</code></pre> <p> </p> <p>C++ Standard uses the term <code>translation unit</code> instead of <code>file</code> in order to preserve greater generality; the file metaphor is not the only possible way to organize information for a computer. For simplicity, this book will use the term file, but feel free to translate that to <code>translation unit</code>.</p>  Multiple Library Linking        The C++ Standard allows each compiler designer the latitude to implement name decoration or mangling (see the sidebar \u201cWhat Is Name Decoration?\u201d in Chapter 8, \u201cAdventures in Functions\u201d) as it sees fit, so you should be aware that binary modules (object-code files) created with different compilers will, most likely, not link properly. That is, the two compilers will generate different decorated names for the same function. This name difference will prevent the linker from matching the function call generated by one compiler with the function definition generated by a second compiler. When attempting to link compiled modules, you should make sure that each object file or library was generated with the same compiler. If you are provided with the source code, you can usually resolve link errors by recompiling the source with your compiler.      <p></p>"},{"location":"#storage-duration-scope-and-linkage","title":"Storage Duration, Scope, and Linkage","text":"<p>memory. C++ uses three separate schemes (four under C++11) for storing data, and the schemes differ in how long they preserve data in memory:</p> <ul> <li>Automatic storage duration\u2014Variables declared inside a function definition\u2014 including function parameters\u2014have automatic storage duration.They are created when program execution enters the function or block in which they are defined, and the memory used for them is freed when execution leaves the function or block. C++ has two kinds of automatic storage duration variables.</li> <li>Static storage duration\u2014Variables defined outside a function definition or else by using the keyword <code>static</code> have static storage duration.They persist for the entire time a program is running. C++ has three kinds of static storage duration variables.</li> <li>Thread storage duration (C++11)\u2014These days multicore processors are common. These are CPUs that can handle several execution tasks simultaneously.This allows a program to split computations into separate threads that can be processed concurrently.Variables declared with the <code>thread_local</code> keyword have storage that persists for as long as the containing thread lasts.This book does not venture into concurrent programming.</li> <li>Dynamic storage duration\u2014Memory allocated by the <code>new</code> operator persists until it is freed with the <code>delete</code> operator or until the program ends, whichever comes first.This memory has dynamic storage duration and sometimes is termed the free store or the heap.</li> </ul>"},{"location":"#scope-and-linkage","title":"Scope and Linkage","text":"<p><code>Scope</code> describes how widely visible a name is in a file (translation unit). <code>Linkage</code> describes how a name can be shared in different units.</p> <p>A name with external linkage can be shared across files, and a name with internal linkage can be shared by functions within a single file. Names of automatic variables have no linkage because they are not shared. A C++ variable can have one of several scopes.A variable that has local scope (also termed block scope) is known only within the block in which it is defined.</p>"},{"location":"#automatic-storage-duration","title":"Automatic Storage Duration","text":"<p>Function parameters and variables declared inside a function have, by default, automatic storage duration. They also have local scope and no linkage.That is, if you declare a variable called texas in <code>main()</code> and you declare another variable with the same name in a function called <code>oil()</code>, you\u2019ve created two independent variables, each known only in the function in which it\u2019s defined. Anything you do to the texas in <code>oil()</code> has no effect on the texas in main(), and vice versa.</p> autoscp.cpp - illustrating scope of automatic variables <pre><code>// autoscp.cpp -- illustrating scope of automatic variables\n#include &lt;iostream&gt;\n\nvoid oil(int x);\n\nint main()\n{\n    using namespace std;\n\n    int texas = 31;\n    int year = 2011;\n    cout &lt;&lt; \"In main(), texas = \" &lt;&lt; texas &lt;&lt; \", &amp;texas = \";\n    cout &lt;&lt; &amp;texas &lt;&lt; endl;\n    cout &lt;&lt; \"In main(), year = \" &lt;&lt; year &lt;&lt; \", &amp;year = \";\n    cout &lt;&lt; &amp;year &lt;&lt; endl;\n    oil(texas);\n    cout &lt;&lt; \"In main(), texas = \" &lt;&lt; texas &lt;&lt; \", &amp;texas = \";\n    cout &lt;&lt; &amp;texas &lt;&lt; endl;\n    cout &lt;&lt; \"In main(), year = \" &lt;&lt; year &lt;&lt; \", &amp;year = \";\n    cout &lt;&lt; &amp;year &lt;&lt; endl;\n    return 0;\n}\n\nvoid oil(int x)\n{\n    using namespace std;\n    int texas = 5;\n\n    cout &lt;&lt; \"In oil(), texas = \" &lt;&lt; texas &lt;&lt; \", &amp;texas = \";\n    cout &lt;&lt; &amp;texas &lt;&lt; endl;\n    cout &lt;&lt; \"In oil(), x = \" &lt;&lt; x &lt;&lt; \", &amp;x = \";\n    cout &lt;&lt; &amp;x &lt;&lt; endl;\n    { // start a block\n        int texas = 113;\n        cout &lt;&lt; \"In block, texas = \" &lt;&lt; texas;\n        cout &lt;&lt; \", &amp;texas = \" &lt;&lt; &amp;texas &lt;&lt; endl;\n        cout &lt;&lt; \"In block, x = \" &lt;&lt; x &lt;&lt; \", &amp;x = \";\n        cout &lt;&lt; &amp;x &lt;&lt; endl;\n    } // end a block\n    cout &lt;&lt; \"Post-block texas = \" &lt;&lt; texas;\n    cout &lt;&lt; \", &amp;texas = \" &lt;&lt; &amp;texas &lt;&lt; endl;\n}\n\nIn main(), texas = 31, &amp;texas = 0012FED4\nIn main(), year = 2011, &amp;year = 0012FEC8\nIn oil(), texas = 5, &amp;texas = 0012FDE4\nIn oil(), x = 31, &amp;x = 0012FDF4\nIn block, texas = 113, &amp;texas = 0012FDD8\nIn block, x = 31, &amp;x = 0012FDF4\nPost-block texas = 5, &amp;texas = 0012FDE4\nIn main(), texas = 31, &amp;texas = 0012FED4\nIn main(), year = 2011, &amp;year = 0012FEC8\n</code></pre>  Changes to auto in C++11        In C++11, the keyword auto is used for automatic type deduction, as you have seen in Chapters 3, 7, and 8. But in C and in prior versions of C++, `auto` has an entirely different meaning. It\u2019s used to explicitly identify a variable as having automatic storage:  <pre><code>int froob(int n)\n{\n    auto float ford; // ford has automatic storage\n    ...\n}\n</code></pre>  Because programmers can use the `auto` keyword only with variables that are already automatic by default, they rarely bother using it. Its main function is to document that you really wanted to use a local automatic variable. In C++11, this usage no longer is valid. The people who prepare standards are reluctant to introduce new keywords because doing so might invalidate existing code that already uses that word for other purposes. In this case, it was felt that the old use of `auto` was rare enough that it was better to repurpose this keyword rather than introduce a new one.  <p></p>"},{"location":"#automatic-variables-and-the-stack","title":"Automatic Variables and the Stack","text":"<p>The usual means is to set aside a section of memory and treat it as a stack for managing the flow and ebb of variables. It\u2019s called a stack because new data is figuratively stacked atop old data (that is, at an adjacent location, not at the same location) and then removed from the stack when a program is finished with it.The default size of the stack depends on the implementation, but a compiler typically provides the option of changing the size.The program keeps track of the stack by using two pointers. One points to the base of the stack, where the memory set aside for the stack begins, and one points to the top of the stack, which is the next free memory location.When a function is called, its automatic variables are added to the stack, and the pointer to the top points to the next available free space following the variables</p> <p>A stack is a LIFO (last-in, first-out) design, meaning the last variables added to the stack are the first to go.The design simplifies argument passing</p>"},{"location":"#register-variables","title":"Register Variables","text":"<p>C originally introduced the <code>register</code> keyword to suggest that the compiler use a CPU register to store an automatic variable:</p> <pre><code>register int count_fast; // request for a register variable\n</code></pre> <p>The idea was that this would allow faster access to the variable. Prior to C++11, C++ used the keyword in the same fashion, except that as hardware and compilers developed in sophistication, the hint was generalized to mean that the variable was heavily used and perhaps the compiler could provide some sort of special treatment.</p> <p>With C++11, that hint is being deprecated, leaving <code>register</code> as just a way to explicitly identify a variable as being automatic.</p>"},{"location":"#static-duration-variables","title":"Static Duration Variables","text":"<p>storage duration variables with three kinds of linkage: external linkage (accessible across files), internal linkage (accessible to functions within a single file), and no linkage (accessible to just one function or to one block within a function). All three last for the duration of the program; they are less ephemeral than automatic variables. Because the number of static variables doesn\u2019t change as the program runs, the program doesn\u2019t need a special device such as a stack to manage them. Instead, the compiler allocates a fixed block of memory to hold all the static variables, and those variables stay present as long as the program executes. Also if you don\u2019t explicitly initialize a static variable, the compiler sets it to 0. Static arrays and structures have all the bits of each element or member set to 0 by default.</p> <p> </p>"},{"location":"#initializing-static-variables","title":"Initializing Static Variables","text":"<p>Static variables may be zero-initialized, they may undergo constant expression initialization, and they may undergo dynamic initialization.As you may have surmised, zero-initialization means setting the variable to the value zero</p> <p><code>Zero-initialization</code> and <code>constant-expression</code> initialization collectively are called <code>static initialization</code>. This means the variable is initialized when the compiler processes the file (or translation unit). Dynamic initialization means the variable is initialized later</p> <pre><code>#include &lt;cmath&gt;\nint x; // zero-initialization\nint y = 5; // constant-expression initialization\nlong z = 13 * 13; // constant-expression initialization\nconst double pi = 4.0 * atan(1.0); // dynamic initialization\n</code></pre> <p>C++11 introduces a new keyword, <code>constexpr</code>, to expand the options for creating constant expressions; this is one of the new C++11 features that this book does not pursue further</p>"},{"location":"#static-duration-external-linkage","title":"Static Duration, External Linkage","text":"<p>Variables with external linkage are often simply called <code>external variables</code> You can use an external variable in any function that follows the external variable\u2019s definition in the file.Thus, external variables are also termed global variables, in contrast to automatic variables, which are local variables.</p>"},{"location":"#the-one-definition-rule","title":"The One Definition Rule","text":"<p>On the one hand, an external variable has to be declared in each file that uses the variable. On the other hand, C++ has the \u201cone definition rule\u201d (also known as odr), which states that there can be only one definition of a variable. To satisfy these requirements, C++ has two kinds of variable declarations. One is the <code>defining declaration</code> or, simply, a <code>definition</code>. The second is the referencing declaration or, simply, a declaration. It does not cause storage to be allocated because it refers to an existing variable.</p> <p>A referencing declaration uses the keyword extern and does not provide initialization. Otherwise, a declaration is a definition and causes storage to be allocated:</p> <pre><code>double up; // definition, up is 0\nextern int blem; // blem defined elsewhere\nextern char gr = 'z'; // definition because initialized\n</code></pre> <p> </p> _ch9_external.cpp - external variables <pre><code>// external.cpp -- external variables\n// compile with support.cpp\n#include &lt;iostream&gt;\nusing namespace std;\n// external variable\ndouble warming = 0.3; // warming defined\n// function prototypes\nvoid update(double dt);\nvoid local();\n\nint main() // uses global variable\n{\n    cout &lt;&lt; \"Global warming is \" &lt;&lt; warming &lt;&lt; \" degrees.\\n\";\n    update(0.1); // call function to change warming\n    cout &lt;&lt; \"Global warming is \" &lt;&lt; warming &lt;&lt; \" degrees.\\n\";\n    local(); // call function with local warming\n    cout &lt;&lt; \"Global warming is \" &lt;&lt; warming &lt;&lt; \" degrees.\\n\";\n    return 0;\n}\n\n/*\nGlobal warming is 0.3 degrees.\nUpdating global warming to 0.4 degrees.\nGlobal warming is 0.4 degrees.\nLocal warming = 0.8 degrees.\nBut global warming = 0.4 degrees.\nGlobal warming is 0.4 degrees\n*/\n</code></pre> _ch9_support.cpp - use external variable <pre><code>// support.cpp -- use external variable\n// compile with external.cpp\n#include &lt;iostream&gt;\nextern double warming; // use warming from another file\n\n// function prototypes\nvoid update(double dt);\nvoid local();\n\nusing std::cout;\nvoid update(double dt) // modifies global variable\n{\n    extern double warming; // optional redeclaration\n    warming += dt;         // uses global warming\n    cout &lt;&lt; \"Updating global warming to \" &lt;&lt; warming;\n    cout &lt;&lt; \" degrees.\\n\";\n}\n\nvoid local() // uses local variable\n{\n    double warming = 0.8; // new variable hides external one\n    cout &lt;&lt; \"Local warming = \" &lt;&lt; warming &lt;&lt; \" degrees.\\n\";\n    // Access global variable with the\n    // scope resolution operator\n    cout &lt;&lt; \"But global warming = \" &lt;&lt; ::warming;\n    cout &lt;&lt; \" degrees.\\n\";\n}\n</code></pre>  Global Versus Local Variables       Now that you have a choice of using global or local variables, which should you use? At first, global variables have a seductive appeal\u2014because all functions have access to a global variable, you don\u2019t have to bother passing arguments. But this easy access has a heavy price: unreliable programs. Computing experience has shown that the better job your program does of isolating data from unnecessary access, the better job the program does in preserving the integrity of the data. Most often, you should use local variables and pass data to functions on a need-to-know basis rather than make data available indiscriminately by using global variables. As you will see, OOP takes this data isolation a step further. Global variables do have their uses, however. For example, you might have a block of data that\u2019s to be used by several functions, such as an array of month names or the atomic weights of the elements. The external storage class is particularly suited to representing constant data because you can use the keyword `const` to protect the data from change:  <pre><code>const char * const months[12] =\n{\n    \"January\", \"February\", \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\", \"September\", \"October\",\n    \"November\", \"December\"\n};\n</code></pre>  In this example, the first `const` protects the strings from change, and the second `const` makes sure that each pointer in the array remains pointing to the same string to which it pointed initially.  <p></p>"},{"location":"#static-duration-internal-linkage","title":"Static Duration, Internal Linkage","text":"<p>Applying the static modifier to a file-scope variable gives it internal linkage.The difference between internal linkage and external linkage becomes meaningful in multifile programs. In that context, a variable with internal linkage is local to the file that contains it. But a regular external variable has external linkage, meaning that it can be used in different files, as the previous example showed.</p> <p>Declaration of a static external variable that has the same name as an ordinary external variable declared in another file, the static version is the one in scope for that file:</p> _ch9_twofile1.cpp - variables with external and internal linkage <pre><code>// twofile1.cpp -- variables with external and internal linkage\n#include &lt;iostream&gt;     // to be compiled with two file2.cpp\nint tom = 3;            // external variable definition\nint dick = 30;          // external variable definition\nstatic int harry = 300; // static, internal linkage\n\n// function prototype\nvoid remote_access();\n\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"main() reports the following addresses:\\n\";\n    cout &lt;&lt; &amp;tom &lt;&lt; \" = &amp;tom, \" &lt;&lt; &amp;dick &lt;&lt; \" = &amp;dick, \";\n    cout &lt;&lt; &amp;harry &lt;&lt; \" = &amp;harry\\n\";\n    remote_access();\n    return 0;\n}\n\n/*\nmain() reports the following addresses:\n0x0041a020 = &amp;tom, 0x0041a024 = &amp;dick, 0x0041a028 = &amp;harry\nremote_access() reports the following addresses:\n0x0041a020 = &amp;tom, 0x0041a450 = &amp;dick, 0x0041a454 = &amp;harry\n*/\n</code></pre> _ch9_twofile2.cpp - variables with internal and external linkage <pre><code>// twofile2.cpp -- variables with internal and external linkage\n#include &lt;iostream&gt;\nextern int tom;       // tom defined elsewhere\nstatic int dick = 10; // overrides external dick\nint harry = 200;      // external variable definition,\n                      // no conflict with twofile1 harry\n\nvoid remote_access()\n{\n    using namespace std;\n    cout &lt;&lt; \"remote_access() reports the following addresses:\\n\";\n    cout &lt;&lt; &amp;tom &lt;&lt; \" = &amp;tom, \" &lt;&lt; &amp;dick &lt;&lt; \" = &amp;dick, \";\n    cout &lt;&lt; &amp;harry &lt;&lt; \" = &amp;harry\\n\";\n}\n</code></pre> <pre><code>// file1\nint errors = 20; // external declaration\n...\n---------------------------------------------\n// file2\nstatic int errors = 5; // known to file2 only\nvoid froobish()\n{\ncout &lt;&lt; errors; // uses errors defined in file2\n...\n</code></pre> <p>This doesn\u2019t violate the one definition rule because the keyword static establishes that the identifier errors has internal linkage, so no attempt is made to bring in an external definition.</p>"},{"location":"#static-storage-duration-no-linkage","title":"Static Storage Duration, No Linkage","text":"<p>You create such a variable by applying the static modifier to a variable defined inside a block.When you use it inside a block, static causes a local variable to have static storage duration.This means that even though the variable is known within that block, it exists even while the block is inactive.Thus a static local variable can preserve its value between function calls.</p> static.cpp - variables with external and internal linkage <pre><code>// static.cpp -- using a static local variable\n#include &lt;iostream&gt;\n// constants\nconst int ArSize = 10;\n\n// function prototype\nvoid strcount(const char *str);\n\nint main()\n{\n    using namespace std;\n    char input[ArSize];\n    char next;\n\n    cout &lt;&lt; \"Enter a line:\\n\";\n    cin.get(input, ArSize);\n    while (cin)\n    {\n        cin.get(next);\n        while (next != '\\n') // string didn't fit!\n            cin.get(next);   // dispose of remainder\n        strcount(input);\n        cout &lt;&lt; \"Enter next line (empty line to quit):\\n\";\n        cin.get(input, ArSize);\n    }\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\nvoid strcount(const char *str)\n{\n    using namespace std;\n    static int total = 0; // static local variable\n    int count = 0;        // automatic local variable\n\n    cout &lt;&lt; \"\\\"\" &lt;&lt; str &lt;&lt; \"\\\" contains \";\n    while (*str++) // go to end of string\n        count++;\n    total += count;\n    cout &lt;&lt; count &lt;&lt; \" characters\\n\";\n    cout &lt;&lt; total &lt;&lt; \" characters total\\n\";\n}\n\n/*\nEnter a line:\nnice pants\n\"nice pant\" contains 9 characters\n9 characters total\nEnter next line (empty line to quit):\nthanks\n\"thanks\" contains 6 characters\n15 characters total\nEnter next line (empty line to quit):\nparting is such sweet sorrow\n\"parting i\" contains 9 characters\n24 characters total\nEnter next line (empty line to quit):\nok\n\"ok\" contains 2 characters\n26 characters total\nEnter next line (empty line to quit):\n\nBye\n*/\n</code></pre>"},{"location":"#specifiers-and-qualifiers","title":"Specifiers and Qualifiers","text":"<p>Certain C++ keywords, called <code>storage class specifiers</code> and <code>cv-qualifiers</code>, provide additional information about storage. Here\u2019s a list of the storage class specifiers:</p> <pre><code>auto (eliminated as a specifier in C++11)\nregister\nstatic\nextern\nthread_local (added by C++11)\nmutable\n</code></pre> <p>A <code>thread_local</code> variable is to a thread much as a regular static variable is to the whole program.The keyword <code>mutable</code> is explained in terms of <code>const</code>, so let\u2019s look at the cv-qualifiers first before returning to <code>mutable</code>.</p>"},{"location":"#cv-qualifiers","title":"Cv-Qualifiers","text":"<pre><code>const\nvolatile\n</code></pre> <p>(As you may have guessed, cv stands for <code>const</code> and <code>volatile</code>.) The most commonly used cv-qualifier is <code>const</code>, and you\u2019ve already seen its purpose: It indicates that memory, after initialized, should not be altered by a program.</p> <p>The <code>volatile</code> keyword indicates that the value in a memory location can be altered even though nothing in the program code modifies the contents.</p>"},{"location":"#mutable","title":"<code>mutable</code>","text":"<pre><code>struct data\n{\n    char name[30];\n    mutable int accesses;\n    ...\n};\nconst data veep = {\"Claybourne Clodde\", 0, ... };\nstrcpy(veep.name, \"Joye Joux\"); // not allowed\nveep.accesses++; // allowed\n</code></pre> <p>The <code>const</code> qualifier to <code>veep</code> prevents a program from changing veep\u2019s members, but the <code>mutable</code> specifier to the <code>accesses</code> member shields <code>accesses</code> from that restriction. This book doesn\u2019t use <code>volatile</code> or mutable, but there is more to learn about const</p>"},{"location":"#more-about-const","title":"More About <code>const</code>","text":"<p>In C++ (but not C), the const modifier alters the default storage classes slightly.Whereas a global variable has external linkage by default, a const global variable has internal linkage by default.That is, C++ treats a global const definition, such as in the following code fragment, as if the static specifier had been used:</p> <pre><code>const int fingers = 10; // same as static const int fingers = 10;\nint main(void)\n{\n\n// extern would be required if const had external linkage\nextern const int fingers; // can't be initialized\nextern const char * warning;\n\n// If, for some reason, you want to make a constant have external linkage, you can use the\n// extern keyword to override the default internal linkage:\nextern const int states = 50; // definition with external linkage\n...\n</code></pre>  Where C++ Finds Functions   Suppose you call a function in a particular file in a program. Where does C++ look for the function definition? If the function prototype in that file indicates that the function is static, the compiler looks only in that file for the function definition. Otherwise, the compiler (and the linker, too) looks in all the program files. If it finds two definitions, the compiler sends you an error message because you can have only one definition for an external function. If it fails to find any definition in the files, the function then searches the libraries. This implies that if you define a function that has the same name as a library function, the compiler uses your version rather than the library version. (However, C++ reserves the names of the standard library functions, so you shouldn\u2019t reuse them.) Some compiler-linkers need explicit instructions to identify which libraries to search. **One definition rule** - use one definition for function.  <p></p>"},{"location":"#language-linking","title":"Language Linking","text":"<p>suppose you want to use a precompiled function from a C library in a C++ program? For example, suppose you have this code:</p> <pre><code>spiff(22); // want spiff(int) from a C library\n</code></pre> <p>Its hypothetical symbolic name in the C library file is <code>_spiff</code>, but for our hypothetical linker, the C++ look-up convention is to look for the symbolic name <code>_spiff_i</code>. To get around this problem, you can use the function prototype to indicate which protocol to use:</p> <pre><code>extern \"C\" void spiff(int); // use C protocol for name look-up\nextern void spoff(int); // use C++ protocol for name look-up\nextern \"C++\" void spaff(int); // use C++ protocol for name look-up```\n</code></pre>"},{"location":"#the-placement-new-operator","title":"The Placement <code>new</code> Operator","text":"<p>With <code>new</code> header file, you can create your own memory-management procedures or to deal with hardware that is accessed via a particular address or to construct objects in a particular memory location.</p> <pre><code>#include &lt;new&gt;\n\nstruct chaff\n{\n    char dross[20];\n    int slag;\n};\n\nchar buffer1[50];\nchar buffer2[500];\n\nint main()\n{\n    chaff *p1, *p2;\n    int *p3, *p4;\n    // first, the regular forms of new\n    p1 = new chaff; // place structure in heap\n    p3 = new int[20]; // place int array in heap\n    // now, the two forms of placement new\n    p2 = new (buffer1) chaff; // place structure in buffer1\n    p4 = new (buffer2) int[20]; // place int array in buffer2\n    ...\n\n// ----\n// Just as regular new invokes a new function with one argument, the \n// standard placement new invokes a new function with two arguments:\nint * pi = new int; // invokes new(sizeof(int))\nint * p2 = new(buffer) int; // invokes new(sizeof(int), buffer)\nint * p3 = new(buffer) int[40]; // invokes new(40*sizeof(int), buffer)\n</code></pre> newplace.cpp - using placement new <pre><code>#include &lt;iostream&gt;\n#include &lt;new&gt; // for placement new\n\nconst int BUF = 512;\nconst int N = 5;\nchar buffer[BUF]; // chunk of memory\n\nint main()\n{\n    using namespace std;\n    double *pd1, *pd2;\n    int i;\n    cout &lt;&lt; \"Calling new and placement new:\\n\";\n    pd1 = new double[N];          // use heap\n    pd2 = new (buffer) double[N]; // use buffer array\n    for (i = 0; i &lt; N; i++)\n        pd2[i] = pd1[i] = 1000 + 20.0 * i;\n    cout &lt;&lt; \"Memory addresses:\\n\"\n         &lt;&lt; \" heap: \" &lt;&lt; pd1\n         &lt;&lt; \" static: \" &lt;&lt; (void *)buffer &lt;&lt; endl;\n    cout &lt;&lt; \"Memory contents:\\n\";\n    for (i = 0; i &lt; N; i++)\n    {\n        cout &lt;&lt; pd1[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd1[i] &lt;&lt; \"; \";\n        cout &lt;&lt; pd2[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd2[i] &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nCalling new and placement new a second time:\\n\";\n    double *pd3, *pd4;\n    pd3 = new double[N];          // find new address\n    pd4 = new (buffer) double[N]; // overwrite old data\n    for (i = 0; i &lt; N; i++)\n        pd4[i] = pd3[i] = 1000 + 40.0 * i;\n    cout &lt;&lt; \"Memory contents:\\n\";\n    for (i = 0; i &lt; N; i++)\n    {\n        cout &lt;&lt; pd3[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd3[i] &lt;&lt; \"; \";\n        cout &lt;&lt; pd4[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd4[i] &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nCalling new and placement new a third time:\\n\";\n    delete[] pd1;\n    pd1 = new double[N];\n    pd2 = new (buffer + N * sizeof(double)) double[N];\n    for (i = 0; i &lt; N; i++)\n        pd2[i] = pd1[i] = 1000 + 60.0 * i;\n    cout &lt;&lt; \"Memory contents:\\n\";\n    for (i = 0; i &lt; N; i++)\n    {\n        cout &lt;&lt; pd1[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd1[i] &lt;&lt; \"; \";\n        cout &lt;&lt; pd2[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd2[i] &lt;&lt; endl;\n    }\n\n    delete[] pd1;\n    delete[] pd3;\n    return 0;\n}\n\n\n/*\nCalling new and placement new:\nMemory addresses:\n    heap: 006E4AB0 static: 00FD9138\nMemory contents:\n1000 at 006E4AB0; 1000 at 00FD9138\n1020 at 006E4AB8; 1020 at 00FD9140\n1040 at 006E4AC0; 1040 at 00FD9148\n1060 at 006E4AC8; 1060 at 00FD9150\n1080 at 006E4AD0; 1080 at 00FD9158\n\nCalling new and placement new a second time:\nMemory contents:\n1000 at 006E4B68; 1000 at 00FD9138\n1040 at 006E4B70; 1040 at 00FD9140\n1080 at 006E4B78; 1080 at 00FD9148\n1120 at 006E4B80; 1120 at 00FD9150\n1160 at 006E4B88; 1160 at 00FD9158\n\nCalling new and placement new a third time:\nMemory contents:\n1000 at 006E4AB0; 1000 at 00FD9160\n1060 at 006E4AB8; 1060 at 00FD9168\n1120 at 006E4AC0; 1120 at 00FD9170\n1180 at 006E4AC8; 1180 at 00FD9178\n1240 at 006E4AD0; 1240 at 00FD9180\n*/\n</code></pre>"},{"location":"#namespaces","title":"Namespaces","text":"<p>You might want the <code>List</code> class from one library and the <code>Tree</code> from the other, and each might expect its own version of Node. Such conflicts are termed <code>namespace problems</code>.</p> <p><code>declarative region</code> - region in which declarations can be made <code>potential scope</code> - for a variable it begins at its point of declaration and extends to the end of its declarative region. So the potential scope is more limited than the declarative region because you can\u2019t use a variable above the point where it is first defined. However, a variable might not be visible everywhere in its potential scope. <code>scope</code> - The portion of the program that can actually see the variable</p>"},{"location":"#traditional-c-namespaces","title":"Traditional C++ Namespaces","text":"<p>C++\u2019s rules about global and local variables define a kind of namespace hierarchy. Each declarative region can declare names that are independent of names declared in other declarative regions. A local variable declared in one function doesn\u2019t conflict with a local variable declared in a second function.</p>"},{"location":"#new-namespace-features","title":"New Namespace Features","text":"<p>C++ now adds the ability to create named namespaces by defining a new kind of declarative region, one whose main purpose is to provide an area in which to declare names.</p> <p>New keyword <code>namespace</code> to create two namespaces, <code>Jack</code> and <code>Jill</code>:</p> <pre><code>namespace Jack {\n    double pail;    // variable declaration\n    void fetch();   // function prototype\n    int pal;        // variable declaration\n    struct Well { ... }; // structure declaration\n}\n\nnamespace Jill {\n    double bucket(double n) { ... } // function definition\n    double fetch;   // variable declaration\n    int pal;        // variable declaration\n    struct Hill { ... }; // structure declaration\n}\n</code></pre> <p>The simplest way is to use <code>::</code>, the <code>scope-resolution operator</code>, to qualify a name with its namespace:</p> <pre><code>Jack::pail = 12.34; // use a variable\nJill::Hill mole;    // create a type Hill structure\nJack::fetch();      // use a function\n</code></pre> <p>An unadorned name, such as <code>pail</code>, is termed the <code>unqualified name</code>, whereas a name with the namespace, as in <code>Jack::pail</code>, is termed a <code>qualified name</code>.</p> <p>One thing to keep in mind about using directives and using declarations is that they increase the possibility of name conflicts</p> <pre><code>using jack::pal;\nusing jill::pal;\npal = 4; // which one? now have a conflict\n</code></pre>"},{"location":"#using-declarations-and-using-directives","title":"<code>using</code> Declarations and <code>using</code> Directives","text":"<p>A <code>using</code> declaration, then, makes a single name available. In contrast, the <code>using</code> directive makes all the names available</p> <p>Having to qualify names every time they are used is not always an appealing prospect, so C++ provides two mechanisms\u2014the <code>using declaration</code> and the <code>using directive</code> \u2014 to simplify <code>using</code> namespace names.</p> <p><code>using</code> directive in a function treats the namespace names as being declared outside the function, it doesn\u2019t make those names available to other functions in the file.</p>"},{"location":"#using-declaration","title":"<code>using</code> Declaration","text":"<p>For example, the using declaration of <code>Jill::fetch</code> in <code>main()</code> adds fetch to the declarative region defined by <code>main()</code>.</p> <p>After making this declaration, you can use the name <code>fetch</code> instead of <code>Jill::fetch</code>.</p> <pre><code>namespace Jill {\n    double bucket(double n) { ... }\n    double fetch;\n    struct Hill { ... };\n}\nchar fetch;\nint main()\n{\nusing Jill::fetch;  // put fetch into local namespace\n    double fetch;   // Error! Already have a local fetch\n    cin &gt;&gt; fetch;   // read a value into Jill::fetch\n    cin &gt;&gt; ::fetch; // read a value into global fetch\n    ...\n}\n</code></pre>"},{"location":"#using-directive","title":"<code>using</code> Directive","text":"<pre><code>using namespace Jack; // make all the names in Jack available\n</code></pre>"},{"location":"#more-namespace-features","title":"More Namespace Features","text":"<p>You can nest namespace declarations, like this:</p> <pre><code>namespace elements\n{\n    namespace fire\n    {\n        int flame;\n        ...\n    }\n    float water;\n}\n</code></pre> <p>Also you can use using directives and using declarations inside namespaces, like this:</p> <pre><code>namespace myth\n{\n    using Jill::fetch;\n    using namespace elements;\n    using std::cout;\n    using std::cin;\n}\n</code></pre> <p>Suppose you want to access <code>Jill::fetch</code>. Because <code>Jill::fetch</code> is now part of the <code>myth</code> namespace, where it can be called <code>fetch</code>, you can access it this way:</p> <pre><code>std::cin &gt;&gt; myth::fetch;\nstd::cout &lt;&lt; Jill::fetch; // display value read into myth::fetch\n</code></pre> <p><code>unnamed namespace</code>:</p> <pre><code>namespace // unnamed namespace\n{\n    int ice; // internal linkage\n    int bandycoot;\n}\n</code></pre> <p>This code behaves as if it were followed by a using directive; that is, the names declared in this namespace are in potential scope until the end of the declarative region that contains the unnamed namespace</p>"},{"location":"#namespaces-program-example","title":"Namespace's Program Example","text":"Explanation:   The first file in this example (see Listing 9.11) is a header file that contains some items normally found in header files\u2014constants, structure definitions, and function prototypes. In this case, the items are placed in two namespaces.The first namespace, pers, contains a definition of a Person structure, plus prototypes for a function that fills a structure with a person\u2019s name and a function that displays the structure\u2019s contents.The second namespace, debts, defines a structure for storing the name of a person and the amount of money owed to that person.This structure uses the Person structure, so the debts namespace has a using directive to make the names in the pers namespace available in the debts namespace.The debts namespace also contains some prototypes.  The second file in this example (see Listing 9.12) follows the usual pattern of having a source code file provide definitions for functions prototyped in a header file.The function names, which are declared in a namespace, have namespace scope, so the definitions need to be in the same namespace as the declarations.This is where the open nature of namespaces comes in handy.The original namespaces are brought in by including namesp.h (refer to Listing 9.11).The file then adds the function definitions to the two namespaces, as shown in Listing 9.12.Also the namesp.cpp file illustrates bringing in elements of the std namespace with the using declaration and the scope-resolution operator.  Finally, the third file of this program (see Listing 9.13) is a source code file that uses the structures and functions declared and defined in the namespaces. Listing 9.13 shows several methods of making the namespace identifiers available.   namesp.h <pre><code>// namesp.h\n#include &lt;string&gt;\n\n// create the pers and debts namespaces\nnamespace pers\n{\n    struct Person\n    {\n        std::string fname;\n        std::string lname;\n    };\n    void getPerson(Person &amp;);\n    void showPerson(const Person &amp;);\n}\n\nnamespace debts\n{\n    using namespace pers;\n    struct Debt\n    {\n        Person name;\n        double amount;\n    };\n    void getDebt(Debt &amp;);\n    void showDebt(const Debt &amp;);\n    double sumDebts(const Debt ar[], int n);\n}\n</code></pre> namesp.cpp - namespaces <pre><code>// namesp.cpp -- namespaces\n#include &lt;iostream&gt;\n#include \"namesp.h\"\n\nnamespace pers\n{\n    using std::cin;\n    using std::cout;\n    void getPerson(Person &amp;rp)\n    {\n        cout &lt;&lt; \"Enter first name: \";\n        cin &gt;&gt; rp.fname;\n        cout &lt;&lt; \"Enter last name: \";\n        cin &gt;&gt; rp.lname;\n    }\n    void showPerson(const Person &amp;rp)\n    {\n        std::cout &lt;&lt; rp.lname &lt;&lt; \", \" &lt;&lt; rp.fname;\n    }\n}\n\nnamespace debts\n{\n    void getDebt(Debt &amp;rd)\n    {\n        getPerson(rd.name);\n        std::cout &lt;&lt; \"Enter debt: \";\n        std::cin &gt;&gt; rd.amount;\n    }\n    void showDebt(const Debt &amp;rd)\n    {\n        showPerson(rd.name);\n        std::cout &lt;&lt; \": $\" &lt;&lt; rd.amount &lt;&lt; std::endl;\n    }\n    double sumDebts(const Debt ar[], int n)\n    {\n        double total = 0;\n        for (int i = 0; i &lt; n; i++)\n            total += ar[i].amount;\n        return total;\n    }\n}\n</code></pre> usenmsp.cpp - using namespaces <pre><code>// usenmsp.cpp -- using namespaces\n#include &lt;iostream&gt;\n#include \"namesp.h\"\n\nvoid other(void);\nvoid another(void);\n\nint main(void)\n{\n    using debts::Debt;\n    using debts::showDebt;\n    Debt golf = {{\"Benny\", \"Goatsniff\"}, 120.0};\n    showDebt(golf);\n    other();\n    another();\n    return 0;\n}\n\nvoid other(void)\n{\n    using std::cout;\n    using std::endl;\n    using namespace debts;\n    Person dg = {\"Doodles\", \"Glister\"};\n    showPerson(dg);\n    cout &lt;&lt; endl;\n    Debt zippy[3];\n    int i;\n    for (i = 0; i &lt; 3; i++)\n        getDebt(zippy[i]);\n    for (i = 0; i &lt; 3; i++)\n        showDebt(zippy[i]);\n    cout &lt;&lt; \"Total debt: $\" &lt;&lt; sumDebts(zippy, 3) &lt;&lt; endl;\n    return;\n}\n\nvoid another(void)\n{\n    using pers::Person;\n    Person collector = {\"Milo\", \"Rightshift\"};\n    pers::showPerson(collector);\n    std::cout &lt;&lt; std::endl;\n}\n\n/*\nGoatsniff, Benny: $120\nGlister, Doodles\nEnter first name: Arabella\nEnter last name: Binx\nEnter debt: 100\nEnter first name: Cleve\nEnter last name: Delaproux\nEnter debt: 120\nEnter first name: Eddie\nEnter last name: Fiotox\nEnter debt: 200\nBinx, Arabella: $100\nDelaproux, Cleve: $120\nFiotox, Eddie: $200\nTotal debt: $420\nRightshift, Milo\n*/\n</code></pre>"},{"location":"#namespaces-using-guidlines","title":"Namespace's using guidlines","text":"<ul> <li>Use variables in a named namespace instead of using external global variables.</li> <li>Use variables in an unnamed namespace instead of using static global variables.</li> <li>If you develop a library of functions or classes, place them in a namespace. Indeed, C++ currently already calls for placing standard library functions in a namespace called std.This extends to functions brought in from C. For example, the <code>math.c</code> header file, which is C-compatible, doesn\u2019t use namespaces, but the C++ <code>cmath</code> header file should place the various math library functions in <code>the</code> std namespace.</li> <li>Use the <code>using</code> directive only as a temporary means of converting old code to namespace usage.</li> <li>Don\u2019t use <code>using</code> directives in header files; for one thing, doing so conceals which names are being made available.Also the ordering of header files may affect behavior. If you use a <code>using</code> directive, place it after all the preprocessor <code>#include</code> directives.</li> <li>Preferentially import names by using the scope-resolution operator or a <code>using</code> declaration.</li> <li>Preferentially use local scope instead of global scope for <code>using</code> declarations.</li> </ul> <p>Bear in mind that the main motivation for using namespaces is to simplify management of large programming projects. For simple, one-file programs, using a <code>using</code> directive is no great sin.</p>"},{"location":"#chapter-10","title":"Chapter 10","text":"List of what you will learn  <pre><code> - Procedural and object-oriented programming\n - The concept of classes\n - How to define and implement a class\n - Public and private class access\n - Class data members\n - Class methods (also called class function members)\n - Creating and using class objects\n - Class constructors and destructors\n - const member functions\n - The this pointer\n - Creating arrays of objects\n - Class scope\n - Abstract data types\n</code></pre> <p>Object-oriented programming (OOP) is a particular conceptual approach to designing programs, and C++ has enhanced C with features that ease the way to applying that approach.The following are the most important OOP features:</p> <ul> <li>Abstraction</li> <li>Encapsulation and data hiding</li> <li>Polymorphism</li> <li>Inheritance</li> <li>Reusability of code</li> </ul>"},{"location":"#abstraction-and-classes","title":"Abstraction and Classes","text":"<p>Abstraction is the crucial step of representing information in terms of its interface with the user. That is, you abstract the essential operational features of a problem and express a solution in those terms. In the softball statistics example, the interface describes how the user initializes, updates, and displays the data. From abstraction, it is a short step to the user-defined type, which in C++ is a class design that implements the abstract interface</p> <p>Basic data type does three things:</p> <ul> <li>It determines how much memory is needed for a data object.</li> <li>It determines how the bits in memory are interpreted. (A long and a float might use the same number of bits in memory, but they are translated into numeric values differently.)</li> <li>It determines what operations, or methods, can be performed using the data object.</li> </ul> <p><code>class</code> is a C++ vehicle for translating an abstraction to a user-defined type. It combines data representation and methods for manipulating that data into one neat package.</p> <p><code>Interface</code> - shared framework for interactions between two systems\u2014for instance, between a computer and a printer or between a user and a computer program.</p>"},{"location":"#access-control","title":"Access Control","text":"<p>Also new are the keywords private and public. These labels describe access control for class members.Any program that uses an object of a particular class can access the public portions directly. A program can access the private members of an object only by using the public member functions. This insulation of data from direct access by a pro- gram is called <code>data hiding</code></p>"},{"location":"#implementing-class-member-functions","title":"Implementing Class Member Functions","text":"<p>Member function definitions are much like regular function definitions. Each has a function header and a function body. Member function definitions can have return types and arguments. But they also have two special characteristics:</p> <ul> <li>When you define a member function, you use the scope-resolution operator (::) to identify the class to which the function belongs.</li> <li>Class methods can access the private components of the class.</li> </ul> <p>This notation means you are defining the <code>update()</code> function that is a member of the <code>Stock</code> class:</p> <pre><code>void Stock::update(double price)\n</code></pre> <p>Method can access the private members of a class.</p> <p>Any function with a definition in the class declaration automatically becomes an inline function.</p> <p>You can define a member function outside the class declaration and still make it inline.To do so, you just use the inline qualifier</p> <p>-- 001 png </p>  The Client/Server model   OOP programmers often discuss program design in terms of a client/server model. In this conceptualization, the client is a program that uses the class. The class declaration, includ- ing the class methods, constitute the server, which is a resource that is available to the pro- grams that need it. The client uses the server through the publicly defined interface only. This means that the client\u2019s only responsibility, and, by extension, the client\u2019s programmer\u2019s only responsibility, is to know that interface. The server\u2019s responsibility, and, by extension, the server\u2019s designer\u2019s responsibility, is to see that the server reliably and accurately per- forms according to that interface.   <p>Change of precision for vars</p> <pre><code>void Stock::show()\n{\n    using std::cout;\n    using std::ios_base;\n\n    // set format to #.###\n    ios_base::fmtflags orig =\n    cout.setf(ios_base::fixed, ios_base::floatfield);\n    std::streamsize prec = cout.precision(3);\n    cout &lt;&lt; \"Company: \" &lt;&lt; company\n    &lt;&lt; \" Shares: \" &lt;&lt; shares &lt;&lt; \u2018\\n\u2019;\n    cout &lt;&lt; \" Share Price: $\" &lt;&lt; share_val;\n\n    // set format to #.##\n    cout.precision(2);\n    cout &lt;&lt; \" Total Worth: $\" &lt;&lt; total_val &lt;&lt; \u2018\\n\u2019;\n\n    // restore original format\n    cout.setf(orig, ios_base::floatfield);\n    cout.precision(prec);\n}\n</code></pre>"},{"location":"#class-constructors-and-destructors","title":"Class Constructors and Destructors","text":"<p>you need to devise an appropriate member function if you\u2019re to suc- ceed in initializing an object. (You could initialize a class object as just shown if you made the data members public instead of private, but making the data public goes against one of the main justifications for using classes: data hiding.)</p> <p>C++ uses a class constructor whenever you create an object of that class, even when you use new for dynamic memory allocation. Here\u2019s how to use the constructor with new:</p> <pre><code>Stock *pstock = new Stock(\"Electroshock Games\", 18, 19.0);\n</code></pre> <p>A <code>default constructor</code> is a constructor that is used to create an object when you don\u2019t provide explicit initialization values.That is, it\u2019s a constructor used for declarations like this:</p> <pre><code>Stock fluffy_the_cat;\n// uses the default constructor\n</code></pre> <p>The <code>destructor</code> should clean up any debris, so it actually serves a useful purpose. For example, if your constructor uses <code>new</code> to allocate memory, the <code>destructor</code> should use delete to free that memory.</p> <p>A destructor must have no arguments. Thus, the prototype for a Stock destructor must be this:</p> <pre><code>~Stock();\n</code></pre> <p>Because a Stock destructor has no vital duties, you can code it as a do-nothing function:</p> <pre><code>Stock::~Stock()\n{\n}\n</code></pre>  Member Names and Parameter Names  Often those new to constructors try to use the class member names as parameter names in the constructor, as in this example:  <pre><code>// NO!\nStock::Stock(const string &amp; company, long shares, double share_val)\n{...}\n</code></pre>  This is wrong. The constructor arguments don\u2019t represent the class members; they repre- sent values that are assigned to the class members. Thus, they must have distinct names, or you end up with confusing code like this:  <pre><code>shares = shares;\n</code></pre> stock10.cpp - Implementation of a Stock class program file <pre><code>// stock10.cpp -- Stock class with constructors, destructor added\n#include &lt;iostream&gt;\n#include \"stock10.h\"\n// constructors (verbose versions)\nStock::Stock()\n// default constructor\n{\n    std::cout &lt;&lt; \"Default constructor called\\n\";\n    company = \"no name\";\n    shares = 0;\n    share_val = 0.0;\n    total_val = 0.0;\n}\nStock::Stock(const std::string &amp;co, long n, double pr)\n{\n    std::cout &lt;&lt; \"Constructor using \" &lt;&lt; co &lt;&lt; \" called\\n\";\n    company = co;\n    if (n &lt; 0)\n    {\n        std::cout &lt;&lt; \"Number of shares can\u2019t be negative; \"\n                  &lt;&lt; company &lt;&lt; \" shares set to 0.\\n\";\n        shares = 0;\n    }\n    else\n        shares = n;\n    share_val = pr;\n    set_tot();\n}\n// class destructor\nStock::~Stock()\n// verbose class destructor\n{\n    std::cout &lt;&lt; \"Bye, \" &lt;&lt; company &lt;&lt; \"!\\n\";\n}\n// other methods\nvoid Stock::buy(long num, double price)\n{\n    if (num &lt; 0)\n    {\n        std::cout &lt;&lt; \"Number of shares purchased can\u2019t be negative. \"\n\n                  &lt;&lt; \"Transaction is aborted.\\n\";\n    }\n    else\n    {\n        shares += num;\n        share_val = price;\n        set_tot();\n    }\n}\nvoid Stock::sell(long num, double price)\n{\n    using std::cout;\n    if (num &lt; 0)\n    {\n        cout &lt;&lt; \"Number of shares sold can\u2019t be negative. \"\n             &lt;&lt; \"Transaction is aborted.\\n\";\n    }\n    else if (num &gt; shares)\n    {\n        cout &lt;&lt; \"You can\u2019t sell more than you have! \"\n             &lt;&lt; \"Transaction is aborted.\\n\";\n    }\n    else\n    {\n        shares -= num;\n        share_val = price;\n        set_tot();\n    }\n}\nvoid Stock::update(double price)\n{\n    share_val = price;\n    set_tot();\n}\nvoid Stock::show()\n{\n    using std::cout;\n    using std::ios_base;\n    // set format to #.###\n    ios_base::fmtflags orig =\n        cout.setf(ios_base::fixed, ios_base::floatfield);\n    std::streamsize prec = cout.precision(3);\n    cout &lt;&lt; \"Company: \" &lt;&lt; company\n\n         &lt;&lt; \" Shares: \" &lt;&lt; shares &lt;&lt; \u2018\\n\u2019;\n    cout &lt;&lt; \" Share Price: $\" &lt;&lt; share_val;\n    // set format to #.##\n    cout.precision(2);\n    cout &lt;&lt; \" Total Worth: $\" &lt;&lt; total_val &lt;&lt; \u2018\\n\u2019;\n    // restore original format\n    cout.setf(orig, ios_base::floatfield);\n    cout.precision(prec);\n}\n</code></pre> stock10.h -- Stock class declaration with constructors, destructor added <pre><code>// stock10.h -- Stock class declaration with constructors, destructor added\n#ifndef STOCK10_H_\n#define STOCK01_H_\n#include &lt;string&gt;\nclass Stock\n{\nprivate:\n    std::string company;\n    long shares;\n    double share_val;\n    double total_val;\n    void set_tot() { total_val = shares * share_val; }\n\npublic:\n    // two constructors\n    Stock(); // default constructor\n    Stock(const std::string &amp;co, long n = 0, double pr = 0.0);\n    ~Stock(); // noisy destructor\n    void buy(long num, double price);\n    void sell(long num, double price);\n    void update(double price);\n    void show();\n};\n#endif\n</code></pre> usestock1.cpp - Client file <pre><code>// usestok1.cpp -- using the Stock class\n// compile with stock10.cpp\n#include &lt;iostream&gt;\n#include \"stock10.h\"\n\nint main()\n{\n    {\n        using std::cout;\n        cout &lt;&lt; \"Using constructors to create new objects\\n\";\n        Stock stock1(\"NanoSmart\", 12, 20.0);\n        // syntax 1\n        stock1.show();\n        Stock stock2 = Stock(\"Boffo Objects\", 2, 2.0); // syntax 2\n        stock2.show();\n        cout &lt;&lt; \"Assigning stock1 to stock2:\\n\";\n        stock2 = stock1;\n        cout &lt;&lt; \"Listing stock1 and stock2:\\n\";\n        stock1.show();\n        stock2.show();\n        cout &lt;&lt; \"Using a constructor to reset an object\\n\";\n        stock1 = Stock(\"Nifty Foods\", 10, 50.0);\n        // temp object\n        cout &lt;&lt; \"Revised stock1:\\n\";\n        stock1.show();\n        cout &lt;&lt; \"Done\\n\";\n    }\n    return 0;\n}\n</code></pre>  Note   You may have noticed that `Client file` has an extra brace at the beginning and near the end of main(). Automatic variables such as stock1 and stock2 expire when the program exits the block that contains their definitions. Without the extra braces, that block would be the body of main(), so the destructors would not be called until after main() completed execu- tion. In a windowing environment, this would mean that the window would close before the last two destructor calls, preventing you from seeing the last two messages. But with the braces, the last two destructor calls occur before the return statement is reached, so the messages are displayed."},{"location":"#c11-list-initialization","title":"C++11 List Initialization","text":"<p>With C++11, can you use the list-initialization syntax with classes? Yes, you can, providing the brace contents match the argument list of a constructor:</p> <pre><code>Stock hot_tip = {\"Derivatives Plus Plus\", 100, 45.0};\nStock jock {\"Sport Age Storage, Inc\"};\nStock temp {};\n</code></pre> <p>The braced lists in the first two declarations match the following constructor: Therefore, that constructor will be used to create the two objects.</p> <pre><code>Stock::Stock(const std::string &amp; co, long n = 0, double pr = 0.0);\n</code></pre>"},{"location":"#const-member-functions","title":"const Member Functions","text":"<p>Consider the following code snippet:</p> <pre><code>const Stock land = Stock(\"Kludgehorn Properties\");\nland.show();\n</code></pre> <p>With current C++, the compiler should object to the second line.Why? Because the code for show() fails to guarantee that it won\u2019t modify the invoking object, which, because it is const, should not be altered.</p> <p>That is, the show() declaration should look like this:</p> <pre><code>void show() const;          // promises not to change invoking object\n</code></pre> <p>Similarly, the beginning of the function definition should look like this:</p> <pre><code>void stock::show() const    // promises not to change invoking object\n</code></pre> <p>Class functions declared and defined this way are called const member functions.</p>"},{"location":"#the-this-pointer","title":"The <code>this</code> Pointer","text":"<p>Suppose, then, that you want to compare the Stock objects stock1 and stock2 and assign the one with the greater total value to the object top.You can use either of the fol- lowing statements to do so:</p> <pre><code>top = stock1.topval(stock2);\ntop = stock2.topval(stock1);\n</code></pre> <p>Here\u2019s a partial implementation that highlights the problem:</p> <pre><code>const Stock &amp; Stock::topval(const Stock &amp; s) const\n{\n    if (s.total_val &gt; total_val)\n        return s;       // argument object\n    else\n        return ?????;   // invoking object -&gt; should be *this\n}\n</code></pre> <p><code>*this</code> is as an alias for the invoking object. The fact that the return type is a reference means that the returned object is the invoking object itself rather than a copy passed by the return mechanism.</p>"},{"location":"#an-array-of-objects","title":"An Array of Objects","text":"<pre><code>Stock mystuff[4]; // creates an array of 4 Stock object\nconst Stock * tops = mystuff[2].topval(mystuff[1]);\n    // compare 3rd and 2nd elements and set tops\n    // to point at the one with a higher total value\n\n    // You can use a constructor to initialize the array elements\nconst int STKS = 4;\nStock stocks[STKS] = {\n    Stock(\"NanoSmart\", 12.5, 20),\n    Stock(\"Boffo Objects\", 200, 2.0),\n    Stock(\"Monolithic Obelisks\", 130, 3.25),\n    Stock(\"Fleep Enterprises\", 60, 6.5)\n};\n</code></pre>"},{"location":"#abstract-data-types","title":"Abstract Data Types","text":"<p>Using classes is a good way to implement what computer scientists describe as abstract data types (ADTs) ADT describes a data type in a general fashion without bringing in language or implementa- tion details.</p> <pre><code>./programs/\n\n# str 447 Begin (ch 9) 501 -&gt; 497 Summary \n# Chapter 9 Review : 7\nChapter 9 Exercises: 4\n\nstr 505 Begin (ch 10) -&gt; 557 Summary \nChapter 10 Review : 10\nChapter 10 Exercises: 8\n\nstr 563 Begin (ch 11) -&gt; 621 Summary \nChapter 11 Review : 7\nChapter 11 Exercises: 7\n\nch 12 - dynamic memory\nch 13 - class inheritance \nch 14 - reusing code in c++ \nch 15 - friends, exemptions, and more\nch 16 - string class and STL \nch 17 - input, output and files \nch 18 - the new c++ standard\n\n\n## Chapter 4\n\n&lt;details&gt;&lt;summary&gt;\n        List of what you will learn\n&lt;/summary&gt;\n\n```cpp\n</code></pre>"},{"location":"#chapter-review","title":"Chapter Review","text":"<p>Notes\\C++PrimerPlus\\exercises\\</p>  !!!!!Question!!!!!  !!!!!Answer!!!!!"},{"location":"#programming-exercises","title":"Programming Exercises","text":""},{"location":"exercises/","title":"Exercises","text":"<p>Collapse All/Expand All Code Collapse All</p>"},{"location":"exercises/#chapter-2-programming-exercises","title":"Chapter 2 Programming Exercises","text":"<p>1 - Write a C++ program that displays your name and address (or if you value your privacy,a fictitious name and address).</p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;                     // make definitions visible\n    cout &lt;&lt; \"Name: Deimos\\n\";\n    cout &lt;&lt; \"Country: Poland\\n\";\n    cout &lt;&lt; \"City: Warsaw\";\n    cout &lt;&lt; endl;                            // start a new line\n    return 0;                                // terminate main()\n} // end of function body\n</code></pre> <p>2 - Write a C++ program that asks for a distance in furlongs and converts it to yards. (One furlong is 220 yards.)</p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;                     // make definitions visible\n\n    float iFurlongs = 0;                     // declare variables\n    float iYards = 0;\n\n    cout &lt;&lt; \"Program converting distance from furlong to yards\\n\";\n    cout &lt;&lt; \"1 furlong = 220 yards\\n\\n\";\n    cout &lt;&lt; \"Enter the distance in furlongs: \";\n\n    cin &gt;&gt; iFurlongs;                        // read input\n\n    cout &lt;&lt; iFurlongs &lt;&lt; \" furlongs = \" &lt;&lt; iFurlongs * 220 &lt;&lt; \" yards\";\n\n    cout &lt;&lt; endl;                            // start a new line\n    return 0;                                // terminate main()\n} // end of function body\n</code></pre> <p>3 - Write a C++ program that uses three user-defined functions (counting <code>main()</code> as one) and produces the following output:</p> <pre><code>Three blind mice\nThree blind mice\nSee how they run\nSee how they run\n</code></pre> <p>One function,called two times,should produce the first two lines, and the remain- ing function, also called twice, should produce the remaining output.</p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nusing namespace std;\n\nvoid fun1()\n{\n    cout &lt;&lt; \"Three blind mice\\n\";\n}\n\nvoid fun2()\n{\n    cout &lt;&lt; \"See how they run\\n\";\n}\n\nint main()                                   // function header\n{                                            // start of function body\n    fun1();                                  // function call\n    fun1();                                  // function call\n    fun2();                                  // function call\n    fun2();                                  // function call\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>4 - Write a program that asks the user to enter his or her age. The program then should display the age in months:</p> <pre><code>Enter your age: 29\nYour age in months is 384.\n</code></pre> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;\n\n    int iAge = 0;\n\n    cout &lt;&lt; \"\\nEnter your age: \";\n    cin &gt;&gt; iAge;\n    cout &lt;&lt; \"Your age in months is \" &lt;&lt; iAge * 12 &lt;&lt; \"\\n\";\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>5 - Write a program that has <code>main()</code> call a user-defined function that takes a Celsius temperature value as an argument and then returns the equivalent Fahrenheit value.The program should request the Celsius value as input from the user and displaythe result, as shown in the following code:</p> <pre><code>Please enter a Celsius value: 20\n20 degrees Celsius is 68 degrees Fahrenheit.\n</code></pre> <p>For reference,here is the formula for making the conversion: <code>Fahrenheit = 1.8 \u00d7 degrees Celsius + 32.0</code></p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nfloat fnCelsiusToFahrenheit(float fCelsius)\n{\n    return (1.8 * fCelsius + 32);\n}\n\nint main()                                   // function header\n{                      \n    using namespace std;\n\n    float fCelsius = 0;\n\n    cout &lt;&lt; \"\\nPlease enter a Celsius value: \";\n    cin &gt;&gt; fCelsius;\n    cout &lt;&lt; fCelsius &lt;&lt; \" degrees Celsius is \" &lt;&lt; fnCelsiusToFahrenheit(fCelsius) &lt;&lt; \" degrees Farhenheit\\n\";\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>6 -</p> <p>Write a program that has <code>main()</code> call a user-defined function that takes a distance in light years as an argument and then returns the distance in astronomical units.The program should request the light year value as input from the user and display the result,as shown in the following code:</p> <pre><code>Enter the number of light years: 4.2\n4.2 light years = 265608 astronomical units.\n</code></pre> <p>An astronomical unit is the average distance from the earth to the sun (about 150,000,000 km or 93,000,000 miles), and a light year is the distance light travels in a year (about 10 trillion kilometers or 6 trillion miles). (The nearest star after thesun is about 4.2 light years away.) Use type double (as in Listing 2.4 (page 51)) and this conversion factor:</p> <pre><code>1 light year = 63,240 astronomical units\n</code></pre> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                      \n    using namespace std;\n\n    double dLightYears = 0;\n\n    cout &lt;&lt; \"\\nEnter the number of light years: \";\n    cin &gt;&gt; dLightYears;\n    cout &lt;&lt; dLightYears &lt;&lt; \" light years = \" &lt;&lt; (dLightYears * 63240) &lt;&lt; \" astronomical units\\n\";\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>7 - Write a program that asks the user to enter an hour value and a minute value. The <code>main()</code> function should then pass these two values to a type <code>void</code> function that displays the two values in the format shown in the following sample run:</p> <pre><code>Enter the number of hours: 9\nEnter the number of minutes: 28\nTime: 9:28\n</code></pre> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                      \n    using namespace std;\n\n    int iHours = 0;\n    int iMinutes = 0;\n\n    cout &lt;&lt; \"\\nEnter the number of hours: \";\n    cin &gt;&gt; iHours;\n    cout &lt;&lt; \"Enter the number of minutes: \";\n    cin &gt;&gt; iMinutes;\n\n    cout &lt;&lt; \"Time: \" &lt;&lt; iHours &lt;&lt; \":\" &lt;&lt; iMinutes &lt;&lt; endl;\n\n    return 0;                                // terminate main()\n} \n</code></pre>"},{"location":"exercises/#chapter-3-programming-exercises","title":"Chapter 3 Programming Exercises","text":"<p>1 - Write a short program that asks for your height in integer inches and then converts your height to feet and inches. Have the program use the underscore character to indicate where to type the response. Also use a const symbolic constant to represent the conversion factor.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst unsigned int _CONV_FACTOR {12};\n\nint main() \n{\n    using namespace std;\n\n    unsigned int uiHeightInput {0};\n    unsigned int uiHeightFeet {0};\n    unsigned int uiHeightInches {0};\n\n    cout &lt;&lt; \"Enter your height in inches:__\\b\\b\";\n    cin &gt;&gt; uiHeightInput;\n\n    uiHeightFeet = uiHeightInput / _CONV_FACTOR;\n    uiHeightInches = uiHeightInput % _CONV_FACTOR;\n\n    cout &lt;&lt; \"Your height is: \" &lt;&lt; uiHeightFeet &lt;&lt; \" feet and \" &lt;&lt; uiHeightInches &lt;&lt; \" inches.\" &lt;&lt; endl;\n}\n</code></pre> <p>2 -</p> <p>Write a short program that asks for your height in feet and inches and your weight in pounds. (Use three variables to store the information.) Have the program report your body mass index (BMI).To calculate the BMI, first convert your height in feet and inches to your height in inches (1 foot = 12 inches). Then convert your height in inches to your height in meters by multiplying by 0.0254.Then convert your weight in pounds into your mass in kilograms by dividing by 2.2. Finally, compute your BMI by dividing your mass in kilograms by the square of your height in meters. Use symbolic constants to represent the various conversion factors.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst int _RATIO_FEET_TO_INCH {12};\nconst float _RATIO_INCH_TO_METER {0.0254};\nconst float _CONV_POUNDS_TO_KG {2.2};\n\ndouble fnBMI(double dHeight, double dWeight);   // function prototype\n\nint main() \n{\n    using namespace std;\n\n    unsigned int uiHeightFeet {};\n    double ulHeightInches {};\n    double ulWeight {};\n\n    cout &lt;&lt; \"Enter your height in feet and (the rest) in inches. Round to whole units.\\n\";\n\n    cout &lt;&lt; \"Enter your height in feet:__\\b\\b\";\n    cin &gt;&gt; uiHeightFeet;\n    cout &lt;&lt; \"Enter your height in inches:__\\b\\b\";\n    cin &gt;&gt; ulHeightInches;\n    cout &lt;&lt; \"Enter your  weight in pounds:__\\b\\b\";\n    cin &gt;&gt; ulWeight;\n\n    ulHeightInches = (uiHeightFeet * _RATIO_FEET_TO_INCH) + ulHeightInches;   // height in inches\n    cout &lt;&lt; \"\\nYour height in inches is \" &lt;&lt; ulHeightInches &lt;&lt; endl;\n\n    cout &lt;&lt; \"Your BMI is \" &lt;&lt; fnBMI(ulHeightInches, ulWeight) &lt;&lt; endl;\n}\n\n/// @brief BMI calculator\n/// @param dHeight in inches\n/// @param dWeight in pounds\n/// @return BMI value in double\ndouble fnBMI(double dHeight, double dWeight)\n{\n    dHeight = dHeight * _RATIO_INCH_TO_METER;                   // height in meters\n    std::cout &lt;&lt; \"Your height in meters is \" &lt;&lt; dHeight &lt;&lt; std::endl;\n\n    dWeight = dWeight / _CONV_POUNDS_TO_KG;                    // weight in kilograms \n    std::cout &lt;&lt; \"Your weight in kilograms is \" &lt;&lt; dWeight &lt;&lt; std::endl &lt;&lt; std::endl;\n\n    return dWeight / (dHeight * dHeight);\n}\n</code></pre> <p>3 - Write a program that asks the user to enter a latitude in degrees, minutes, and seconds and that then displays the latitude in decimal format.There are 60 seconds of arc to a minute and 60 minutes of arc to a degree; represent these values with symbolic constants.You should use a separate variable for each input value. A sample run should look like this:</p> <pre><code>Enter a latitude in degrees, minutes, and seconds:\nFirst, enter the degrees: 37\nNext, enter the minutes of arc: 51\nFinally, enter the seconds of arc: 19\n37 degrees, 51 minutes, 19 seconds = 37.8553 degrees\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n\nconst int _CONV_ARCSECONDS_TO_ARCMINUTES {60};\nconst int _CONV_ARCMINUTES_TO_DEGREES {60};\n\ndouble fnDecimalLattitude(int iDegrees, int iArcMinutes, int iArcSeconds);\n\nint main() \n{\n    using namespace std;\n\n    int iDegrees {};\n    int iArcMinutes {};\n    int iArcSeconds {};\n\n    cout &lt;&lt; \"Enter a latitude in degrees, minutes, and seconds:\\n\";\n\n    cout &lt;&lt; \"First, enter the degrees: \";\n    cin &gt;&gt; iDegrees;\n    cout &lt;&lt; \"Next, enter the minutes of arc: \";\n    cin &gt;&gt; iArcMinutes;\n    cout &lt;&lt; \"Finally, enter the seconds of arc: \";\n    cin &gt;&gt; iArcSeconds;\n\n    cout &lt;&lt; iDegrees &lt;&lt; \" degrees, \" &lt;&lt; iArcMinutes &lt;&lt; \" minutes, \" &lt;&lt; iArcSeconds &lt;&lt; \" seconds = \";\n    cout &lt;&lt; fnDecimalLattitude(iDegrees, iArcMinutes, iArcSeconds) &lt;&lt; \" degrees\\n\";\n}\n\n/// @brief Returns the latitude with decimal format\ndouble fnDecimalLattitude(int iDegrees, int iArcMinutes, int iArcSeconds)\n{\n    double dDegrees = double(iArcSeconds) / _CONV_ARCSECONDS_TO_ARCMINUTES;\n    dDegrees = (iArcMinutes + dDegrees) / _CONV_ARCMINUTES_TO_DEGREES;\n    return iDegrees + dDegrees;\n}\n</code></pre> <p>4 - Write a program that asks the user to enter the number of seconds as an integer value (use type long, or, if available, long long) and that then displays the equivalent time in days, hours, minutes, and seconds. Use symbolic constants to represent the number of hours in the day, the number of minutes in an hour, and the number of seconds in a minute.The output should look like this:</p> <pre><code>Enter the number of seconds: 31600000 \n31600000 seconds = 365 days, 17 hours, 46 minutes, 40 seconds\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n\nconst int _CONV_SECONDS_TO_MINUTES {60};\nconst int _CONV_MINUTES_TO_HOURS {60};\nconst int _CONV_HOURS_TO_DAYS {24};\n\nint main() \n{\n    using namespace std;\n\n    unsigned long long llInputSeconds {}, llSeconds {};\n    unsigned long iMinutes {}, iHours {}, iDays {};\n\n    cout &lt;&lt; \"Enter the number of seconds: \";\n    cin &gt;&gt; llInputSeconds;\n\n    iMinutes = llInputSeconds / _CONV_SECONDS_TO_MINUTES;\n    llSeconds = llInputSeconds % iMinutes;\n\n    iHours = iMinutes / _CONV_MINUTES_TO_HOURS;\n    iMinutes = iMinutes % iHours;\n\n    iDays = iHours / _CONV_HOURS_TO_DAYS;\n    iHours = iHours % iDays;\n\n    cout &lt;&lt; llInputSeconds &lt;&lt; \" seconds = \" &lt;&lt; iDays &lt;&lt; \" days, \" &lt;&lt; iHours &lt;&lt; \" hours, \" &lt;&lt; iMinutes &lt;&lt; \" minutes, \" &lt;&lt; llSeconds &lt;&lt; \" seconds\\n\";\n}\n</code></pre> <p>5 - Write a program that requests the user to enter the current world population and the current population of the U.S. (or of some other nation of your choice). Store the information in variables of type long long. Have the program display the percent that the U.S. (or other nation\u2019s) population is of the world\u2019s population.The output should look something like this:</p> <pre><code>Enter the world's population: 6898758899\nEnter the population of the US: 310783781\nThe population of the US is 4.50492% of the world population.\n</code></pre> <p>You can use the Internet to get more recent figures.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    using namespace std;\n\n    unsigned long long llWorldPopulation {};\n    unsigned long long llCountryPopulation {};\n\n    cout &lt;&lt; \"Enter the world's population: \";\n    cin &gt;&gt; llWorldPopulation;\n\n    cout &lt;&lt; \"Enter the population of the US: \";\n    cin &gt;&gt; llCountryPopulation;\n\n    cout &lt;&lt; \"The population of the US is \";\n    cout &lt;&lt; (double)llCountryPopulation / llWorldPopulation * 100;\n    cout &lt;&lt; \"% of the world population.\";\n}\n</code></pre> <p>6 - Write a program that asks how many miles you have driven and how many gallons of gasoline you have used and then reports the miles per gallon your car has gotten. Or, if you prefer, the program can request distance in kilometers and petrol in liters and then report the result European style, in liters per 100 kilometers.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    using namespace std;\n\n    unsigned long long llMilesDriven {};\n    unsigned long long llUsedGasoline {};\n\n    cout &lt;&lt; \"Enter how many miles you have driven: \";\n    cin &gt;&gt; llMilesDriven;\n\n    cout &lt;&lt; \"Enter how many gallons of gasoline you have used: \";\n    cin &gt;&gt; llUsedGasoline;\n\n    cout &lt;&lt; (double)llMilesDriven / llUsedGasoline;\n    cout &lt;&lt; \" miles per gallon your car have gotten\";\n}\n</code></pre> <p>7 - Write a program that asks you to enter an automobile gasoline consumption figure in the European style (liters per 100 kilometers) and converts to the U.S. style of miles per gallon. Note that in addition to using different units of measurement, the U.S. approach (distance / fuel) is the inverse of the European approach (fuel / distance). Note that 100 kilometers is 62.14 miles, and 1 gallon is 3.875 liters. Thus, 19 mpg is about 12.4 l/100 km, and 27 mpg is about 8.7 l/100 km.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst double _RATIO_KM_TO_M {0.6214};\nconst double _RATIO_GAL_TO_L {3.785412};\n\nint main() \n{\n    using namespace std;\n\n    float fGasolineConsumptionEU {};\n\n    cout &lt;&lt; \"Enter automobile gasoline consumption figure (liters per 100 kilometers): \";\n    cin &gt;&gt; fGasolineConsumptionEU;\n\n    cout &lt;&lt; fGasolineConsumptionEU &lt;&lt; \" liters per 100 kilometers = \";\n    cout &lt;&lt; fGasolineConsumptionEU / _RATIO_GAL_TO_L &lt;&lt; \" galons per \";\n    cout &lt;&lt; _RATIO_KM_TO_M * 100 &lt;&lt; \" miles\\n\";\n\n    cout &lt;&lt; \"MPG = \" &lt;&lt; (_RATIO_KM_TO_M * 100) / (fGasolineConsumptionEU / _RATIO_GAL_TO_L) &lt;&lt; endl;\n}\n</code></pre>"},{"location":"exercises/#chapter-4-programming-exercises","title":"Chapter 4 Programming Exercises","text":"<p>1 - Write a C++ program that requests and displays information as shown in the following.</p> <p>Example of output:</p> <pre><code>What is your first name? Betty Sue\nWhat is your last name? Yewe\nWhat letter grade do you deserve? B\nWhat is your age? 22\nName: Yewe, Betty Sue\nGrade: C\nAge: 22\n</code></pre> <p>Note that the program should be able to accept first names that comprise more than one word. Also note that the program adjusts the grade downward\u2014that is, up one letter. Assume that the user requests an A, a B, or a C so that you don\u2019t have to worry about the gap between a D and an F.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst double _RATIO_KM_TO_M {0.6214};\nconst double _RATIO_GAL_TO_L {3.785412};\n\nint main() \n{\n    using namespace std;\n\n    float fGasolineConsumptionEU {};\n\n    cout &lt;&lt; \"Enter automobile gasoline consumption figure (liters per 100 kilometers): \";\n    cin &gt;&gt; fGasolineConsumptionEU;\n\n    cout &lt;&lt; fGasolineConsumptionEU &lt;&lt; \" liters per 100 kilometers = \";\n    cout &lt;&lt; fGasolineConsumptionEU / _RATIO_GAL_TO_L &lt;&lt; \" galons per \";\n    cout &lt;&lt; _RATIO_KM_TO_M * 100 &lt;&lt; \" miles\\n\";\n\n    cout &lt;&lt; \"MPG = \" &lt;&lt; (_RATIO_KM_TO_M * 100) / (fGasolineConsumptionEU / _RATIO_GAL_TO_L) &lt;&lt; endl;\n}\n</code></pre> <p>2 - Rewrite Listing 4.4, using the C++ string class instead of char arrays.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct stStudent {\n    std::string firstName;\n    std::string lastName;\n    char Grade;\n    unsigned int age;\n};\n\nint main() \n{\n    using namespace std;\n    stStudent *pStudent = new stStudent;\n\n    cout &lt;&lt; \"What is your first name? \"; \n    getline(cin, pStudent-&gt;firstName);\n\n    cout &lt;&lt; \"What is your last name? \";\n    getline(cin, pStudent-&gt;lastName);\n\n    cout &lt;&lt; \"What letter grade do you deserve? \";\n    cin &gt;&gt; pStudent-&gt;Grade;\n\n    cout &lt;&lt; \"What is your age? \";\n    cin &gt;&gt; pStudent-&gt;age;\n\n    cout &lt;&lt; \"Name: \" &lt;&lt; pStudent-&gt;lastName &lt;&lt; \", \" &lt;&lt; pStudent-&gt;firstName &lt;&lt; endl;\n    cout &lt;&lt; \"Grade: \" &lt;&lt; (char) ++(pStudent-&gt;Grade) &lt;&lt; endl;     \n    cout &lt;&lt; \"Age: \" &lt;&lt; pStudent-&gt;age &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>3 - Write a program that asks the user to enter his or her first name and then last name, and that then constructs, stores, and displays a third string, consisting of the user\u2019s last name followed by a comma, a space, and first name. Use char arrays and functions from the cstring header file.A sample run could look like this:</p> <pre><code>Enter your first name: Flip\nEnter your last name: Fleming\nHere\u2019s the information in a single string: Fleming, Flip\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main() \n{\n    using namespace std;\n    char szFirstName[50];\n    char szLastName[50];\n    char szConNames[100];\n\n    cout &lt;&lt; \"Enter your first name: \"; \n    cin.getline(szFirstName, 50);\n\n    cout &lt;&lt; \"Enter your last name: \";\n    cin.getline(szLastName, 50);\n\n    cout &lt;&lt; \"Here is the information in a single string: \";\n    strcpy(szConNames, szLastName);\n    strcat(szConNames, \", \");\n    strcat(szConNames, szFirstName);\n    cout &lt;&lt; szConNames &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>4 - Write a program that asks the user to enter his or her first name and then last name, and that then constructs, stores, and displays a third string consisting of the user\u2019s last name followed by a comma, a space, and first name. Use string objects and methods from the string header file. A sample run could look like this:</p> <pre><code>Enter your first name: Flip\nEnter your last name: Fleming\nHere\u2019s the information in a single string: Fleming, Flip\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() \n{\n    using namespace std;\n    string szFirstName;\n    string szLastName;\n    string szConNames;\n\n    cout &lt;&lt; \"Enter your first name: \"; \n    getline(cin, szFirstName);\n\n    cout &lt;&lt; \"Enter your last name: \";\n    getline(cin, szLastName);\n\n    cout &lt;&lt; \"Here is the information in a single string: \";\n    szConNames = szLastName + \", \" + szFirstName;\n    cout &lt;&lt; szConNames &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>5 - The CandyBar structure contains three members. The first member holds the brand name of a candy bar. The second member holds the weight (which may have a fractional part) of the candy bar, and the third member holds the number of calories (an integer value) in the candy bar. Write a program that declares such a structure and creates a CandyBar variable called snack, initializing its members to \"Mocha Munch\", 2.3, and 350, respectively.The initialization should be part of the declaration for snack. Finally, the program should display the contents of the snack variable.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct CandyBar{\n    char name[20];\n    float weight;\n    int calories;\n};\n\nint main() \n{\n    using namespace std;\n\n    CandyBar snack {\"Mocha Munch\", 2.3, 350};\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack.name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack.weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack.calories &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>6 - The CandyBar structure contains three members, as described in Programming Exercise 5.Write a program that creates an array of three CandyBar structures, initializes them to values of your choice, and then displays the contents of each structure.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct CandyBar{\n    char name[20];\n    float weight;\n    int calories;\n};\n\nint main() \n{\n    using namespace std;\n\n    CandyBar snack[3];\n\n    snack[0] = {\"Mocha Munch\", 2.3, 350};\n    snack[1] = {\"Nom Nom Nom\", 4.5, 440};\n    snack[2] = {\"Diet Munch\", 5.3, 600};\n\n    // // Also correct\n    // snack[3] =\n    // {\n    //     {\"Mocha Munch\", 2.3, 350};\n    //     {\"Nom Nom Nom\", 4.5, 440};\n    //     {\"Diet Munch\", 5.3, 600}\n    // };\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[0].name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[0].weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[0].calories &lt;&lt; endl &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[1].name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[1].weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[1].calories &lt;&lt; endl &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[2].name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[2].weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[2].calories &lt;&lt; endl &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>7 - William Wingate runs a pizza-analysis service. For each pizza, he needs to record the following information:</p> <ul> <li>The name of the pizza company, which can consist of more than one word</li> <li>The diameter of the pizza</li> <li>The weight of the pizza</li> </ul> <p>Devise a structure that can hold this information and write a program that uses a structure variable of that type.The program should ask the user to enter each of the preceding items of information, and then the program should display that information. Use cin (or its methods) and cout.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct Pizza{\n    char name[50];\n    float diameter;\n    float weight;\n};\n\nint main() \n{\n    using namespace std;\n    Pizza myPizza;\n\n     cout &lt;&lt; \"Enter the name of your pizza: \";\n     cin.getline(myPizza.name, 50);\n     cout &lt;&lt; \"Enter the diameter of your pizza: \";\n     cin &gt;&gt; myPizza.diameter;\n     cout &lt;&lt; \"Enter the weight of your pizza: \";\n     cin &gt;&gt; myPizza.weight;\n\n    cout &lt;&lt; endl &lt;&lt; \"My Pizza name: \" &lt;&lt; myPizza.name &lt;&lt; endl \n         &lt;&lt; \"My Pizza diameter: \" &lt;&lt; myPizza.diameter &lt;&lt; endl \n         &lt;&lt; \"My Pizza weight: \" &lt;&lt; myPizza.weight &lt;&lt; endl &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>8 - Do Programming Exercise 7 but use new to allocate a structure instead of declaring a structure variable. Also have the program request the pizza diameter before it requests the pizza company name.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstruct Pizza\n{\n    char name[50];\n    float diameter;\n    float weight;\n};\n\nint main()\n{\n    using namespace std;\n    Pizza *myPizza = new Pizza;\n\n    cout &lt;&lt; \"Enter the diameter of your pizza: \";\n    // cin leaves a newline character in the input stream .get removes it (chapter 3: C-style strings)\n    (cin &gt;&gt; myPizza-&gt;diameter).get();\n    cout &lt;&lt; \"Enter the name of your pizza: \";\n    cin.getline(myPizza-&gt;name, 50);\n    cout &lt;&lt; \"Enter the weight of your pizza: \";\n    cin &gt;&gt; myPizza-&gt;weight;\n\n    cout &lt;&lt; endl\n         &lt;&lt; \"My Pizza name: \" &lt;&lt; myPizza-&gt;name &lt;&lt; endl\n         &lt;&lt; \"My Pizza diameter: \" &lt;&lt; myPizza-&gt;diameter &lt;&lt; endl\n         &lt;&lt; \"My Pizza weight: \" &lt;&lt; myPizza-&gt;weight &lt;&lt; endl\n         &lt;&lt; endl;\n\n    delete myPizza;\n\n    return 0;\n}\n</code></pre> <p>9 - Do Programming Exercise 6, but instead of declaring an array of three CandyBar structures, use new to allocate the array dynamically.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct CandyBar\n{\n    char name[20];\n    float weight;\n    int calories;\n};\n\nint main()\n{\n    using namespace std;\n\n    CandyBar *snack = new CandyBar[3];\n\n    snack[0] = {\"Mocha Munch\", 2.3, 350};\n    snack[1] = {\"Nom Nom Nom\", 4.5, 440};\n    snack[2] = {\"Diet Munch\", 5.3, 600};\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[0].name &lt;&lt; endl\n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[0].weight &lt;&lt; endl\n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[0].calories &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[1].name &lt;&lt; endl\n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[1].weight &lt;&lt; endl\n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[1].calories &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[2].name &lt;&lt; endl\n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[2].weight &lt;&lt; endl\n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[2].calories &lt;&lt; endl\n         &lt;&lt; endl;\n\n    delete[] snack;\n\n    return 0;\n}\n</code></pre> <p>10 - Write a program that requests the user to enter three times for the 40-yd dash (or 40-meter, if you prefer) and then displays the times and the average. Use an array object to hold the data. (Use a built-in array if array is not available.)</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main()\n{\n     using namespace std;\n     array&lt;int, 3&gt; aDash{}; // or int aDash[3] {};\n\n     cout &lt;&lt; \"enter three times the 40-meter dash: \\n\";\n     cin &gt;&gt; aDash[0] &gt;&gt; aDash[1] &gt;&gt; aDash[2];\n     cout &lt;&lt; \"Average: \" &lt;&lt; (aDash[0] + aDash[1] + aDash[2]) / 3.0 &lt;&lt; \" \\n\";\n\n     return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-5-programming-exercises","title":"Chapter 5 Programming Exercises","text":"<p>1 - Write a program that requests the user to enter two integers.The program should then calculate and report the sum of all the integers between and including the two integers. At this point, assume that the smaller integer is entered first. For example, if the user enters 2 and 9, the program should report that the sum of all the integers from 2 through 9 is 44.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n    int iVal[2] {}, iSum {};\n\n    cout &lt;&lt; \"Enter two integers: \" &lt;&lt; endl;\n    cout &lt;&lt; \"  First integer: \";\n    cin &gt;&gt; iVal[0];\n\n    cout &lt;&lt; \"  Second integer: \";\n    cin &gt;&gt; iVal[1];\n\n    if (iVal[0] &gt; iVal[1]){\n        int temp {};\n\n        temp = iVal[0]; \n        iVal[0] = iVal[1];\n        iVal[1] = temp;\n    }\n\n    for (size_t i = iVal[0]; i &lt;= iVal[1]; i++)\n        iSum += i;\n\n    cout &lt;&lt; \"Sum of integers from \" &lt;&lt; iVal[0] &lt;&lt; \" to \" &lt;&lt; iVal[1] &lt;&lt; \" is \" &lt;&lt; iSum &lt;&lt; endl;\n\n    return 0;    \n}\n</code></pre> <p>2 - Redo Listing 5.4 using a type array object instead of a built-in array and type long double instead of long long. Find the value of 100!</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main()\n{\n    using namespace std;\n    array&lt;long double, 2&gt; dVal {};\n    long double dSum {};\n\n    cout &lt;&lt; \"Enter two integers: \" &lt;&lt; endl;\n    cout &lt;&lt; \"  First integer: \";\n    cin &gt;&gt; dVal[0];\n\n    cout &lt;&lt; \"  Second integer: \";\n    cin &gt;&gt; dVal[1];\n\n    if (dVal[0] &gt; dVal[1]){\n        int temp {};\n\n        temp = dVal[0]; \n        dVal[0] = dVal[1];\n        dVal[1] = temp;\n    }\n\n    for (size_t i = dVal[0]; i &lt;= dVal[1]; i++)\n        dSum += i;\n\n    cout &lt;&lt; \"Sum of integers from \" &lt;&lt; dVal[0] &lt;&lt; \" to \" &lt;&lt; dVal[1] &lt;&lt; \" is \" &lt;&lt; dSum &lt;&lt; endl;\n\n    return 0;    \n}\n</code></pre> <p>3 - Write a program that asks the user to type in numbers.After each entry, the program should report the cumulative sum of the entries to date.The program should terminate when the user enters 0.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    using namespace std;\n    long double dVal {}, dSum {};\n\n    cout &lt;&lt; \"Enter a number, the program will sum it all.\\n\";\n    cout &lt;&lt; \"Enter 0 to exit.\\n\\n\";\n\n    do{\n        cout &lt;&lt; \"Enter a number : \";\n        cin &gt;&gt; dVal;\n        dSum += dVal;\n        cout &lt;&lt; \"Sum : \" &lt;&lt; dSum &lt;&lt; endl;\n    }while (dVal != 0);\n\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\n</code></pre> <p>4 - Daphne invests <code>$100 at 10%</code> simple interest.That is, every year, the investment earns <code>10%</code> of the original investment, or <code>$10</code> each and every year:</p> <pre><code>interest = 0.10 \u00d7 original balance\n</code></pre> <p>At the same time, Cleo invests <code>$100</code> at <code>5%</code> compound interest.That is, interest is <code>5%</code> of the current balance, including previous additions of interest:</p> <pre><code>interest = 0.05 \u00d7 current balance\n</code></pre> <p>Cleo earns <code>5% of $100</code> the first year, giving her <code>$105</code>.The next year she earns <code>5%</code> of <code>$105</code>, or <code>$5.25</code>, and so on. Write a program that finds how many years it takes for the value of Cleo\u2019s investment to exceed the value of Daphne\u2019s investment and then displays the value of both investments at that time.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n    double dSimple {100}, dCompound {100};\n    double dSimpleSum {dSimple}, dCompoundSum {dCompound};\n    size_t i {0};\n\n    cout &lt;&lt; \"\\nInitial investment in 10% Simple interest: \" &lt;&lt; dSimple &lt;&lt; endl;\n    cout &lt;&lt; \"Initial investment in 5% Compound interest: \" &lt;&lt; dCompound &lt;&lt; endl &lt;&lt; endl;\n\n    do\n    {\n        i++;\n        dSimpleSum += dSimple * 0.1;\n        dCompoundSum += dCompoundSum * 0.05;\n    } while (dSimpleSum &gt; dCompoundSum);\n\n    cout &lt;&lt; \"Simple Interest after \" &lt;&lt; i &lt;&lt; \" years: \" &lt;&lt; dSimpleSum &lt;&lt; endl;\n    cout &lt;&lt; \"Compound Interest after \" &lt;&lt; i &lt;&lt; \" years: \" &lt;&lt; dCompoundSum &lt;&lt; endl;\n\n    cout &lt;&lt; endl &lt;&lt; \"  It takes \" &lt;&lt; i &lt;&lt; \" years for compound investment to exceed simple investment.\" &lt;&lt; endl &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>5 - You sell the book C++ for Fools. Write a program that has you enter a year\u2019s worth of monthly sales (in terms of number of books, not of money).The program should use a loop to prompt you by month, using an array of char * (or an array of string objects, if you prefer) initialized to the month strings and storing the input data in an array of int.Then, the program should find the sum of the array contents and report the total sales for the year.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    using namespace std;\n    string sMonths[] {\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n    // const char *sMonths[12] {                                                // also correct\n    //     \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \n    //     \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n\n    int iSales[12];\n    long lTotal {};\n\n    cout &lt;&lt; \"Enter monthly sale for a: \\n\";\n\n    for (size_t i = 0; i &lt; 12; i++)\n    {\n        cout &lt;&lt; sMonths[i] &lt;&lt; \": \"; \n        cin &gt;&gt; iSales[i];\n        lTotal += iSales[i];\n    }\n\n    cout &lt;&lt; \"\\nTotal sales for the year: \" &lt;&lt; lTotal &lt;&lt; endl;   \n\n    return 0;\n}\n</code></pre> <p>6 - Do Programming Exercise 5 but use a two-dimensional array to store input for 3 years of monthly sales. Report the total sales for each individual year and for the combined years.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    using namespace std;\n    string sMonths[]{\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n    int iSales[3][12] {};\n    long lYearlyTotal[3] {};\n    long lTotal{};\n\n    for (size_t i = 0; i &lt; 3; i++)\n    {\n        cout &lt;&lt; \"For \" &lt;&lt; (i + 1) &lt;&lt; \" year, enter the sale for: \\n\";\n        for (size_t j = 0; j &lt; 12; j++)\n        {\n            cout &lt;&lt; sMonths[j] &lt;&lt; \": \";\n            cin &gt;&gt; iSales[i][j];\n            lYearlyTotal[i] += iSales[i][j];\n        }\n        lTotal += lYearlyTotal[i];\n        cout &lt;&lt; \"\\nTotal sales for \" &lt;&lt; (i + 1) &lt;&lt; \" year: \" &lt;&lt; lYearlyTotal[i] &lt;&lt; \"\\n\";\n    }\n\n    cout &lt;&lt; \"\\nTotal sales for all years: \" &lt;&lt; lTotal &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>7 - Design a structure called car that holds the following information about an automobile: its make, as a string in a character array or in a string object, and the year it was built, as an integer.Write a program that asks the user how many cars to catalog. The program should then use new to create a dynamic array of that many car structures. Next, it should prompt the user to input the make (which might consist of more than one word) and year information for each structure. Note that this requires some care because it alternates reading strings with numeric data (see Chapter 4). Finally, it should display the contents of each structure.A sample run should look something like the following:</p> <pre><code>How many cars do you wish to catalog? 2\nCar #1:\nPlease enter the make: Hudson Hornet\nPlease enter the year made: 1952\nCar #2:\nPlease enter the make: Kaiser\nPlease enter the year made: 1951\nHere is your collection:\n1952 Hudson Hornet\n1951 Kaiser\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct car{\n    std::string make;\n    int year;\n};\n\nint main()\n{\n    using namespace std;\n    int iNumCars{};\n\n    cout &lt;&lt; \"How many cars do you wish to catalog? : \";\n    (cin &gt;&gt; iNumCars).get();\n\n    car *pCar = new car[iNumCars];\n\n    for (size_t i = 0; i &lt; iNumCars; i++)\n    {\n        cout &lt;&lt; \"Car #\" &lt;&lt; i + 1 &lt;&lt; \":\" &lt;&lt; endl;\n\n        cout &lt;&lt; \"Please enter the make: \";\n        getline(cin, pCar[i].make);\n\n        cout &lt;&lt; \"Please enter the year made: \";\n        (cin &gt;&gt; pCar[i].year).get();\n    }\n\n    cout &lt;&lt; \"\\nHere is your collection:\\n\";\n    for (size_t i = 0; i &lt; iNumCars; i++)\n        cout &lt;&lt; pCar[i].year &lt;&lt; \" \" &lt;&lt; pCar[i].make &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>8 - Write a program that uses an array of char and a loop to read one word at a time until the word done is entered.The program should then report the number of words entered (not counting done).A sample run could look like this:</p> <pre><code>Enter words (to stop, type the word done):\nanteater birthday category dumpster\nenvy finagle geometry done for sure\nYou entered a total of 7 words.\n</code></pre> <p>You should include the cstring header file and use the strcmp() function to make the comparison test.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    using namespace std;\n    char word[100];\n    int count{};\n\n    cout &lt;&lt; \"Enter words (to stop, type the word done):\\n\";\n    do\n    {\n        cin &gt;&gt; word;\n        ++count;\n    } while (strcmp(word, \"done\"));\n    cout &lt;&lt; endl\n         &lt;&lt; \"You entered a total of \" &lt;&lt; count &lt;&lt; \" words\\n\";\n\n    return 0;\n}\n</code></pre> <p>9 - Write a program that matches the description of the program in Programming Exercise 8, but use a string class object instead of an array. Include the string header file and use a relational operator to make the comparison test.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    using namespace std;\n    string word;\n    int count{};\n\n    cout &lt;&lt; \"Enter words (to stop, type the word done):\\n\";\n    do\n    {\n        cin &gt;&gt; word;\n        ++count;\n    } while (word != \"done\");\n    cout &lt;&lt; endl\n         &lt;&lt; \"You entered a total of \" &lt;&lt; count &lt;&lt; \" words\\n\";\n\n    return 0;\n}\n</code></pre> <p>10 - Write a program using nested loops that asks the user to enter a value for the number of rows to display. It should then display that many rows of asterisks, with one asterisk in the first row, two in the second row, and so on. For each row, the asterisks are preceded by the number of periods needed to make all the rows display a total number of characters equal to the number of rows.A sample run would look like this:</p> <pre><code>Enter number of rows: 5\n....*\n...**\n..***\n.****\n*****\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    using namespace std;\n    int iRows{};\n\n    cout &lt;&lt; \"Enter number of rows: \";\n    cin &gt;&gt; iRows;\n\n    for (size_t i = 0; i &lt; iRows; i++)                  // lines to print\n    {\n        // dots to print: \n        // dot = 1, -&gt; because per 3 chars there is one `star`\n        // dot &lt; iRows - i, -&gt; because the next line will have one more `star` \n        //                     and one less `dot` EVERY LOOP\n        for (size_t dot = 1; dot &lt; iRows - i; ++dot)    // DOTS ARE PRINTED FIRST\n            cout &lt;&lt; \".\";\n        for (size_t star = 0; star &lt;= i; ++star)        // STARS ARE PRINTED SECOND\n            cout &lt;&lt; \"*\";\n\n        // // Different solution\n        // for (size_t dot = i; dot &lt; iRows - 1; dot++)\n        //     cout &lt;&lt; '.';\n        // for (size_t star = i + 1; star != 0; star--)\n        //     cout &lt;&lt; '*';\n\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-6-programming-exercises","title":"Chapter 6 Programming Exercises","text":"<p>1 - Write a program that reads keyboard input to the @ symbol and that echoes the input except for digits, converting each uppercase character to lowercase, and vice versa. (Don\u2019t forget the <code>cctype</code> family.)</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cctype&gt;\n\nint main(){\n    using namespace std;\n\n    char cInput;\n\n    while (cin.get(cInput) &amp;&amp; cInput != '@')\n    {\n        if(isdigit(cInput))\n            cInput = ' ';\n        else if(isupper(cInput))\n            cInput = tolower(cInput);\n        else\n            cInput = toupper(cInput);\n        cout &lt;&lt; cInput;\n    }\n\n    return 0;\n}\n</code></pre> <p>2 - Write a program that reads up to 10 donation values into an array of double. (Or, if you prefer, use an array template object.) The program should terminate input on non-numeric input. It should report the average of the numbers and also report how many numbers in the array are larger than the average.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cctype&gt;\n\nconst int MAX_SIZE = 10;\n\nint main()\n{\n    using namespace std;\n\n    double dArray[MAX_SIZE]{};\n    double dAboveAverage{}, dSum{};\n    int i{};\n\n    cout &lt;&lt; \"Write \" &lt;&lt; MAX_SIZE &lt;&lt; \" donations: \\n\";\n    cout &lt;&lt; \"\\n #\" &lt;&lt; i + 1 &lt;&lt; \" donation: \";\n\n    while (i &lt; MAX_SIZE &amp;&amp; cin &gt;&gt; dArray[i])\n    {\n        dSum += dArray[i];\n        if(++i &lt; MAX_SIZE)\n            cout &lt;&lt; \" #\" &lt;&lt; i + 1 &lt;&lt; \" donation: \";\n    }\n\n    for (size_t j = 0; j &lt; i; j++)\n        if (dArray[j] &gt; (dSum / i))\n            ++dAboveAverage;\n\n    cout &lt;&lt; \"\\n\\n   Average from donations: \" &lt;&lt; dSum / i &lt;&lt; endl;\n    cout &lt;&lt; \"   Amount of donations above average: \" &lt;&lt; dAboveAverage &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>3 - Write a precursor to a menu-driven program.The program should display a menu offering four choices, each labeled with a letter. If the user responds with a letter other than one of the four valid choices, the program should prompt the user to enter a valid response until the user complies.Then the program should use a switch to select a simple action based on the user\u2019s selection. A program run could look something like this:</p> <pre><code>Please enter one of the following choices:\nc) carnivore    p) pianist\nt) tree         g) game\nf\nPlease enter a c, p, t, or g: q\nPlease enter a c, p, t, or g: t\nA maple is a tree.\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n\nint main(){\n    using namespace std;\n    char cMenu;\n\n    cout &lt;&lt; \"Please enter one of the following choices:\" &lt;&lt; endl \n         &lt;&lt; \"c) carnivore\\t p) pianist\" &lt;&lt; endl \n         &lt;&lt; \"t) tree\\t\\t g) game\" &lt;&lt; endl;\n\n    cin &gt;&gt; cMenu;\n\n    while(true){\n        switch (cMenu)\n        {\n        case 'c':        \n            cout &lt;&lt; \"Cat is a carnivore.\";\n            break;\n        case 'p':        \n            cout &lt;&lt; \"Beethoven is a pianist\";\n            break;\n        case 't':        \n            cout &lt;&lt; \"A maple is a tree.\";\n            break;\n        case 'g':        \n            cout &lt;&lt; \"Rain World is a good game.\";\n            break;\n        default:\n            cout &lt;&lt; \"Please enter a: c, p, t, or g: \";\n            break;\n        }\n        cin &gt;&gt; cMenu;\n    }\n\n    return 0;\n}\n</code></pre> <p>4 - When you join the Benevolent Order of Programmers, you can be known at BOP meetings by your real name, your job title, or your secret BOP name. Write a program that can list members by real name, by job title, by secret name, or by a member\u2019s preference. Base the program on the following structure:</p> <pre><code>// Benevolent Order of Programmers name structure\nstruct bop\n{\n    char fullname[strsize]; // real name\n    char title[strsize];    // job title\n    char bopname[strsize];  // secret BOP name\n    int preference;         // 0 = fullname, 1 = title, 2 = bopname\n};\n</code></pre> <p>In the program, create a small array of such structures and initialize it to suitable values. Have the program run a loop that lets the user select from different alternatives:</p> <pre><code>a. display by name      b. display by title\nc. display by bopname   d. display by preference\nq. quit\n</code></pre> <p>Note that \u201cdisplay by preference\u201d does not mean display the preference member; it means display the member corresponding to the preference number. For instance, if preference is 1, choice d would display the programmer\u2019s job title.A sample run may look something like the following:</p> <pre><code>Benevolent Order of Programmers Report\na. display by name b. display by title\nc. display by bopname d. display by preference\nq. quit\nEnter your choice: a\nWimp Macho\nRaki Rhodes\nCelia Laiter\nHoppy Hipman\nPat Hand\nNext choice: d\nWimp Macho\nJunior Programmer\nMIPS\nAnalyst Trainee\nLOOPY\nNext choice: q\nBye!\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nconst int sizeBOP = 5;\nconst int strsize = 50;\n// Benevolent Order of Programmers name structure\nstruct bop\n{\n    char fullname[strsize]; // real name\n    char title[strsize];    // job title\n    char bopname[strsize];  // secret BOP name\n    int preference;         // 0 = fullname, 1 = title, 2 = bopname\n};\n\nint main()\n{\n    using namespace std;\n    char cMenu;\n\n    cout &lt;&lt; \"Please enter one of the following choices:\" &lt;&lt; endl\n         &lt;&lt; \"a. display by name\\t b. display by title\" &lt;&lt; endl\n         &lt;&lt; \"c. display by bopname\\t d. display by preference\" &lt;&lt; endl\n         &lt;&lt; \"q. quit\" &lt;&lt; endl;\n\n    cout &lt;&lt; \"Enter your choice: \";\n    cin &gt;&gt; cMenu;\n\n    bop *stBOP = new bop[sizeBOP];\n    strcpy(stBOP[0].fullname, \"Wimp Macho\");\n    strcpy(stBOP[0].title, \"Chef\");\n    strcpy(stBOP[0].bopname, \"BOPA\");\n    stBOP[0].preference = 0;\n\n    strcpy(stBOP[1].fullname, \"Raki Rhodes\");\n    strcpy(stBOP[1].title, \"Junior Programmer\");\n    strcpy(stBOP[1].bopname, \"RAKI\");\n    stBOP[1].preference = 1;\n\n    strcpy(stBOP[2].fullname, \"Celia Laiter\");\n    strcpy(stBOP[2].title, \"Senior Programmer\");\n    strcpy(stBOP[2].bopname, \"MIPS\");\n    stBOP[2].preference = 2;\n\n    strcpy(stBOP[3].fullname, \"Hoppy Hipman\");\n    strcpy(stBOP[3].title, \"Analyst trainee\");\n    strcpy(stBOP[3].bopname, \"MEHA\");\n    stBOP[3].preference = 1;\n\n    strcpy(stBOP[4].fullname, \"Pat Hand\");\n    strcpy(stBOP[4].title, \"Boss\");\n    strcpy(stBOP[4].bopname, \"LOOPY\");\n    stBOP[4].preference = 2;\n\n    while (cMenu != 'q')\n    {\n        switch (cMenu)\n        {\n        case 'a':\n            for (int i{}; i &lt; sizeBOP; ++i)\n                cout &lt;&lt; stBOP[i].fullname &lt;&lt; endl;\n            break;\n        case 'b':\n            for (int i{}; i &lt; sizeBOP; ++i)\n                cout &lt;&lt; stBOP[i].title &lt;&lt; endl;\n            break;\n        case 'c':\n            for (int i{}; i &lt; sizeBOP; ++i)\n                cout &lt;&lt; stBOP[i].bopname &lt;&lt; endl;\n            break;\n        case 'd':\n            for (int i{}; i &lt; sizeBOP; ++i)\n            {\n                switch (stBOP[i].preference)\n                {\n                case 0: cout &lt;&lt; stBOP[i].fullname &lt;&lt; endl;  break;\n                case 1: cout &lt;&lt; stBOP[i].title &lt;&lt; endl;     break;\n                case 2: cout &lt;&lt; stBOP[i].bopname &lt;&lt; endl;   break;\n                default: cout &lt;&lt; \"No preference\" &lt;&lt; endl;   break;\n                }\n            }\n            break;\n        default:\n            cout &lt;&lt; \"Please enter: a, b, c, d, or q. : \";\n            break;\n        }\n        cout &lt;&lt; \"Next choice: \";\n        cin &gt;&gt; cMenu;\n    }\n    delete[] stBOP;\n    cout &lt;&lt; \"Bye!\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>5 - The Kingdom of Neutronia, where the unit of currency is the tvarp, has the following income tax code:</p> <pre><code>    First 5,000 tvarps: 0% tax\n    Next 10,000 tvarps: 10% tax\n    Next 20,000 tvarps: 15% tax\n    Tvarps after 35,000: 20% tax\n</code></pre> <p>For example, someone earning 38,000 tvarps would owe 5,000 \u00d7 0.00 + 10,000 \u00d7 0.10 + 20,000 \u00d7 0.15 + 3,000 \u00d7 0.20, or 4,600 tvarps. Write a program that uses a loop to solicit incomes and to report tax owed. The loop should terminate when the user enters a negative number or non-numeric input.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint main(){\n    using namespace std;\n    long double dIncome{}, dTax{}; \n\n    cout &lt;&lt; \"Enter income in tvarps: \";\n    while(cin &gt;&gt; dIncome){\n        if(dIncome &lt; 0)\n            break;\n\n        if (dIncome &lt;= 5000)\n            dTax = 0;\n        else if(dIncome &lt;= 15000)\n            dTax = (dIncome - 5000) * 0.1;\n        else if(dIncome &lt; 35000)\n            dTax = (dIncome - 15000) * 0.15 + 10000 * 0.1;\n        else\n            dTax = (dIncome - 35000) * 0.2 + 20000 * 0.15 + 10000 * 0.1;\n\n        cout &lt;&lt; \"Your tax is: \" &lt;&lt; dTax &lt;&lt; \" tvarps\" &lt;&lt; endl;\n        cout &lt;&lt; \"Enter income in tvarps: \";\n    }\n    return 0;\n}\n</code></pre> <p>6 - Put together a program that keeps track of monetary contributions to the Society for the Preservation of Rightful Influence. It should ask the user to enter the number of contributors and then solicit the user to enter the name and contribution of each contributor.The information should be stored in a dynamically allocated array of structures. Each structure should have two members: a character array (or else a <code>string</code> object) to store the name and a <code>double</code> member to hold the amount of the contribution.After reading all the data, the program should display the names and amounts donated for all donors who contributed $10,000 or more.This list should be headed by the label Grand Patrons.After that, the program should list the remaining donors. That list should be headed Patrons. If there are no donors in one of the categories, the program should print the word \u201cnone.\u201dAside from displaying two categories, the program need do no sorting.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct stSocietyPRI\n{\n    std::string name;\n    double contribution;\n};\n\nint main()\n{\n    using namespace std;\n    int iContrbutors{}, iCounter{};\n\n    cout &lt;&lt; \"Enter the number of contributors: \";\n\n    while (!(cin &gt;&gt; iContrbutors))\n    {\n        cin.clear(); // reset input\n        while (cin.get() != '\\n')\n            continue; // get rid of bad input\n        cout &lt;&lt; \"Please enter a number: \";\n    }\n    cin.get(); // clear the input buffer\n\n    stSocietyPRI *pSociety = new stSocietyPRI[iContrbutors];\n\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        cout &lt;&lt; \"Enter the name of the \" &lt;&lt; i + 1 &lt;&lt; \" contributor: \";\n        getline(cin, pSociety[i].name);\n\n        cout &lt;&lt; \"Enter the contribution of the \" &lt;&lt; i + 1 &lt;&lt; \" contributor: \";\n        while (!(cin &gt;&gt; pSociety[i].contribution))\n        {\n            cin.clear(); // reset input\n            while (cin.get() != '\\n')\n                continue; // get rid of bad input\n            cout &lt;&lt; \"Please enter a number: \";\n        }\n        cin.get(); // clear the input buffer\n    }\n\n    // Print Grand Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Grand Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        if (pSociety[i].contribution &gt;= 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    // Print the rest Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        if (pSociety[i].contribution &lt; 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    return 0;\n}\n</code></pre> <p>7 - Write a program that reads input a word at a time until a lone q is entered. The program should then report the number of words that began with vowels, the number that began with consonants, and the number that fit neither of those categories. One approach is to use <code>isalpha()</code> to discriminate between words beginning with letters and those that don\u2019t and then use an <code>if</code> or <code>switch</code> statement to further identify those passing the <code>isalpha()</code> test that begin with vowels.A sample run might look like this:</p> <pre><code>Enter words (q to quit):\nThe 12 awesome oxen ambled\nquietly across 15 meters of lawn. q\n5 words beginning with vowels\n4 words beginning with consonants\n2 others\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cctype&gt;\n\nint main()\n{\n    using namespace std;\n    char cInput[100];\n    int iNumOther{}, iNumVowels{}, iNumConsonants{};\n\n    cout &lt;&lt; \"\\nEnter words (q to quit):\\n\";\n\n    do\n    {\n        cin &gt;&gt; cInput;\n        if (!isalpha(cInput[0]))\n        {\n            ++iNumOther;\n        }\n        else if (cInput[0] == 'A' || cInput[0] == 'E' ||\n                 cInput[0] == 'I' || cInput[0] == 'O' ||\n                 cInput[0] == 'U' || cInput[0] == 'Y' ||\n                 cInput[0] == 'a' || cInput[0] == 'e' ||\n                 cInput[0] == 'i' || cInput[0] == 'o' ||\n                 cInput[0] == 'u' || cInput[0] == 'y')\n        {\n            ++iNumVowels;\n        }\n        else if (cInput[0] == 'A' || cInput[0] == 'C' || cInput[0] == 'D' ||\n                 cInput[0] == 'F' || cInput[0] == 'G' || cInput[0] == 'J' ||\n                 cInput[0] == 'K' || cInput[0] == 'L' || cInput[0] == 'M' ||\n                 cInput[0] == 'N' || cInput[0] == 'P' || cInput[0] == 'Q' ||\n                 cInput[0] == 'S' || cInput[0] == 'T' || cInput[0] == 'V' ||\n                 cInput[0] == 'X' || cInput[0] == 'Z' ||\n                 cInput[0] == 'a' || cInput[0] == 'c' || cInput[0] == 'd' ||\n                 cInput[0] == 'f' || cInput[0] == 'g' || cInput[0] == 'j' ||\n                 cInput[0] == 'k' || cInput[0] == 'l' || cInput[0] == 'm' ||\n                 cInput[0] == 'n' || cInput[0] == 'p' || cInput[0] == 'q' ||\n                 cInput[0] == 's' || cInput[0] == 't' || cInput[0] == 'v' ||\n                 cInput[0] == 'x' || cInput[0] == 'z')\n        {\n            ++iNumConsonants;\n        }\n        else\n        {\n            ++iNumOther;\n        }\n\n    } while (strcmp(cInput, \"q\"));\n    --iNumConsonants; // q  - at the end detected as word(consonant)\n\n    cout &lt;&lt; iNumVowels &lt;&lt; \" words beginning with vowels\\n\";\n    cout &lt;&lt; iNumConsonants &lt;&lt; \" words beginning with consonants\\n\";\n    cout &lt;&lt; iNumOther &lt;&lt; \" others\\n\";\n\n    return 0;\n}\n\n// Different method - pseudocode\n/*\n\n    char sConsonants[]{'b', 'c', 'd', 'f', 'g', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 's', 't', 'v', 'x', 'z',\n                      'B', 'C', 'D', 'F', 'G', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'S', 'T', 'V', 'X', 'Z'};\n    char sWovels[]{'a', 'e', 'i', 'o', 'u',\n                  'A', 'E', 'I', 'O', 'U'};\n\n        cin &gt;&gt; cInput;\n        if (!isalpha(cInput[0]))\n        {\n            ++iNumOther;\n        }\n        else{\n            for (size_t i = 0; i &lt; 12; i++)\n            {\n                if(cInput[0] == sConsonants[i] || cInput[0] == sConsonants[i+11] || cInput[0] == sConsonants[i + 22]){\n                    ++iNumConsonants;\n                    break;\n                }\n                else (cInput[0] == sWovels[i]){\n                    ++iNumVowels;\n                    break;\n                }\n            }\n        }\n*/\n</code></pre> <p>8 - Write a program that opens a text file, reads it character-by-character to the end of the file, and reports the number of characters in the file.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    using namespace std;\n    int iDataCounter;\n\n    ifstream inFile;\n    inFile.open(\"./Notes/C++PrimerPlus/exercises/exercise_ch6_8.txt\"); //OR ./exercise_ch6_8.txt\n\n    if (!inFile.is_open())\n    {\n        cout &lt;&lt; \"Could not open the file\" &lt;&lt; endl;\n        cout &lt;&lt; \"Program terminating.\\n\";\n    }\n\n    while(inFile.good()){\n        ++iDataCounter;\n\n        char temp;\n        inFile &gt;&gt; temp;\n    }\n\n    cout &lt;&lt; \"\\nnumber of characters in the file \" &lt;&lt; iDataCounter &lt;&lt; endl;\n    inFile.close();\n\n    return 0;\n}\n</code></pre> <p>9 - Do Programming Exercise 6 but modify it to get information from a file.The first item in the file should be the number of contributors, and the rest of the file should consist of pairs of lines, with the first line of each pair being a contributor\u2019s name and the second line being a contribution. That is, the file should look like this:</p> <pre><code>4\nSam Stone\n2000\nFreida Flass\n100500\nTammy Tubbs\n5000\nRich Raptor\n55000\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nstruct stSocietyPRI\n{\n    std::string name;\n    double contribution;\n};\n\nint main()\n{\n    using namespace std;\n    int iContrbutors{}, iCounter{};\n\n    ifstream inFile;\n    inFile.open(\"./Notes/C++PrimerPlus/exercises/exercise_ch6_9.txt\");\n\n    if (!inFile.is_open()) // failed to open file\n    {\n        cout &lt;&lt; \"Could not open the file\" &lt;&lt; endl;\n        cout &lt;&lt; \"Terminate program.\\n\";\n        exit(EXIT_FAILURE);\n    }\n\n    if(inFile.good()){\n        inFile &gt;&gt; iContrbutors; // First line\n    }\n\n    stSocietyPRI *pSociety = new stSocietyPRI[iContrbutors];\n\n    // Read contributors from file \n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        inFile.get(); // clear buffer\n        getline(inFile, pSociety[i].name);\n        inFile &gt;&gt; pSociety[i].contribution;\n    }\n\n    // Print Grand Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Grand Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        if (pSociety[i].contribution &gt;= 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    // Print the rest Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {        if (pSociety[i].contribution &lt; 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"reviews/","title":"Reviews","text":""},{"location":"reviews/#chapter-2-review","title":"Chapter 2 Review","text":"1. What are the modules of C++ programs called?  They are called functions   2. What does the following preprocessor directive do?  ```#include ```  It causes the contents of the iostream file to be substituted for this directive before final compilation.   3. What does the following statement do?  ``using namespace std;``  It makes definitions made in the std namespace available to a program.   4. What statement would you use to print the phrase \u201cHello, world\u201d and then start a new line?  <pre><code>cout &lt;&lt; \"Hello, world\\n\";\n</code></pre>  or  <pre><code>cout &lt;&lt; \"Hello, world\" &lt;&lt; endl;\n</code></pre>  5. What statement would you use to create an integer variable with the name cheeses ?  <pre><code>int cheeses;\n</code></pre>  6. What statement would you use to assign the value 32 to the variable cheeses ?  <pre><code>cheeses = 32;\n</code></pre>  7. What statement would you use to read a value from keyboard input into the \u2003variable cheeses ?  <pre><code>cin &gt;&gt; cheeses;\n</code></pre>  8. What statement would you use to print \u201cWe have X varieties of cheese,\u201d \u2003where the current value of the cheeses variable replaces X ?      <pre><code>cout &lt;&lt; \"We have \" &lt;&lt; cheeses &lt;&lt; \" varieties of cheese\\n\";\n</code></pre>  9. What do the following function prototypes tell you about the functions?  <pre><code>int prune(void);\nint froop(double t);\nvoid rattle(int n);\n</code></pre>   The function froop() expects to be called with one argument, which will be type double, and that the function will return a type int value. For instance, it could be used as follows: ``int gval = froop(3.14159);``  The function rattle() has no return value and expects an int argument. For instance, it could be used as follows: ``rattle(37);``  The function prune() returns an int and expects to be used without an argument. For instance, it could be used as follows: ``int residue = prune();``   10.  When do you not have to use the keyword return when you define a function?   You don\u2019t have to use return in a function when the function has the return type `void`. However, you can use it if you don\u2019t give a return value: ``return;``   11. Suppose your main() function has the following line:  ``cout &lt;&lt; \u201cPlease enter your PIN: \u201c;`` And suppose the compiler complains that cout is an unknown identifier. What is the likely cause of this complaint, and what are three ways to fix the problem?      ***Lack of caller for std library.*** Use directive: ``using namespace std;`` or ``using std::cout`` for only `cout` or call library with `std::cout` instead of `cout`"},{"location":"reviews/#chapter-3-review","title":"Chapter 3 Review","text":"1. Why does C++ have more than one integer type?   Having more than one integer type lets you choose the type that is best suited to a particular need. For example, you could use `short` to conserve space or `long to guarantee storage capacity or to find that a particular type speeds up a particular calculation.    2. Declare variables matching the following descriptions: \u00a0\u00a0\u00a0\u00a0\u00a0 a. A short integer with the value 80 \u00a0\u00a0\u00a0\u00a0\u00a0 b. An unsigned int integer with the value 42,110 \u00a0\u00a0\u00a0\u00a0\u00a0 c. An integer with the value 3,000,000,000      <pre><code>short rbis = 80; // or short int rbis = 80;\nunsigned int q = 42110; // or unsigned q = 42110;\nunsigned long ants = 3000000000;\n// or long long ants = 3000000000;\n\n//Note: Don\u2019t count on int being large enough to hold 3,000,000,000.Also if your\n//system supports universal list-initialization, you could use it:\nshort rbis = {80}; // = is optional\nunsigned int q {42110}; // could use = {42110}\nlong long ants {3000000000};\n</code></pre>  3. What safeguards does C++ provide to keep you from exceeding the limits of an integer type?       C++ provides no automatic safeguards to keep you from exceeding integer limits; you can use the climits header file to determine what the limits are.   4. What is the distinction between 33L and 33?       The constant 33L is type long, whereas the constant 33 is type int.   5. Consider the two C++ statements that follow:  <pre><code>char grade = 65;\nchar grade = 'A';\n</code></pre>  Are they equivalent?       The two statements are not really equivalent, although they have the same effect on some systems. Most importantly, the first statement assigns the letter `A` to grade only on a system using the `ASCII` code, while the second statement also works for other codes. Second, `65` is a type int constant, whereas `'A'` is a type char constant.   6. How could you use C++ to find out which character the code 88 represents? Come up with at least two ways.       Here are four ways:  <pre><code>char c = 88;\ncout &lt;&lt; c &lt;&lt; endl; // char type prints as character\ncout.put(char(88)); // put() prints char as character\ncout &lt;&lt; char(88) &lt;&lt; endl; // new-style type cast value to char\ncout &lt;&lt; (char)88 &lt;&lt; endl; // old-style type cast value to char\n</code></pre>  7. Assigning a `long` value to a `float` can result in a rounding error. What about assigning `long` to `double`? `long long` to `double`?       The answer depends on how large the two types are. If `long` is 4 bytes, there is no loss. That\u2019s because the largest `long` value would be about 2 billion, which is 10 digits. Because `double` provides at least 13 significant figures, no rounding would be needed. The `long long` type, on the other hand, can reach 19 digits, which exceeds the 13 significant figures guaranteed for `double`.   8. Evaluate the following expressions as C++ would:  <pre><code>a. 8 * 9 + 2 \nb. 6 * 3 / 4 \nc. 3 / 4 * 6 \nd. 6.0 * 3 / 4 \ne. 15 % 4 \n</code></pre> <pre><code>a. 8 * 9 + 2 is 72 + 2 is 74\nb. 6 * 3 / 4 is 18 / 4 is 4\nc. 3 / 4 * 6 is 0 * 6 is 0\nd. 6.0 * 3 / 4 is 18.0 / 4 is 4.5\ne. 15 % 4 is 3\n</code></pre>  9.  Suppose `x1` and `x2` are two type `double` variables that you want to add as `integers` and assign to an `integer` variable. Construct a C++ statement for doing so. What if you want to add them as type `double` and then convert to `int`?    Either of the following would work for the first task:  <pre><code>int pos = (int) x1 + (int) x2;\nint pos = int(x1) + int(x2);\n</code></pre>  To add them as type double and then convert, you could do either of the following:  <pre><code>int pos = (int) (x1 + x2);\nint pos = int(x1 + x2);\n</code></pre>  10.  What is the variable type for each of the following declarations?  <pre><code>a. `auto cars = 15;` \nb. `auto iou = 150.37f;`\nc. `auto level = 'B';` \nd. `auto crat = U'/U00002155';` \ne. `auto fract = 8.25f/2.5;` \n</code></pre> <pre><code>a. int\nb. float\nc. char\nd. char32_t\ne. double\n</code></pre>"},{"location":"reviews/#chapter-4-review","title":"Chapter 4 Review","text":"1. How would you declare each of the following?  <pre><code>a. actors is an array of 30 char.\nb. betsie is an array of 100 short.\nc. chuck is an array of 13 float.\nd. dipsea is an array of 64 long double.\n</code></pre> <pre><code>char actors[30];\nshort betsie[100];\nfloat chuck[13];\nlong double dipsea[64];\n</code></pre>  2. Do Chapter Review Question 1 and use the array template class instead of built-in arrays.      <pre><code>array&lt;char, 30&gt; actors;\narray&lt;short, 100&gt; betsie;\narray&lt;float, 13&gt; chuck;\narray&lt;long double, 64&gt; dipsea;\n</code></pre>  3. Declare an array of five ints and initialize it to the first five odd positive integers      <pre><code>int oddly[5] = {1, 3, 5, 7, 9};\narray&lt;int, 5&gt; at {1, 3, 5, 7, 9}; // also correct\n</code></pre>  4. Write a statement that assigns the sum of the first and last elements of the array in Question 3 to the variable even.      <pre><code>int even = array[0] + array[4]; \n</code></pre>  5. Write a statement that displays the value of the second element in the float array ideas.      <pre><code>std::cout &lt;&lt; ideas[1];\n</code></pre>  6. Declare an array of char and initialize it to the string \"cheeseburger\".      <pre><code>char food[] {\"cheeseburger\"};\n// or\nchar lunch[13] = \"cheeseburger\"; // number of characters + 1\n</code></pre>  7. Declare a string object and initialize it to the string \"Waldorf Salad\".      <pre><code>std::string obj = \"Waldorf Salad\";\n</code></pre>  8. Devise a structure declaration that describes a fish.The structure should include the kind, the weight in whole ounces, and the length in fractional inches.      <pre><code>struct fish {\n    char kind[20];\n    int weight;\n    float length;\n};\n</code></pre>  9. Declare a variable of the type defined in Question 8 and initialize it.      <pre><code>fish petes =\n{\n    \"trout\",\n    12,\n    26.25\n};\n\n// fish flounder; //??\n// flounder.kind = \"fishy\";\n// flounder.weight = 21;\n// flounder.length = 21;\n</code></pre>  10.  Use enum to define a type called Response with the possible values Yes, No, and Maybe. Yes should be 1, No should be 0, and Maybe should be 2.      <pre><code>enum response {No, Yes, Maybe};\n</code></pre>  11.  Suppose ted is a double variable. Declare a pointer that points to ted and use the pointer to display ted\u2019s value.      <pre><code>double *ptrTed = &amp;ted;\nstd::cout &lt;&lt; *ptrTed;\n</code></pre>  12.  Suppose treacle is an array of 10 floats. Declare a pointer that points to the first element of treacle and use the pointer to display the first and last elements of the array.      <pre><code>float *ptrTreacle = treacle; // or = &amp;treacle[0]\ncout &lt;&lt; pf[0] &lt;&lt; \" \" &lt;&lt; pf[9] &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; ptrTreacle[0] &lt;&lt; \"last\" &lt;&lt; ptrTreacle[9];\n// or use:\n// std::cout &lt;&lt; *(ptrTreacle + 1) &lt;&lt; \"last\" &lt;&lt; *(ptrTreacle + 9);\n</code></pre>  13. Write a code fragment that asks the user to enter a positive integer and then creates a dynamic array of that many ints. Do this by using new, then again using a vector object.      <pre><code>unsigned int iUsr {};\ncout &lt;&lt; \"Enter a positive integer: \";\nstd::cin &gt;&gt; iUsr;\n\nint *sth = new int[iUsr];\nvector&lt;int&gt; sth(iUsr);\n</code></pre>  14. Is the following valid code? If so, what does it print?  <pre><code>cout &lt;&lt; (int *) \u201cHome of the jolly bytes\u201d;\n</code></pre>   //Yes //Start of memory of this Literal Yes, it is valid.The expression \"Home of the jolly bytes\" is a string constant; hence it evaluates as the address of the beginning of the string.The cout object interprets the address of a char as an invitation to print a string, but the type cast (int *) converts the address to type pointer-to-int, which is then printed as an address. In short, the statement prints the address of the string, assuming the int type is wide enough to hold an address.   15. Write a code fragment that dynamically allocates a structure of the type described in Question 8 and then reads a value for the `kind` member of the structure.      <pre><code>struct fish\n{\n    char kind[20];\n    int weight;\n    float length;\n};\n\nint main(){\n    fish * pole = new fish;    \n\n    std::cout &lt;&lt; \"Enter kind of fish: \";\n    std::cin &gt;&gt; pole-&gt;kind;\n}\n</code></pre>  16. Listing 4.6 illustrates a problem created by following numeric input with line-oriented string input. How would replacing:  <pre><code>// this:\ncin.getline(address,80);\n// with this:\ncin &gt;&gt; address;\n// affect the working of this program?\n</code></pre>   //cin &gt;&gt; address will read from user only to the space. Data after space will be in the queue; Using cin &gt;&gt; address causes a program to skip over whitespace until it finds nonwhitespace. It then reads characters until it encounters whitespace again.Thus, it will skip over the newline following the numeric input, avoiding that problem. On the other hand, it will read just a single word, not an entire line.   17. Declare a vector object of 10 string objects and an array object of 10 string objects. Show the necessary header files and don\u2019t use using. Do use a const for the number of strings.  <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\n// vector&lt;string&gt; vSth(10);\n// array&lt;string, 10&gt; aSth;\n\nconst int Str_num {10}; // or = 10\n...\nstd::vector&lt;std::string&gt; vstr(Str_num);\nstd::array&lt;std::string, Str_num&gt; astr;\n</code></pre>"},{"location":"reviews/#chapter-5-review","title":"Chapter 5 Review","text":"1. What\u2019s the difference between an entry-condition loop and an exit-condition loop? Which kind is each of the C++ loops?      // entry-condition loop - check condition before entering the loop  // exit-condition loop -  check condition at the end of loop, making at least 1 loop  An entry-condition loop evaluates a test expression before entering the body of the loop. If the condition is initially false, the loop never executes its body.An exitcondition loop evaluates a test expression after processing the body of the loop. Thus, the loop body is executed once, even if the test expression is initially false. The for and while loops are entry-condition loops, and the do while loop is an exit-condition loop   2. What would the following code fragment print if it were part of a valid program?  <pre><code>int i;\nfor (i = 0; i &lt; 5; i++)\n    cout &lt;&lt; i;\n    cout &lt;&lt; endl;\n</code></pre>  01234  Note that cout &lt;&lt; endl; is not part of the loop body (because there are no braces).   3. What would the following code fragment print if it were part of a valid program?  <pre><code>int j;\nfor (j = 0; j &lt; 11; j += 3)\n    cout &lt;&lt; j;\ncout &lt;&lt; endl &lt;&lt; j &lt;&lt; endl;\n</code></pre>  It would print the following: 0369 12  4. What would the following code fragment print if it were part of a valid program?  <pre><code>int j = 5;\nwhile ( ++j &lt; 9)\n    cout &lt;&lt; j++ &lt;&lt; endl;\n</code></pre>  It would print the following: 6 8   5. What would the following code fragment print if it were part of a valid program?  <pre><code>int k = 8;\ndo\n    cout &lt;&lt;\" k = \" &lt;&lt; k &lt;&lt; endl;\nwhile (k++ &lt; 5);\n</code></pre>  It would print the following: k = 8   6. Write a `for` loop that prints the values 1 2 4 8 16 32 64 by increasing the value of a counting variable by a factor of two in each cycle.      It\u2019s simplest to use the *= operator: <pre><code>for(int i {}; i &lt; 65; i *= 2)\n    cout &lt;&lt; i &lt;&lt; \" \";\n</code></pre>  7. How do you make a loop body include more than one statement?      //add curly braces {}   You enclose the statements within paired braces to form a single compound statement, or block.   8. Is the following statement valid? If not, why not? If so, what does it do?  <pre><code>int x = (1,024);\n</code></pre>  What about the following?  <pre><code>int y;\ny = 1,024;\n</code></pre>  //1st is valid, but 1 will be assigned to x due to precedence and first value will do nothing  //in 2nd 1 will be assigned to y, and 024 will do nothing, but confuse.   Yes, the first statement is valid.The expression 1,024 consists of two expressions\u20141 and 024\u2014joined by a comma operator.The value is the value of the right-hand expression.This is 024, which is octal for 20, so the declaration assigns the value 20 to x.The second statement is also valid. However, operator precedence causes it to be evaluated as follows:  <pre><code>(y = 1), 024;\n</code></pre>  That is, the left expression sets y to 1, and the value of the entire expression, which isn\u2019t used, is `024`, or `20`.    9. How does cin &gt;&gt; ch differ from cin.get(ch) and ch=cin.get() in how it views input?      //cin&gt;&gt;ch will omit spaces, cin.get(ch) will return bool true, false if EOF, ch=cin.get() will assign int value and EOF if EOF   The `cin &gt;&gt; ch` form skips over spaces, newlines, and tabs when it encounters them. The other two forms read those characters"},{"location":"reviews/#chapter-6-review","title":"Chapter 6 Review","text":"1. Consider the following two code fragments for counting spaces and newlines  <pre><code>// Version 1\nwhile (cin.get(ch)) // quit on eof\n{\n    if (ch == ' ')\n        spaces++;\n    if (ch == '\\n')\n        newlines++;\n}\n// Version 2\nwhile (cin.get(ch)) // quit on eof\n{\n    if (ch == ' ')\n        spaces++;\n    else if (ch == '\\n')\n        newlines++;\n}\n</code></pre>  What advantages, if any, does the second form have over the first?  // Because version 1 checks every times both conditions, thus it's less efficient. // Version 2 checks 2 condition only if first is not true.  Both versions give the same answers, but the if else version is more efficient. Consider what happens, for example, when ch is a space.Version 1, after incrementing spaces, tests whether the character is a newline.This wastes time because the program has already established that ch is a space and hence could not be a newline. Version 2, in the same situation, skips the newline test.   2. In Listing 6.2, what is the effect of replacing ++ch with ch+1?  <pre><code>Listing 6.2 ifelse.cpp\n// ifelse.cpp -- using the if else statement\n#include &lt;iostream&gt;\n    int\n    main()\n{\n    char ch;\n    std::cout &lt;&lt; \"Type, and I shall repeat.\\n\";\n    std::cin.get(ch);\n    while (ch != '.')\n    {\n        if (ch == '\\n')\n            std::cout &lt;&lt; ch; // done if newline\n        else\n            std::cout &lt;&lt; ++ch; // done otherwise\n        std::cin.get(ch);\n    }\n    std::cout &lt;&lt; \"\\nPlease excuse the slight confusion.\\n\";\n    return 0;\n}\n</code></pre>   // The `char` is promoted to `int`, and display numbers  Both `++ch` and `ch + 1` have the same numerical value. But `++ch` is type char and prints as a character, while `ch + 1`, because it adds a `char` to an `int`, is type `int` and prints as a number.    3. Carefully consider the following program:  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    char ch;\n    int ct1, ct2;\n    ct1 = ct2 = 0;\n    while ((ch = cin.get()) != '$')\n    {\n        cout &lt;&lt; ch;\n        ct1++;\n        if (ch = '$')\n            ct2++;\n        cout &lt;&lt; ch;\n    }\n    cout &lt;&lt; \"ct1 = \" &lt;&lt; ct1 &lt;&lt; \", ct2 = \" &lt;&lt; ct2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>  Suppose you provide the following input, pressing the Enter key at the end of each line:  <pre><code>Hi!\nSend $10 or $20 now!\n</code></pre>  What is the output? (Recall that input is buffered.)       // Program print after every read character `$` and if in input is `$`, the while loop will end. // `Hi!` // `H$i$!$` // `$Send $10 or $20 now!` // `S$e$n$d$ $ct1 = 8, ct2 = 8` // `$` is added even newline, and `ct` is added with it, I didn't include that  Because the program uses `ch = '$'` instead of `ch == '$'`, the combined input and output looks like this:  <pre><code>Hi!\nH$i$!$\n$Send $10 or $20 now!\nS$e$n$d$ $ct1 = 9, ct2 = 9\n</code></pre>  Each character is converted to the `$` character before being printed the second time.Also the value of the expression `ch = $` is the code for the `$` character, hence nonzero, hence `true`; so `ct2` is incremented each time.   4. Construct logical expressions to represent the following conditions:  <pre><code>    a. weight is greater than or equal to 115 but less than 125.\n    b. ch is q or Q.\n    c. x is even but is not 26.\n    d. x is even but is not a multiple of 26.\n    e. donation is in the range 1,000\u20132,000 or guest is 1.\n    f. ch is a lowercase letter or an uppercase letter. (Assume, as is true for ASCII, \n    that lowercase letters are coded sequentially and that uppercase letters are coded \n    sequentially but that there is a gap in the code between uppercase and lowercase.)\n</code></pre> <pre><code>weight &gt;= 115 &amp;&amp; weight &lt; 125                           //a\nch == `q` || ch == `Q`                                  //b\nx % 2 == 0 &amp;&amp; x != 26                                   //c\n\nx % 2 == 0 &amp;&amp; x % 26 != 0                               //d\nx % 2 == 0 &amp;&amp; !(x % 26 == 0)                            //d\ndonation &gt;= 1000 &amp;&amp; donation &lt;= 2000 || guest == 1      //e\n\n(ch =&gt; `a` &amp;&amp; ch &lt;= z) || (ch &gt;= `A` &amp;&amp; ch &lt;= `Z`)      //f\nisalpha(ch)                                             //f\n</code></pre>  5. In English, the statement \u201cI will not not speak\u201d means the same as \u201cI will speak.\u201d In C++, is !!x the same as x?       // No. Return from `!!x` is boolean/int, while `x` have defined type by programmer  Not necessarily. For example, if `x` is 10, then `!x` is 0 and `!!x` is 1. However, if `x` is a `bool` variable, then `!!x` is `x`.   6. Construct a conditional expression that is equal to the absolute value of a variable. That is, if a variable x is positive, the value of the expression is just x, but if x is negative, the value of the expression is -x, which is positive.      <pre><code>// x &gt; 0 ? x : -x\n\n(x &lt; 0)? -x : x\n// or\n(x &gt;= 0)? x : -x;\n</code></pre>  7. Rewrite the following fragment using switch:  <pre><code>if (ch == 'A')\n    a_grade++;\nelse if (ch == 'B')\n    b_grade++;\nelse if (ch == 'C')\n    c_grade++;\nelse if (ch == 'D')\n    d_grade++;\nelse\n    f_grade++;\n</code></pre> <pre><code>switch (ch)\n{\n    case `A`:   a_grade++;\n                break;\n    case `B`:   b_grade++;\n                break;\n    case `C`:   c_grade++;\n                break;\n    case `D`:   d_grade++;\n                break;\n    default:    f_grade++;\n                break;\n}\n</code></pre>  8. In Listing 6.10, what advantage would there be in using character labels, such as a and c, instead of numbers for the menu choices and switch cases? (Hint:Think about what happens if the user types q in either case and what happens if the user types 5 in either case.)  <pre><code>Listing 6.10 switch.cpp\n// switch.cpp -- using the switch statement\n#include &lt;iostream&gt;\n    using namespace std;\nvoid showmenu(); // function prototypes\nvoid report();\nvoid comfort();\nint main()\n{\n    showmenu();\n    int choice;\n    cin &gt;&gt; choice;\n    while (choice != 5)\n    {\n        switch (choice)\n        {\n        case 1:\n            cout &lt;&lt; \"\\a\\n\";\n            break;\n        case 2:\n            report();\n            break;\n        case 3:\n            cout &lt;&lt; \"The boss was in all day.\\n\";\n            break;\n        case 4:\n            comfort();\n            break;\n        default:\n            cout &lt;&lt; \"That's not a choice.\\n\";\n        }\n        showmenu();\n        cin &gt;&gt; choice;\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\nvoid showmenu()\n{\n    cout &lt;&lt; \"Please enter 1, 2, 3, 4, or 5:\\n\"\n            \"1) alarm 2) report\\n\"\n            \"3) alibi 4) comfort\\n\"\n            \"5) quit\\n\";\n}\nvoid report()\n{\n    cout &lt;&lt; \"It's been an excellent week for business.\\n\"\n            \"Sales are up 120%. Expenses are down 35%.\\n\";\n}\nvoid comfort()\n{\n    cout &lt;&lt; \"Your employees think you are the finest CEO\\n\"\n            \"in the industry. The board of directors think\\n\"\n            \"you are the finest CEO in the industry.\\n\";\n}\n</code></pre>  // Character labels would be more resistant to invalid input (characters promoted to int instead numbers); // It would also not go into infinite loop due to buffered characters from user input    If you use integer labels and the user types a noninteger such as q, the program hangs because integer input can\u2019t process a character. But if you use character labels and the user types an integer such as 5, character input will process 5 as a character. Then the default part of the switch can suggest entering another character.   9. Consider the following code fragment:  <pre><code>int line = 0;\nchar ch;\nwhile (cin.get(ch))\n{\n    if (ch == 'Q')\n        break;\n    if (ch != '\\n')\n        continue;\n    line++;\n}\n</code></pre>  Rewrite this code without using break or continue.      <pre><code>int line = 0;\nchar ch;\nwhile (cin.get(ch) &amp;&amp; ch != 'Q')\n{\n    if (ch == '\\n')\n        line++;\n}\n</code></pre>"}]}